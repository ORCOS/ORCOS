   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"memp.c"
  19              	.Ltext0:
  20              		.bss
  21              		.align	2
  22              	memp_tab:
  23 0000 00000000 		.space	52
  23      00000000 
  23      00000000 
  23      00000000 
  23      00000000 
  24              		.section	.rodata
  25              		.align	2
  28              	memp_sizes:
  29 0000 1C00     		.short	28
  30 0002 2000     		.short	32
  31 0004 8C00     		.short	140
  32 0006 1C00     		.short	28
  33 0008 1400     		.short	20
  34 000a 1000     		.short	16
  35 000c 2C00     		.short	44
  36 000e 1400     		.short	20
  37 0010 1400     		.short	20
  38 0012 0800     		.short	8
  39 0014 1000     		.short	16
  40 0016 1000     		.short	16
  41 0018 5E02     		.short	606
  42 001a 0000     		.align	2
  45              	memp_num:
  46 001c 0400     		.short	4
  47 001e 0400     		.short	4
  48 0020 0500     		.short	5
  49 0022 0800     		.short	8
  50 0024 1000     		.short	16
  51 0026 0200     		.short	2
  52 0028 0400     		.short	4
  53 002a 0800     		.short	8
  54 002c 0800     		.short	8
  55 002e 1E00     		.short	30
  56 0030 0300     		.short	3
  57 0032 1000     		.short	16
  58 0034 1000     		.short	16
  59 0036 0000     		.bss
  60              		.align	2
  61              	memp_memory:
  62 0034 00000000 		.space	12252
  62      00000000 
  62      00000000 
  62      00000000 
  62      00000000 
  63              		.text
  64              		.align	2
  65              		.global	memp_init
  67              	memp_init:
  68              	.LFB0:
  69              		.file 1 "./src/lwip/core/memp.c"
   1:./src/lwip/core/memp.c **** /**
   2:./src/lwip/core/memp.c ****  * @file
   3:./src/lwip/core/memp.c ****  * Dynamic pool memory manager
   4:./src/lwip/core/memp.c ****  *
   5:./src/lwip/core/memp.c ****  * lwIP has dedicated pools for many structures (netconn, protocol control blocks,
   6:./src/lwip/core/memp.c ****  * packet buffers, ...). All these pools are managed here.
   7:./src/lwip/core/memp.c ****  */
   8:./src/lwip/core/memp.c **** 
   9:./src/lwip/core/memp.c **** /*
  10:./src/lwip/core/memp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  11:./src/lwip/core/memp.c ****  * All rights reserved. 
  12:./src/lwip/core/memp.c ****  * 
  13:./src/lwip/core/memp.c ****  * Redistribution and use in source and binary forms, with or without modification, 
  14:./src/lwip/core/memp.c ****  * are permitted provided that the following conditions are met:
  15:./src/lwip/core/memp.c ****  *
  16:./src/lwip/core/memp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:./src/lwip/core/memp.c ****  *    this list of conditions and the following disclaimer.
  18:./src/lwip/core/memp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:./src/lwip/core/memp.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:./src/lwip/core/memp.c ****  *    and/or other materials provided with the distribution.
  21:./src/lwip/core/memp.c ****  * 3. The name of the author may not be used to endorse or promote products
  22:./src/lwip/core/memp.c ****  *    derived from this software without specific prior written permission. 
  23:./src/lwip/core/memp.c ****  *
  24:./src/lwip/core/memp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
  25:./src/lwip/core/memp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
  26:./src/lwip/core/memp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
  27:./src/lwip/core/memp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
  28:./src/lwip/core/memp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
  29:./src/lwip/core/memp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  30:./src/lwip/core/memp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  31:./src/lwip/core/memp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
  32:./src/lwip/core/memp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  33:./src/lwip/core/memp.c ****  * OF SUCH DAMAGE.
  34:./src/lwip/core/memp.c ****  *
  35:./src/lwip/core/memp.c ****  * This file is part of the lwIP TCP/IP stack.
  36:./src/lwip/core/memp.c ****  * 
  37:./src/lwip/core/memp.c ****  * Author: Adam Dunkels <adam@sics.se>
  38:./src/lwip/core/memp.c ****  *
  39:./src/lwip/core/memp.c ****  */
  40:./src/lwip/core/memp.c **** 
  41:./src/lwip/core/memp.c **** #include "lwip/opt.h"
  42:./src/lwip/core/memp.c **** 
  43:./src/lwip/core/memp.c **** #include "lwip/memp.h"
  44:./src/lwip/core/memp.c **** #include "lwip/pbuf.h"
  45:./src/lwip/core/memp.c **** #include "lwip/udp.h"
  46:./src/lwip/core/memp.c **** #include "lwip/raw.h"
  47:./src/lwip/core/memp.c **** #include "lwip/tcp.h"
  48:./src/lwip/core/memp.c **** #include "lwip/igmp.h"
  49:./src/lwip/core/memp.c **** #include "lwip/api.h"
  50:./src/lwip/core/memp.c **** #include "lwip/api_msg.h"
  51:./src/lwip/core/memp.c **** #include "lwip/tcpip.h"
  52:./src/lwip/core/memp.c **** #include "lwip/sys.h"
  53:./src/lwip/core/memp.c **** #include "lwip/stats.h"
  54:./src/lwip/core/memp.c **** #include "netif/etharp.h"
  55:./src/lwip/core/memp.c **** #include "lwip/ip_frag.h"
  56:./src/lwip/core/memp.c **** 
  57:./src/lwip/core/memp.c **** #include <string.h>
  58:./src/lwip/core/memp.c **** 
  59:./src/lwip/core/memp.c **** #if !MEMP_MEM_MALLOC /* don't build if not configured for use in lwipopts.h */
  60:./src/lwip/core/memp.c **** 
  61:./src/lwip/core/memp.c **** struct memp {
  62:./src/lwip/core/memp.c ****   struct memp *next;
  63:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
  64:./src/lwip/core/memp.c ****   const char *file;
  65:./src/lwip/core/memp.c ****   int line;
  66:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
  67:./src/lwip/core/memp.c **** };
  68:./src/lwip/core/memp.c **** 
  69:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
  70:./src/lwip/core/memp.c **** /* if MEMP_OVERFLOW_CHECK is turned on, we reserve some bytes at the beginning
  71:./src/lwip/core/memp.c ****  * and at the end of each element, initialize them as 0xcd and check
  72:./src/lwip/core/memp.c ****  * them later. */
  73:./src/lwip/core/memp.c **** /* If MEMP_OVERFLOW_CHECK is >= 2, on every call to memp_malloc or memp_free,
  74:./src/lwip/core/memp.c ****  * every single element in each pool is checked!
  75:./src/lwip/core/memp.c ****  * This is VERY SLOW but also very helpful. */
  76:./src/lwip/core/memp.c **** /* MEMP_SANITY_REGION_BEFORE and MEMP_SANITY_REGION_AFTER can be overridden in
  77:./src/lwip/core/memp.c ****  * lwipopts.h to change the amount reserved for checking. */
  78:./src/lwip/core/memp.c **** #ifndef MEMP_SANITY_REGION_BEFORE
  79:./src/lwip/core/memp.c **** #define MEMP_SANITY_REGION_BEFORE  16
  80:./src/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_BEFORE*/
  81:./src/lwip/core/memp.c **** #if MEMP_SANITY_REGION_BEFORE > 0
  82:./src/lwip/core/memp.c **** #define MEMP_SANITY_REGION_BEFORE_ALIGNED    LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_BEFORE)
  83:./src/lwip/core/memp.c **** #else
  84:./src/lwip/core/memp.c **** #define MEMP_SANITY_REGION_BEFORE_ALIGNED    0
  85:./src/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_BEFORE*/
  86:./src/lwip/core/memp.c **** #ifndef MEMP_SANITY_REGION_AFTER
  87:./src/lwip/core/memp.c **** #define MEMP_SANITY_REGION_AFTER   16
  88:./src/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_AFTER*/
  89:./src/lwip/core/memp.c **** #if MEMP_SANITY_REGION_AFTER > 0
  90:./src/lwip/core/memp.c **** #define MEMP_SANITY_REGION_AFTER_ALIGNED     LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_AFTER)
  91:./src/lwip/core/memp.c **** #else
  92:./src/lwip/core/memp.c **** #define MEMP_SANITY_REGION_AFTER_ALIGNED     0
  93:./src/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_AFTER*/
  94:./src/lwip/core/memp.c **** 
  95:./src/lwip/core/memp.c **** /* MEMP_SIZE: save space for struct memp and for sanity check */
  96:./src/lwip/core/memp.c **** #define MEMP_SIZE          (LWIP_MEM_ALIGN_SIZE(sizeof(struct memp)) + MEMP_SANITY_REGION_BEFORE_AL
  97:./src/lwip/core/memp.c **** #define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x) + MEMP_SANITY_REGION_AFTER_ALIGNED)
  98:./src/lwip/core/memp.c **** 
  99:./src/lwip/core/memp.c **** #else /* MEMP_OVERFLOW_CHECK */
 100:./src/lwip/core/memp.c **** 
 101:./src/lwip/core/memp.c **** /* No sanity checks
 102:./src/lwip/core/memp.c ****  * We don't need to preserve the struct memp while not allocated, so we
 103:./src/lwip/core/memp.c ****  * can save a little space and set MEMP_SIZE to 0.
 104:./src/lwip/core/memp.c ****  */
 105:./src/lwip/core/memp.c **** #define MEMP_SIZE           0
 106:./src/lwip/core/memp.c **** #define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x))
 107:./src/lwip/core/memp.c **** 
 108:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 109:./src/lwip/core/memp.c **** 
 110:./src/lwip/core/memp.c **** /** This array holds the first free element of each pool.
 111:./src/lwip/core/memp.c ****  *  Elements form a linked list. */
 112:./src/lwip/core/memp.c **** static struct memp *memp_tab[MEMP_MAX];
 113:./src/lwip/core/memp.c **** 
 114:./src/lwip/core/memp.c **** #else /* MEMP_MEM_MALLOC */
 115:./src/lwip/core/memp.c **** 
 116:./src/lwip/core/memp.c **** #define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x))
 117:./src/lwip/core/memp.c **** 
 118:./src/lwip/core/memp.c **** #endif /* MEMP_MEM_MALLOC */
 119:./src/lwip/core/memp.c **** 
 120:./src/lwip/core/memp.c **** /** This array holds the element sizes of each pool. */
 121:./src/lwip/core/memp.c **** #if !MEM_USE_POOLS && !MEMP_MEM_MALLOC
 122:./src/lwip/core/memp.c **** static
 123:./src/lwip/core/memp.c **** #endif
 124:./src/lwip/core/memp.c **** const u16_t memp_sizes[MEMP_MAX] = {
 125:./src/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),
 126:./src/lwip/core/memp.c **** #include "lwip/memp_std.h"
 127:./src/lwip/core/memp.c **** };
 128:./src/lwip/core/memp.c **** 
 129:./src/lwip/core/memp.c **** #if !MEMP_MEM_MALLOC /* don't build if not configured for use in lwipopts.h */
 130:./src/lwip/core/memp.c **** 
 131:./src/lwip/core/memp.c **** /** This array holds the number of elements in each pool. */
 132:./src/lwip/core/memp.c **** static const u16_t memp_num[MEMP_MAX] = {
 133:./src/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc)  (num),
 134:./src/lwip/core/memp.c **** #include "lwip/memp_std.h"
 135:./src/lwip/core/memp.c **** };
 136:./src/lwip/core/memp.c **** 
 137:./src/lwip/core/memp.c **** /** This array holds a textual description of each pool. */
 138:./src/lwip/core/memp.c **** #ifdef LWIP_DEBUG
 139:./src/lwip/core/memp.c **** static const char *memp_desc[MEMP_MAX] = {
 140:./src/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc)  (desc),
 141:./src/lwip/core/memp.c **** #include "lwip/memp_std.h"
 142:./src/lwip/core/memp.c **** };
 143:./src/lwip/core/memp.c **** #endif /* LWIP_DEBUG */
 144:./src/lwip/core/memp.c **** 
 145:./src/lwip/core/memp.c **** /** This is the actual memory used by the pools. */
 146:./src/lwip/core/memp.c **** static u8_t memp_memory[MEM_ALIGNMENT - 1 
 147:./src/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )
 148:./src/lwip/core/memp.c **** #include "lwip/memp_std.h"
 149:./src/lwip/core/memp.c **** ];
 150:./src/lwip/core/memp.c **** 
 151:./src/lwip/core/memp.c **** #if MEMP_SANITY_CHECK
 152:./src/lwip/core/memp.c **** /**
 153:./src/lwip/core/memp.c ****  * Check that memp-lists don't form a circle
 154:./src/lwip/core/memp.c ****  */
 155:./src/lwip/core/memp.c **** static int
 156:./src/lwip/core/memp.c **** memp_sanity(void)
 157:./src/lwip/core/memp.c **** {
 158:./src/lwip/core/memp.c ****   s16_t i, c;
 159:./src/lwip/core/memp.c ****   struct memp *m, *n;
 160:./src/lwip/core/memp.c **** 
 161:./src/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; i++) {
 162:./src/lwip/core/memp.c ****     for (m = memp_tab[i]; m != NULL; m = m->next) {
 163:./src/lwip/core/memp.c ****       c = 1;
 164:./src/lwip/core/memp.c ****       for (n = memp_tab[i]; n != NULL; n = n->next) {
 165:./src/lwip/core/memp.c ****         if (n == m && --c < 0) {
 166:./src/lwip/core/memp.c ****           return 0;
 167:./src/lwip/core/memp.c ****         }
 168:./src/lwip/core/memp.c ****       }
 169:./src/lwip/core/memp.c ****     }
 170:./src/lwip/core/memp.c ****   }
 171:./src/lwip/core/memp.c ****   return 1;
 172:./src/lwip/core/memp.c **** }
 173:./src/lwip/core/memp.c **** #endif /* MEMP_SANITY_CHECK*/
 174:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 175:./src/lwip/core/memp.c **** /**
 176:./src/lwip/core/memp.c ****  * Check if a memp element was victim of an overflow
 177:./src/lwip/core/memp.c ****  * (e.g. the restricted area after it has been altered)
 178:./src/lwip/core/memp.c ****  *
 179:./src/lwip/core/memp.c ****  * @param p the memp element to check
 180:./src/lwip/core/memp.c ****  * @param memp_size the element size of the pool p comes from
 181:./src/lwip/core/memp.c ****  */
 182:./src/lwip/core/memp.c **** static void
 183:./src/lwip/core/memp.c **** memp_overflow_check_element(struct memp *p, u16_t memp_size)
 184:./src/lwip/core/memp.c **** {
 185:./src/lwip/core/memp.c ****   u16_t k;
 186:./src/lwip/core/memp.c ****   u8_t *m;
 187:./src/lwip/core/memp.c **** #if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
 188:./src/lwip/core/memp.c ****   m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
 189:./src/lwip/core/memp.c ****   for (k = 0; k < MEMP_SANITY_REGION_BEFORE_ALIGNED; k++) {
 190:./src/lwip/core/memp.c ****     if (m[k] != 0xcd) {
 191:./src/lwip/core/memp.c ****       LWIP_ASSERT("detected memp underflow!", 0);
 192:./src/lwip/core/memp.c ****     }
 193:./src/lwip/core/memp.c ****   }
 194:./src/lwip/core/memp.c **** #endif
 195:./src/lwip/core/memp.c **** #if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
 196:./src/lwip/core/memp.c ****   m = (u8_t*)p + MEMP_SIZE + memp_size;
 197:./src/lwip/core/memp.c ****   for (k = 0; k < MEMP_SANITY_REGION_AFTER_ALIGNED; k++) {
 198:./src/lwip/core/memp.c ****     if (m[k] != 0xcd) {
 199:./src/lwip/core/memp.c ****       LWIP_ASSERT("detected memp overflow!", 0);
 200:./src/lwip/core/memp.c ****     }
 201:./src/lwip/core/memp.c ****   }
 202:./src/lwip/core/memp.c **** #endif
 203:./src/lwip/core/memp.c **** }
 204:./src/lwip/core/memp.c **** 
 205:./src/lwip/core/memp.c **** /**
 206:./src/lwip/core/memp.c ****  * Do an overflow check for all elements in every pool.
 207:./src/lwip/core/memp.c ****  *
 208:./src/lwip/core/memp.c ****  * @see memp_overflow_check_element for a description of the check
 209:./src/lwip/core/memp.c ****  */
 210:./src/lwip/core/memp.c **** static void
 211:./src/lwip/core/memp.c **** memp_overflow_check_all(void)
 212:./src/lwip/core/memp.c **** {
 213:./src/lwip/core/memp.c ****   u16_t i, j;
 214:./src/lwip/core/memp.c ****   struct memp *p;
 215:./src/lwip/core/memp.c **** 
 216:./src/lwip/core/memp.c ****   p = LWIP_MEM_ALIGN(memp_memory);
 217:./src/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
 218:./src/lwip/core/memp.c ****     p = p;
 219:./src/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 220:./src/lwip/core/memp.c ****       memp_overflow_check_element(p, memp_sizes[i]);
 221:./src/lwip/core/memp.c ****       p = (struct memp*)((u8_t*)p + MEMP_SIZE + memp_sizes[i] + MEMP_SANITY_REGION_AFTER_ALIGNED);
 222:./src/lwip/core/memp.c ****     }
 223:./src/lwip/core/memp.c ****   }
 224:./src/lwip/core/memp.c **** }
 225:./src/lwip/core/memp.c **** 
 226:./src/lwip/core/memp.c **** /**
 227:./src/lwip/core/memp.c ****  * Initialize the restricted areas of all memp elements in every pool.
 228:./src/lwip/core/memp.c ****  */
 229:./src/lwip/core/memp.c **** static void
 230:./src/lwip/core/memp.c **** memp_overflow_init(void)
 231:./src/lwip/core/memp.c **** {
 232:./src/lwip/core/memp.c ****   u16_t i, j;
 233:./src/lwip/core/memp.c ****   struct memp *p;
 234:./src/lwip/core/memp.c ****   u8_t *m;
 235:./src/lwip/core/memp.c **** 
 236:./src/lwip/core/memp.c ****   p = LWIP_MEM_ALIGN(memp_memory);
 237:./src/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
 238:./src/lwip/core/memp.c ****     p = p;
 239:./src/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 240:./src/lwip/core/memp.c **** #if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
 241:./src/lwip/core/memp.c ****       m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
 242:./src/lwip/core/memp.c ****       memset(m, 0xcd, MEMP_SANITY_REGION_BEFORE_ALIGNED);
 243:./src/lwip/core/memp.c **** #endif
 244:./src/lwip/core/memp.c **** #if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
 245:./src/lwip/core/memp.c ****       m = (u8_t*)p + MEMP_SIZE + memp_sizes[i];
 246:./src/lwip/core/memp.c ****       memset(m, 0xcd, MEMP_SANITY_REGION_AFTER_ALIGNED);
 247:./src/lwip/core/memp.c **** #endif
 248:./src/lwip/core/memp.c ****       p = (struct memp*)((u8_t*)p + MEMP_SIZE + memp_sizes[i] + MEMP_SANITY_REGION_AFTER_ALIGNED);
 249:./src/lwip/core/memp.c ****     }
 250:./src/lwip/core/memp.c ****   }
 251:./src/lwip/core/memp.c **** }
 252:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 253:./src/lwip/core/memp.c **** 
 254:./src/lwip/core/memp.c **** /**
 255:./src/lwip/core/memp.c ****  * Initialize this module.
 256:./src/lwip/core/memp.c ****  * 
 257:./src/lwip/core/memp.c ****  * Carves out memp_memory into linked lists for each pool-type.
 258:./src/lwip/core/memp.c ****  */
 259:./src/lwip/core/memp.c **** void
 260:./src/lwip/core/memp.c **** memp_init(void)
 261:./src/lwip/core/memp.c **** {
  70              		.loc 1 261 0
  71              		@ Function supports interworking.
  72              		@ args = 0, pretend = 0, frame = 8
  73              		@ frame_needed = 1, uses_anonymous_args = 0
  74              		@ link register save eliminated.
  75 0000 04B02DE5 		str	fp, [sp, #-4]!
  76              	.LCFI0:
  77 0004 00B08DE2 		add	fp, sp, #0
  78              	.LCFI1:
  79 0008 0CD04DE2 		sub	sp, sp, #12
  80              	.LCFI2:
 262:./src/lwip/core/memp.c ****   struct memp *memp;
 263:./src/lwip/core/memp.c ****   u16_t i, j;
 264:./src/lwip/core/memp.c **** 
 265:./src/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
  81              		.loc 1 265 0
  82 000c 0030A0E3 		mov	r3, #0
  83 0010 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
  84 0014 320000EA 		b	.L2
  85              	.L3:
 266:./src/lwip/core/memp.c ****     MEMP_STATS_AVAIL(used, i, 0);
  86              		.loc 1 266 0
  87 0018 B8205BE1 		ldrh	r2, [fp, #-8]
  88 001c 90019FE5 		ldr	r0, .L9
  89 0020 B410A0E3 		mov	r1, #180
  90 0024 0230A0E1 		mov	r3, r2
  91 0028 0331A0E1 		mov	r3, r3, asl #2
  92 002c 023083E0 		add	r3, r3, r2
  93 0030 8330A0E1 		mov	r3, r3, asl #1
  94 0034 003083E0 		add	r3, r3, r0
  95 0038 013083E0 		add	r3, r3, r1
  96 003c 0020A0E3 		mov	r2, #0
  97 0040 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 267:./src/lwip/core/memp.c ****     MEMP_STATS_AVAIL(max, i, 0);
  98              		.loc 1 267 0
  99 0044 B8205BE1 		ldrh	r2, [fp, #-8]
 100 0048 64019FE5 		ldr	r0, .L9
 101 004c B610A0E3 		mov	r1, #182
 102 0050 0230A0E1 		mov	r3, r2
 103 0054 0331A0E1 		mov	r3, r3, asl #2
 104 0058 023083E0 		add	r3, r3, r2
 105 005c 8330A0E1 		mov	r3, r3, asl #1
 106 0060 003083E0 		add	r3, r3, r0
 107 0064 013083E0 		add	r3, r3, r1
 108 0068 0020A0E3 		mov	r2, #0
 109 006c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 268:./src/lwip/core/memp.c ****     MEMP_STATS_AVAIL(err, i, 0);
 110              		.loc 1 268 0
 111 0070 B8205BE1 		ldrh	r2, [fp, #-8]
 112 0074 38019FE5 		ldr	r0, .L9
 113 0078 B810A0E3 		mov	r1, #184
 114 007c 0230A0E1 		mov	r3, r2
 115 0080 0331A0E1 		mov	r3, r3, asl #2
 116 0084 023083E0 		add	r3, r3, r2
 117 0088 8330A0E1 		mov	r3, r3, asl #1
 118 008c 003083E0 		add	r3, r3, r0
 119 0090 013083E0 		add	r3, r3, r1
 120 0094 0020A0E3 		mov	r2, #0
 121 0098 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 269:./src/lwip/core/memp.c ****     MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 122              		.loc 1 269 0
 123 009c B8205BE1 		ldrh	r2, [fp, #-8]
 124 00a0 B8105BE1 		ldrh	r1, [fp, #-8]
 125 00a4 0C319FE5 		ldr	r3, .L9+4
 126 00a8 8110A0E1 		mov	r1, r1, asl #1
 127 00ac 033081E0 		add	r3, r1, r3
 128 00b0 B010D3E1 		ldrh	r1, [r3, #0]
 129 00b4 F8C09FE5 		ldr	ip, .L9
 130 00b8 B200A0E3 		mov	r0, #178
 131 00bc 0230A0E1 		mov	r3, r2
 132 00c0 0331A0E1 		mov	r3, r3, asl #2
 133 00c4 023083E0 		add	r3, r3, r2
 134 00c8 8330A0E1 		mov	r3, r3, asl #1
 135 00cc 0C3083E0 		add	r3, r3, ip
 136 00d0 003083E0 		add	r3, r3, r0
 137 00d4 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 138              		.loc 1 265 0
 139 00d8 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 140 00dc 013083E2 		add	r3, r3, #1
 141 00e0 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 142              	.L2:
 143 00e4 B8305BE1 		ldrh	r3, [fp, #-8]
 144 00e8 0C0053E3 		cmp	r3, #12
 145 00ec C9FFFF9A 		bls	.L3
 270:./src/lwip/core/memp.c ****   }
 271:./src/lwip/core/memp.c **** 
 272:./src/lwip/core/memp.c ****   memp = LWIP_MEM_ALIGN(memp_memory);
 146              		.loc 1 272 0
 147 00f0 C4309FE5 		ldr	r3, .L9+8
 148 00f4 0C300BE5 		str	r3, [fp, #-12]
 273:./src/lwip/core/memp.c ****   /* for every pool: */
 274:./src/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
 149              		.loc 1 274 0
 150 00f8 0030A0E3 		mov	r3, #0
 151 00fc B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 152 0100 250000EA 		b	.L4
 153              	.L7:
 275:./src/lwip/core/memp.c ****     memp_tab[i] = NULL;
 154              		.loc 1 275 0
 155 0104 B8205BE1 		ldrh	r2, [fp, #-8]
 156 0108 B0309FE5 		ldr	r3, .L9+12
 157 010c 0010A0E3 		mov	r1, #0
 158 0110 021183E7 		str	r1, [r3, r2, asl #2]
 276:./src/lwip/core/memp.c ****     /* create a linked list of memp elements */
 277:./src/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 159              		.loc 1 277 0
 160 0114 0030A0E3 		mov	r3, #0
 161 0118 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 162 011c 130000EA 		b	.L5
 163              	.L6:
 278:./src/lwip/core/memp.c ****       memp->next = memp_tab[i];
 164              		.loc 1 278 0
 165 0120 B8205BE1 		ldrh	r2, [fp, #-8]
 166 0124 94309FE5 		ldr	r3, .L9+12
 167 0128 022193E7 		ldr	r2, [r3, r2, asl #2]
 168 012c 0C301BE5 		ldr	r3, [fp, #-12]
 169 0130 002083E5 		str	r2, [r3, #0]
 279:./src/lwip/core/memp.c ****       memp_tab[i] = memp;
 170              		.loc 1 279 0
 171 0134 B8205BE1 		ldrh	r2, [fp, #-8]
 172 0138 80309FE5 		ldr	r3, .L9+12
 173 013c 0C101BE5 		ldr	r1, [fp, #-12]
 174 0140 021183E7 		str	r1, [r3, r2, asl #2]
 280:./src/lwip/core/memp.c ****       memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 175              		.loc 1 280 0
 176 0144 B8205BE1 		ldrh	r2, [fp, #-8]
 177 0148 74309FE5 		ldr	r3, .L9+16
 178 014c 8220A0E1 		mov	r2, r2, asl #1
 179 0150 033082E0 		add	r3, r2, r3
 180 0154 B030D3E1 		ldrh	r3, [r3, #0]
 181 0158 0C201BE5 		ldr	r2, [fp, #-12]
 182 015c 033082E0 		add	r3, r2, r3
 183 0160 0C300BE5 		str	r3, [fp, #-12]
 184              		.loc 1 277 0
 185 0164 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 186 0168 013083E2 		add	r3, r3, #1
 187 016c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 188              	.L5:
 189 0170 B8205BE1 		ldrh	r2, [fp, #-8]
 190 0174 3C309FE5 		ldr	r3, .L9+4
 191 0178 8220A0E1 		mov	r2, r2, asl #1
 192 017c 033082E0 		add	r3, r2, r3
 193 0180 B030D3E1 		ldrh	r3, [r3, #0]
 194 0184 B6205BE1 		ldrh	r2, [fp, #-6]
 195 0188 030052E1 		cmp	r2, r3
 196 018c E3FFFF3A 		bcc	.L6
 197              		.loc 1 274 0
 198 0190 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 199 0194 013083E2 		add	r3, r3, #1
 200 0198 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 201              	.L4:
 202 019c B8305BE1 		ldrh	r3, [fp, #-8]
 203 01a0 0C0053E3 		cmp	r3, #12
 204 01a4 D6FFFF9A 		bls	.L7
 281:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 282:./src/lwip/core/memp.c ****         + MEMP_SANITY_REGION_AFTER_ALIGNED
 283:./src/lwip/core/memp.c **** #endif
 284:./src/lwip/core/memp.c ****       );
 285:./src/lwip/core/memp.c ****     }
 286:./src/lwip/core/memp.c ****   }
 287:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 288:./src/lwip/core/memp.c ****   memp_overflow_init();
 289:./src/lwip/core/memp.c ****   /* check everything a first time to see if it worked */
 290:./src/lwip/core/memp.c ****   memp_overflow_check_all();
 291:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 292:./src/lwip/core/memp.c **** }
 205              		.loc 1 292 0
 206 01a8 00D08BE2 		add	sp, fp, #0
 207 01ac 0008BDE8 		ldmfd	sp!, {fp}
 208 01b0 1EFF2FE1 		bx	lr
 209              	.L10:
 210              		.align	2
 211              	.L9:
 212 01b4 00000000 		.word	lwip_stats
 213 01b8 1C000000 		.word	memp_num
 214 01bc 34000000 		.word	memp_memory
 215 01c0 00000000 		.word	memp_tab
 216 01c4 00000000 		.word	memp_sizes
 217              	.LFE0:
 219              		.align	2
 220              		.global	memp_malloc
 222              	memp_malloc:
 223              	.LFB1:
 293:./src/lwip/core/memp.c **** 
 294:./src/lwip/core/memp.c **** /**
 295:./src/lwip/core/memp.c ****  * Get an element from a specific pool.
 296:./src/lwip/core/memp.c ****  *
 297:./src/lwip/core/memp.c ****  * @param type the pool to get an element from
 298:./src/lwip/core/memp.c ****  *
 299:./src/lwip/core/memp.c ****  * the debug version has two more parameters:
 300:./src/lwip/core/memp.c ****  * @param file file name calling this function
 301:./src/lwip/core/memp.c ****  * @param line number of line where this function is called
 302:./src/lwip/core/memp.c ****  *
 303:./src/lwip/core/memp.c ****  * @return a pointer to the allocated memory or a NULL pointer on error
 304:./src/lwip/core/memp.c ****  */
 305:./src/lwip/core/memp.c **** void *
 306:./src/lwip/core/memp.c **** #if !MEMP_OVERFLOW_CHECK
 307:./src/lwip/core/memp.c **** memp_malloc(memp_t type)
 308:./src/lwip/core/memp.c **** #else
 309:./src/lwip/core/memp.c **** memp_malloc_fn(memp_t type, const char* file, const int line)
 310:./src/lwip/core/memp.c **** #endif
 311:./src/lwip/core/memp.c **** {
 224              		.loc 1 311 0
 225              		@ Function supports interworking.
 226              		@ args = 0, pretend = 0, frame = 16
 227              		@ frame_needed = 1, uses_anonymous_args = 0
 228              		@ link register save eliminated.
 229 01c8 04B02DE5 		str	fp, [sp, #-4]!
 230              	.LCFI3:
 231 01cc 00B08DE2 		add	fp, sp, #0
 232              	.LCFI4:
 233 01d0 14D04DE2 		sub	sp, sp, #20
 234              	.LCFI5:
 235 01d4 0030A0E1 		mov	r3, r0
 236 01d8 0D304BE5 		strb	r3, [fp, #-13]
 312:./src/lwip/core/memp.c ****   struct memp *memp;
 313:./src/lwip/core/memp.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 314:./src/lwip/core/memp.c ****  
 315:./src/lwip/core/memp.c ****   LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 237              		.loc 1 315 0
 238 01dc 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 239 01e0 0C0053E3 		cmp	r3, #12
 240 01e4 0100009A 		bls	.L12
 241 01e8 0030A0E3 		mov	r3, #0
 242 01ec 630000EA 		b	.L13
 243              	.L12:
 316:./src/lwip/core/memp.c **** 
 317:./src/lwip/core/memp.c ****   SYS_ARCH_PROTECT(old_level);
 318:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK >= 2
 319:./src/lwip/core/memp.c ****   memp_overflow_check_all();
 320:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK >= 2 */
 321:./src/lwip/core/memp.c **** 
 322:./src/lwip/core/memp.c ****   memp = memp_tab[type];
 244              		.loc 1 322 0
 245 01f0 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 246 01f4 94319FE5 		ldr	r3, .L18
 247 01f8 023193E7 		ldr	r3, [r3, r2, asl #2]
 248 01fc 08300BE5 		str	r3, [fp, #-8]
 323:./src/lwip/core/memp.c ****   
 324:./src/lwip/core/memp.c ****   if (memp != NULL) {
 249              		.loc 1 324 0
 250 0200 08301BE5 		ldr	r3, [fp, #-8]
 251 0204 000053E3 		cmp	r3, #0
 252 0208 4500000A 		beq	.L14
 325:./src/lwip/core/memp.c ****     memp_tab[type] = memp->next;
 253              		.loc 1 325 0
 254 020c 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 255 0210 08301BE5 		ldr	r3, [fp, #-8]
 256 0214 001093E5 		ldr	r1, [r3, #0]
 257 0218 70319FE5 		ldr	r3, .L18
 258 021c 021183E7 		str	r1, [r3, r2, asl #2]
 326:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 327:./src/lwip/core/memp.c ****     memp->next = NULL;
 328:./src/lwip/core/memp.c ****     memp->file = file;
 329:./src/lwip/core/memp.c ****     memp->line = line;
 330:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 331:./src/lwip/core/memp.c ****     MEMP_STATS_INC_USED(used, type);
 259              		.loc 1 331 0
 260 0220 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 261 0224 68019FE5 		ldr	r0, .L18+4
 262 0228 B410A0E3 		mov	r1, #180
 263 022c 0230A0E1 		mov	r3, r2
 264 0230 0331A0E1 		mov	r3, r3, asl #2
 265 0234 023083E0 		add	r3, r3, r2
 266 0238 8330A0E1 		mov	r3, r3, asl #1
 267 023c 003083E0 		add	r3, r3, r0
 268 0240 013083E0 		add	r3, r3, r1
 269 0244 B030D3E1 		ldrh	r3, [r3, #0]
 270 0248 013083E2 		add	r3, r3, #1
 271 024c 0338A0E1 		mov	r3, r3, asl #16
 272 0250 2318A0E1 		mov	r1, r3, lsr #16
 273 0254 38C19FE5 		ldr	ip, .L18+4
 274 0258 B400A0E3 		mov	r0, #180
 275 025c 0230A0E1 		mov	r3, r2
 276 0260 0331A0E1 		mov	r3, r3, asl #2
 277 0264 023083E0 		add	r3, r3, r2
 278 0268 8330A0E1 		mov	r3, r3, asl #1
 279 026c 0C3083E0 		add	r3, r3, ip
 280 0270 003083E0 		add	r3, r3, r0
 281 0274 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 282 0278 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 283 027c 10019FE5 		ldr	r0, .L18+4
 284 0280 B610A0E3 		mov	r1, #182
 285 0284 0230A0E1 		mov	r3, r2
 286 0288 0331A0E1 		mov	r3, r3, asl #2
 287 028c 023083E0 		add	r3, r3, r2
 288 0290 8330A0E1 		mov	r3, r3, asl #1
 289 0294 003083E0 		add	r3, r3, r0
 290 0298 013083E0 		add	r3, r3, r1
 291 029c B010D3E1 		ldrh	r1, [r3, #0]
 292 02a0 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 293 02a4 E8C09FE5 		ldr	ip, .L18+4
 294 02a8 B400A0E3 		mov	r0, #180
 295 02ac 0230A0E1 		mov	r3, r2
 296 02b0 0331A0E1 		mov	r3, r3, asl #2
 297 02b4 023083E0 		add	r3, r3, r2
 298 02b8 8330A0E1 		mov	r3, r3, asl #1
 299 02bc 0C3083E0 		add	r3, r3, ip
 300 02c0 003083E0 		add	r3, r3, r0
 301 02c4 B030D3E1 		ldrh	r3, [r3, #0]
 302 02c8 030051E1 		cmp	r1, r3
 303 02cc 2A00002A 		bcs	.L16
 304 02d0 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 305 02d4 0D105BE5 		ldrb	r1, [fp, #-13]	@ zero_extendqisi2
 306 02d8 B4C09FE5 		ldr	ip, .L18+4
 307 02dc B400A0E3 		mov	r0, #180
 308 02e0 0130A0E1 		mov	r3, r1
 309 02e4 0331A0E1 		mov	r3, r3, asl #2
 310 02e8 013083E0 		add	r3, r3, r1
 311 02ec 8330A0E1 		mov	r3, r3, asl #1
 312 02f0 0C3083E0 		add	r3, r3, ip
 313 02f4 003083E0 		add	r3, r3, r0
 314 02f8 B010D3E1 		ldrh	r1, [r3, #0]
 315 02fc 90C09FE5 		ldr	ip, .L18+4
 316 0300 B600A0E3 		mov	r0, #182
 317 0304 0230A0E1 		mov	r3, r2
 318 0308 0331A0E1 		mov	r3, r3, asl #2
 319 030c 023083E0 		add	r3, r3, r2
 320 0310 8330A0E1 		mov	r3, r3, asl #1
 321 0314 0C3083E0 		add	r3, r3, ip
 322 0318 003083E0 		add	r3, r3, r0
 323 031c B010C3E1 		strh	r1, [r3, #0]	@ movhi
 324 0320 150000EA 		b	.L16
 325              	.L14:
 332:./src/lwip/core/memp.c ****     LWIP_ASSERT("memp_malloc: memp properly aligned",
 333:./src/lwip/core/memp.c ****                 ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
 334:./src/lwip/core/memp.c ****     memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
 335:./src/lwip/core/memp.c ****   } else {
 336:./src/lwip/core/memp.c ****     LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", me
 337:./src/lwip/core/memp.c ****     MEMP_STATS_INC(err, type);
 326              		.loc 1 337 0
 327 0324 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 328 0328 64009FE5 		ldr	r0, .L18+4
 329 032c B810A0E3 		mov	r1, #184
 330 0330 0230A0E1 		mov	r3, r2
 331 0334 0331A0E1 		mov	r3, r3, asl #2
 332 0338 023083E0 		add	r3, r3, r2
 333 033c 8330A0E1 		mov	r3, r3, asl #1
 334 0340 003083E0 		add	r3, r3, r0
 335 0344 013083E0 		add	r3, r3, r1
 336 0348 B030D3E1 		ldrh	r3, [r3, #0]
 337 034c 013083E2 		add	r3, r3, #1
 338 0350 0338A0E1 		mov	r3, r3, asl #16
 339 0354 2318A0E1 		mov	r1, r3, lsr #16
 340 0358 34C09FE5 		ldr	ip, .L18+4
 341 035c B800A0E3 		mov	r0, #184
 342 0360 0230A0E1 		mov	r3, r2
 343 0364 0331A0E1 		mov	r3, r3, asl #2
 344 0368 023083E0 		add	r3, r3, r2
 345 036c 8330A0E1 		mov	r3, r3, asl #1
 346 0370 0C3083E0 		add	r3, r3, ip
 347 0374 003083E0 		add	r3, r3, r0
 348 0378 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 349              	.L16:
 338:./src/lwip/core/memp.c ****   }
 339:./src/lwip/core/memp.c **** 
 340:./src/lwip/core/memp.c ****   SYS_ARCH_UNPROTECT(old_level);
 341:./src/lwip/core/memp.c **** 
 342:./src/lwip/core/memp.c ****   return memp;
 350              		.loc 1 342 0
 351 037c 08301BE5 		ldr	r3, [fp, #-8]
 352              	.L13:
 343:./src/lwip/core/memp.c **** }
 353              		.loc 1 343 0
 354 0380 0300A0E1 		mov	r0, r3
 355 0384 00D08BE2 		add	sp, fp, #0
 356 0388 0008BDE8 		ldmfd	sp!, {fp}
 357 038c 1EFF2FE1 		bx	lr
 358              	.L19:
 359              		.align	2
 360              	.L18:
 361 0390 00000000 		.word	memp_tab
 362 0394 00000000 		.word	lwip_stats
 363              	.LFE1:
 365              		.align	2
 366              		.global	memp_free
 368              	memp_free:
 369              	.LFB2:
 344:./src/lwip/core/memp.c **** 
 345:./src/lwip/core/memp.c **** /**
 346:./src/lwip/core/memp.c ****  * Put an element back into its pool.
 347:./src/lwip/core/memp.c ****  *
 348:./src/lwip/core/memp.c ****  * @param type the pool where to put mem
 349:./src/lwip/core/memp.c ****  * @param mem the memp element to free
 350:./src/lwip/core/memp.c ****  */
 351:./src/lwip/core/memp.c **** void
 352:./src/lwip/core/memp.c **** memp_free(memp_t type, void *mem)
 353:./src/lwip/core/memp.c **** {
 370              		.loc 1 353 0
 371              		@ Function supports interworking.
 372              		@ args = 0, pretend = 0, frame = 16
 373              		@ frame_needed = 1, uses_anonymous_args = 0
 374              		@ link register save eliminated.
 375 0398 04B02DE5 		str	fp, [sp, #-4]!
 376              	.LCFI6:
 377 039c 00B08DE2 		add	fp, sp, #0
 378              	.LCFI7:
 379 03a0 14D04DE2 		sub	sp, sp, #20
 380              	.LCFI8:
 381 03a4 0030A0E1 		mov	r3, r0
 382 03a8 14100BE5 		str	r1, [fp, #-20]
 383 03ac 0D304BE5 		strb	r3, [fp, #-13]
 354:./src/lwip/core/memp.c ****   struct memp *memp;
 355:./src/lwip/core/memp.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 356:./src/lwip/core/memp.c **** 
 357:./src/lwip/core/memp.c ****   if (mem == NULL) {
 384              		.loc 1 357 0
 385 03b0 14301BE5 		ldr	r3, [fp, #-20]
 386 03b4 000053E3 		cmp	r3, #0
 387 03b8 2100000A 		beq	.L24
 388              	.L21:
 358:./src/lwip/core/memp.c ****     return;
 359:./src/lwip/core/memp.c ****   }
 360:./src/lwip/core/memp.c ****   LWIP_ASSERT("memp_free: mem properly aligned",
 361:./src/lwip/core/memp.c ****                 ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);
 362:./src/lwip/core/memp.c **** 
 363:./src/lwip/core/memp.c ****   memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
 389              		.loc 1 363 0
 390 03bc 14301BE5 		ldr	r3, [fp, #-20]
 391 03c0 08300BE5 		str	r3, [fp, #-8]
 364:./src/lwip/core/memp.c **** 
 365:./src/lwip/core/memp.c ****   SYS_ARCH_PROTECT(old_level);
 366:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 367:./src/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK >= 2
 368:./src/lwip/core/memp.c ****   memp_overflow_check_all();
 369:./src/lwip/core/memp.c **** #else
 370:./src/lwip/core/memp.c ****   memp_overflow_check_element(memp, memp_sizes[type]);
 371:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK >= 2 */
 372:./src/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 373:./src/lwip/core/memp.c **** 
 374:./src/lwip/core/memp.c ****   MEMP_STATS_DEC(used, type); 
 392              		.loc 1 374 0
 393 03c4 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 394 03c8 84009FE5 		ldr	r0, .L25
 395 03cc B410A0E3 		mov	r1, #180
 396 03d0 0230A0E1 		mov	r3, r2
 397 03d4 0331A0E1 		mov	r3, r3, asl #2
 398 03d8 023083E0 		add	r3, r3, r2
 399 03dc 8330A0E1 		mov	r3, r3, asl #1
 400 03e0 003083E0 		add	r3, r3, r0
 401 03e4 013083E0 		add	r3, r3, r1
 402 03e8 B030D3E1 		ldrh	r3, [r3, #0]
 403 03ec 013043E2 		sub	r3, r3, #1
 404 03f0 0338A0E1 		mov	r3, r3, asl #16
 405 03f4 2318A0E1 		mov	r1, r3, lsr #16
 406 03f8 54C09FE5 		ldr	ip, .L25
 407 03fc B400A0E3 		mov	r0, #180
 408 0400 0230A0E1 		mov	r3, r2
 409 0404 0331A0E1 		mov	r3, r3, asl #2
 410 0408 023083E0 		add	r3, r3, r2
 411 040c 8330A0E1 		mov	r3, r3, asl #1
 412 0410 0C3083E0 		add	r3, r3, ip
 413 0414 003083E0 		add	r3, r3, r0
 414 0418 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 375:./src/lwip/core/memp.c ****   
 376:./src/lwip/core/memp.c ****   memp->next = memp_tab[type]; 
 415              		.loc 1 376 0
 416 041c 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 417 0420 30309FE5 		ldr	r3, .L25+4
 418 0424 022193E7 		ldr	r2, [r3, r2, asl #2]
 419 0428 08301BE5 		ldr	r3, [fp, #-8]
 420 042c 002083E5 		str	r2, [r3, #0]
 377:./src/lwip/core/memp.c ****   memp_tab[type] = memp;
 421              		.loc 1 377 0
 422 0430 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 423 0434 1C309FE5 		ldr	r3, .L25+4
 424 0438 08101BE5 		ldr	r1, [fp, #-8]
 425 043c 021183E7 		str	r1, [r3, r2, asl #2]
 426 0440 000000EA 		b	.L23
 427              	.L24:
 428              		.loc 1 358 0
 429 0444 0000A0E1 		mov	r0, r0	@ nop
 430              	.L23:
 378:./src/lwip/core/memp.c **** 
 379:./src/lwip/core/memp.c **** #if MEMP_SANITY_CHECK
 380:./src/lwip/core/memp.c ****   LWIP_ASSERT("memp sanity", memp_sanity());
 381:./src/lwip/core/memp.c **** #endif /* MEMP_SANITY_CHECK */
 382:./src/lwip/core/memp.c **** 
 383:./src/lwip/core/memp.c ****   SYS_ARCH_UNPROTECT(old_level);
 384:./src/lwip/core/memp.c **** }
 431              		.loc 1 384 0
 432 0448 00D08BE2 		add	sp, fp, #0
 433 044c 0008BDE8 		ldmfd	sp!, {fp}
 434 0450 1EFF2FE1 		bx	lr
 435              	.L26:
 436              		.align	2
 437              	.L25:
 438 0454 00000000 		.word	lwip_stats
 439 0458 00000000 		.word	memp_tab
 440              	.LFE2:
 515              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 memp.c
     /tmp/ccXELWnn.s:21     .bss:00000000 $d
     /tmp/ccXELWnn.s:22     .bss:00000000 memp_tab
     /tmp/ccXELWnn.s:25     .rodata:00000000 $d
     /tmp/ccXELWnn.s:28     .rodata:00000000 memp_sizes
     /tmp/ccXELWnn.s:45     .rodata:0000001c memp_num
     /tmp/ccXELWnn.s:61     .bss:00000034 memp_memory
     /tmp/ccXELWnn.s:64     .text:00000000 $a
     /tmp/ccXELWnn.s:67     .text:00000000 memp_init
     /tmp/ccXELWnn.s:212    .text:000001b4 $d
     /tmp/ccXELWnn.s:219    .text:000001c8 $a
     /tmp/ccXELWnn.s:222    .text:000001c8 memp_malloc
     /tmp/ccXELWnn.s:361    .text:00000390 $d
     /tmp/ccXELWnn.s:365    .text:00000398 $a
     /tmp/ccXELWnn.s:368    .text:00000398 memp_free
     /tmp/ccXELWnn.s:438    .text:00000454 $d
     /tmp/ccXELWnn.s:455    .debug_frame:00000010 $d

UNDEFINED SYMBOLS
lwip_stats
