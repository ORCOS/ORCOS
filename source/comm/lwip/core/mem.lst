   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"mem.c"
  19              	.Ltext0:
  20              		.bss
  21              		.align	2
  22              	ram_heap:
  23 0000 00000000 		.space	1613
  23      00000000 
  23      00000000 
  23      00000000 
  23      00000000 
  24 064d 000000   		.align	2
  25              	ram:
  26 0650 00000000 		.space	4
  27              		.align	2
  28              	ram_end:
  29 0654 00000000 		.space	4
  30              		.align	2
  31              	lfree:
  32 0658 00000000 		.space	4
  33              		.align	2
  34              	mem_sem:
  35 065c 00000000 		.space	4
  36              		.text
  37              		.align	2
  39              	plug_holes:
  40              	.LFB0:
  41              		.file 1 "./src/lwip/core/mem.c"
   1:./src/lwip/core/mem.c **** /**
   2:./src/lwip/core/mem.c ****  * @file
   3:./src/lwip/core/mem.c ****  * Dynamic memory manager
   4:./src/lwip/core/mem.c ****  *
   5:./src/lwip/core/mem.c ****  * This is a lightweight replacement for the standard C library malloc().
   6:./src/lwip/core/mem.c ****  *
   7:./src/lwip/core/mem.c ****  * If you want to use the standard C library malloc() instead, define
   8:./src/lwip/core/mem.c ****  * MEM_LIBC_MALLOC to 1 in your lwipopts.h
   9:./src/lwip/core/mem.c ****  *
  10:./src/lwip/core/mem.c ****  * To let mem_malloc() use pools (prevents fragmentation and is much faster than
  11:./src/lwip/core/mem.c ****  * a heap but might waste some memory), define MEM_USE_POOLS to 1, define
  12:./src/lwip/core/mem.c ****  * MEM_USE_CUSTOM_POOLS to 1 and create a file "lwippools.h" that includes a list
  13:./src/lwip/core/mem.c ****  * of pools like this (more pools can be added between _START and _END):
  14:./src/lwip/core/mem.c ****  *
  15:./src/lwip/core/mem.c ****  * Define three pools with sizes 256, 512, and 1512 bytes
  16:./src/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL_START
  17:./src/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL(20, 256)
  18:./src/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL(10, 512)
  19:./src/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL(5, 1512)
  20:./src/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL_END
  21:./src/lwip/core/mem.c ****  */
  22:./src/lwip/core/mem.c **** 
  23:./src/lwip/core/mem.c **** /*
  24:./src/lwip/core/mem.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  25:./src/lwip/core/mem.c ****  * All rights reserved.
  26:./src/lwip/core/mem.c ****  *
  27:./src/lwip/core/mem.c ****  * Redistribution and use in source and binary forms, with or without modification,
  28:./src/lwip/core/mem.c ****  * are permitted provided that the following conditions are met:
  29:./src/lwip/core/mem.c ****  *
  30:./src/lwip/core/mem.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  31:./src/lwip/core/mem.c ****  *    this list of conditions and the following disclaimer.
  32:./src/lwip/core/mem.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  33:./src/lwip/core/mem.c ****  *    this list of conditions and the following disclaimer in the documentation
  34:./src/lwip/core/mem.c ****  *    and/or other materials provided with the distribution.
  35:./src/lwip/core/mem.c ****  * 3. The name of the author may not be used to endorse or promote products
  36:./src/lwip/core/mem.c ****  *    derived from this software without specific prior written permission.
  37:./src/lwip/core/mem.c ****  *
  38:./src/lwip/core/mem.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  39:./src/lwip/core/mem.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  40:./src/lwip/core/mem.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  41:./src/lwip/core/mem.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  42:./src/lwip/core/mem.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  43:./src/lwip/core/mem.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  44:./src/lwip/core/mem.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  45:./src/lwip/core/mem.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  46:./src/lwip/core/mem.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  47:./src/lwip/core/mem.c ****  * OF SUCH DAMAGE.
  48:./src/lwip/core/mem.c ****  *
  49:./src/lwip/core/mem.c ****  * This file is part of the lwIP TCP/IP stack.
  50:./src/lwip/core/mem.c ****  *
  51:./src/lwip/core/mem.c ****  * Author: Adam Dunkels <adam@sics.se>
  52:./src/lwip/core/mem.c ****  *         Simon Goldschmidt
  53:./src/lwip/core/mem.c ****  *
  54:./src/lwip/core/mem.c ****  */
  55:./src/lwip/core/mem.c **** 
  56:./src/lwip/core/mem.c **** #include "lwip/opt.h"
  57:./src/lwip/core/mem.c **** 
  58:./src/lwip/core/mem.c **** #if !MEM_LIBC_MALLOC /* don't build if not configured for use in lwipopts.h */
  59:./src/lwip/core/mem.c **** 
  60:./src/lwip/core/mem.c **** #include "lwip/def.h"
  61:./src/lwip/core/mem.c **** #include "lwip/mem.h"
  62:./src/lwip/core/mem.c **** #include "lwip/sys.h"
  63:./src/lwip/core/mem.c **** #include "lwip/stats.h"
  64:./src/lwip/core/mem.c **** 
  65:./src/lwip/core/mem.c **** #include <string.h>
  66:./src/lwip/core/mem.c **** 
  67:./src/lwip/core/mem.c **** #if MEM_USE_POOLS
  68:./src/lwip/core/mem.c **** /* lwIP head implemented with different sized pools */
  69:./src/lwip/core/mem.c **** 
  70:./src/lwip/core/mem.c **** /**
  71:./src/lwip/core/mem.c ****  * Allocate memory: determine the smallest pool that is big enough
  72:./src/lwip/core/mem.c ****  * to contain an element of 'size' and get an element from that pool.
  73:./src/lwip/core/mem.c ****  *
  74:./src/lwip/core/mem.c ****  * @param size the size in bytes of the memory needed
  75:./src/lwip/core/mem.c ****  * @return a pointer to the allocated memory or NULL if the pool is empty
  76:./src/lwip/core/mem.c ****  */
  77:./src/lwip/core/mem.c **** void *
  78:./src/lwip/core/mem.c **** mem_malloc(mem_size_t size)
  79:./src/lwip/core/mem.c **** {
  80:./src/lwip/core/mem.c ****   struct memp_malloc_helper *element;
  81:./src/lwip/core/mem.c ****   memp_t poolnr;
  82:./src/lwip/core/mem.c ****   mem_size_t required_size = size + sizeof(struct memp_malloc_helper);
  83:./src/lwip/core/mem.c **** 
  84:./src/lwip/core/mem.c ****   for (poolnr = MEMP_POOL_FIRST; poolnr <= MEMP_POOL_LAST; poolnr++) {
  85:./src/lwip/core/mem.c **** #if MEM_USE_POOLS_TRY_BIGGER_POOL
  86:./src/lwip/core/mem.c **** again:
  87:./src/lwip/core/mem.c **** #endif /* MEM_USE_POOLS_TRY_BIGGER_POOL */
  88:./src/lwip/core/mem.c ****     /* is this pool big enough to hold an element of the required size
  89:./src/lwip/core/mem.c ****        plus a struct memp_malloc_helper that saves the pool this element came from? */
  90:./src/lwip/core/mem.c ****     if (required_size <= memp_sizes[poolnr]) {
  91:./src/lwip/core/mem.c ****       break;
  92:./src/lwip/core/mem.c ****     }
  93:./src/lwip/core/mem.c ****   }
  94:./src/lwip/core/mem.c ****   if (poolnr > MEMP_POOL_LAST) {
  95:./src/lwip/core/mem.c ****     LWIP_ASSERT("mem_malloc(): no pool is that big!", 0);
  96:./src/lwip/core/mem.c ****     return NULL;
  97:./src/lwip/core/mem.c ****   }
  98:./src/lwip/core/mem.c ****   element = (struct memp_malloc_helper*)memp_malloc(poolnr);
  99:./src/lwip/core/mem.c ****   if (element == NULL) {
 100:./src/lwip/core/mem.c ****     /* No need to DEBUGF or ASSERT: This error is already
 101:./src/lwip/core/mem.c ****        taken care of in memp.c */
 102:./src/lwip/core/mem.c **** #if MEM_USE_POOLS_TRY_BIGGER_POOL
 103:./src/lwip/core/mem.c ****     /** Try a bigger pool if this one is empty! */
 104:./src/lwip/core/mem.c ****     if (poolnr < MEMP_POOL_LAST) {
 105:./src/lwip/core/mem.c ****       poolnr++;
 106:./src/lwip/core/mem.c ****       goto again;
 107:./src/lwip/core/mem.c ****     }
 108:./src/lwip/core/mem.c **** #endif /* MEM_USE_POOLS_TRY_BIGGER_POOL */
 109:./src/lwip/core/mem.c ****     return NULL;
 110:./src/lwip/core/mem.c ****   }
 111:./src/lwip/core/mem.c **** 
 112:./src/lwip/core/mem.c ****   /* save the pool number this element came from */
 113:./src/lwip/core/mem.c ****   element->poolnr = poolnr;
 114:./src/lwip/core/mem.c ****   /* and return a pointer to the memory directly after the struct memp_malloc_helper */
 115:./src/lwip/core/mem.c ****   element++;
 116:./src/lwip/core/mem.c **** 
 117:./src/lwip/core/mem.c ****   return element;
 118:./src/lwip/core/mem.c **** }
 119:./src/lwip/core/mem.c **** 
 120:./src/lwip/core/mem.c **** /**
 121:./src/lwip/core/mem.c ****  * Free memory previously allocated by mem_malloc. Loads the pool number
 122:./src/lwip/core/mem.c ****  * and calls memp_free with that pool number to put the element back into
 123:./src/lwip/core/mem.c ****  * its pool
 124:./src/lwip/core/mem.c ****  *
 125:./src/lwip/core/mem.c ****  * @param rmem the memory element to free
 126:./src/lwip/core/mem.c ****  */
 127:./src/lwip/core/mem.c **** void
 128:./src/lwip/core/mem.c **** mem_free(void *rmem)
 129:./src/lwip/core/mem.c **** {
 130:./src/lwip/core/mem.c ****   struct memp_malloc_helper *hmem = (struct memp_malloc_helper*)rmem;
 131:./src/lwip/core/mem.c **** 
 132:./src/lwip/core/mem.c ****   LWIP_ASSERT("rmem != NULL", (rmem != NULL));
 133:./src/lwip/core/mem.c ****   LWIP_ASSERT("rmem == MEM_ALIGN(rmem)", (rmem == LWIP_MEM_ALIGN(rmem)));
 134:./src/lwip/core/mem.c **** 
 135:./src/lwip/core/mem.c ****   /* get the original struct memp_malloc_helper */
 136:./src/lwip/core/mem.c ****   hmem--;
 137:./src/lwip/core/mem.c **** 
 138:./src/lwip/core/mem.c ****   LWIP_ASSERT("hmem != NULL", (hmem != NULL));
 139:./src/lwip/core/mem.c ****   LWIP_ASSERT("hmem == MEM_ALIGN(hmem)", (hmem == LWIP_MEM_ALIGN(hmem)));
 140:./src/lwip/core/mem.c ****   LWIP_ASSERT("hmem->poolnr < MEMP_MAX", (hmem->poolnr < MEMP_MAX));
 141:./src/lwip/core/mem.c **** 
 142:./src/lwip/core/mem.c ****   /* and put it in the pool we saved earlier */
 143:./src/lwip/core/mem.c ****   memp_free(hmem->poolnr, hmem);
 144:./src/lwip/core/mem.c **** }
 145:./src/lwip/core/mem.c **** 
 146:./src/lwip/core/mem.c **** #else /* MEM_USE_POOLS */
 147:./src/lwip/core/mem.c **** /* lwIP replacement for your libc malloc() */
 148:./src/lwip/core/mem.c **** 
 149:./src/lwip/core/mem.c **** /**
 150:./src/lwip/core/mem.c ****  * The heap is made up as a list of structs of this type.
 151:./src/lwip/core/mem.c ****  * This does not have to be aligned since for getting its size,
 152:./src/lwip/core/mem.c ****  * we only use the macro SIZEOF_STRUCT_MEM, which automatically alignes.
 153:./src/lwip/core/mem.c ****  */
 154:./src/lwip/core/mem.c **** struct mem {
 155:./src/lwip/core/mem.c ****   /** index (-> ram[next]) of the next struct */
 156:./src/lwip/core/mem.c ****   mem_size_t next;
 157:./src/lwip/core/mem.c ****   /** index (-> ram[next]) of the next struct */
 158:./src/lwip/core/mem.c ****   mem_size_t prev;
 159:./src/lwip/core/mem.c ****   /** 1: this area is used; 0: this area is unused */
 160:./src/lwip/core/mem.c ****   u8_t used;
 161:./src/lwip/core/mem.c **** };
 162:./src/lwip/core/mem.c **** 
 163:./src/lwip/core/mem.c **** /** All allocated blocks will be MIN_SIZE bytes big, at least!
 164:./src/lwip/core/mem.c ****  * MIN_SIZE can be overridden to suit your needs. Smaller values save space,
 165:./src/lwip/core/mem.c ****  * larger values could prevent too small blocks to fragment the RAM too much. */
 166:./src/lwip/core/mem.c **** #ifndef MIN_SIZE
 167:./src/lwip/core/mem.c **** #define MIN_SIZE             12
 168:./src/lwip/core/mem.c **** #endif /* MIN_SIZE */
 169:./src/lwip/core/mem.c **** /* some alignment macros: we define them here for better source code layout */
 170:./src/lwip/core/mem.c **** #define MIN_SIZE_ALIGNED     LWIP_MEM_ALIGN_SIZE(MIN_SIZE)
 171:./src/lwip/core/mem.c **** #define SIZEOF_STRUCT_MEM    LWIP_MEM_ALIGN_SIZE(sizeof(struct mem))
 172:./src/lwip/core/mem.c **** #define MEM_SIZE_ALIGNED     LWIP_MEM_ALIGN_SIZE(MEM_SIZE)
 173:./src/lwip/core/mem.c **** 
 174:./src/lwip/core/mem.c **** /** the heap. we need one struct mem at the end and some room for alignment */
 175:./src/lwip/core/mem.c **** static u8_t ram_heap[MEM_SIZE_ALIGNED + (2*SIZEOF_STRUCT_MEM) + MEM_ALIGNMENT];
 176:./src/lwip/core/mem.c **** /** pointer to the heap (ram_heap): for alignment, ram is now a pointer instead of an array */
 177:./src/lwip/core/mem.c **** static u8_t *ram;
 178:./src/lwip/core/mem.c **** /** the last entry, always unused! */
 179:./src/lwip/core/mem.c **** static struct mem *ram_end;
 180:./src/lwip/core/mem.c **** /** pointer to the lowest free block, this is used for faster search */
 181:./src/lwip/core/mem.c **** static struct mem *lfree;
 182:./src/lwip/core/mem.c **** 
 183:./src/lwip/core/mem.c **** /** concurrent access protection */
 184:./src/lwip/core/mem.c **** static sys_sem_t mem_sem;
 185:./src/lwip/core/mem.c **** 
 186:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 187:./src/lwip/core/mem.c **** 
 188:./src/lwip/core/mem.c **** static volatile u8_t mem_free_count;
 189:./src/lwip/core/mem.c **** 
 190:./src/lwip/core/mem.c **** /* Allow mem_free from other (e.g. interrupt) context */
 191:./src/lwip/core/mem.c **** #define LWIP_MEM_FREE_DECL_PROTECT()  SYS_ARCH_DECL_PROTECT(lev_free)
 192:./src/lwip/core/mem.c **** #define LWIP_MEM_FREE_PROTECT()       SYS_ARCH_PROTECT(lev_free)
 193:./src/lwip/core/mem.c **** #define LWIP_MEM_FREE_UNPROTECT()     SYS_ARCH_UNPROTECT(lev_free)
 194:./src/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_DECL_PROTECT() SYS_ARCH_DECL_PROTECT(lev_alloc)
 195:./src/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_PROTECT()      SYS_ARCH_PROTECT(lev_alloc)
 196:./src/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_UNPROTECT()    SYS_ARCH_UNPROTECT(lev_alloc)
 197:./src/lwip/core/mem.c **** 
 198:./src/lwip/core/mem.c **** #else /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 199:./src/lwip/core/mem.c **** 
 200:./src/lwip/core/mem.c **** /* Protect the heap only by using a semaphore */
 201:./src/lwip/core/mem.c **** #define LWIP_MEM_FREE_DECL_PROTECT()
 202:./src/lwip/core/mem.c **** #define LWIP_MEM_FREE_PROTECT()    sys_arch_sem_wait(mem_sem, 0)
 203:./src/lwip/core/mem.c **** #define LWIP_MEM_FREE_UNPROTECT()  sys_sem_signal(mem_sem)
 204:./src/lwip/core/mem.c **** /* mem_malloc is protected using semaphore AND LWIP_MEM_ALLOC_PROTECT */
 205:./src/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_DECL_PROTECT()
 206:./src/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_PROTECT()
 207:./src/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_UNPROTECT()
 208:./src/lwip/core/mem.c **** 
 209:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 210:./src/lwip/core/mem.c **** 
 211:./src/lwip/core/mem.c **** 
 212:./src/lwip/core/mem.c **** /**
 213:./src/lwip/core/mem.c ****  * "Plug holes" by combining adjacent empty struct mems.
 214:./src/lwip/core/mem.c ****  * After this function is through, there should not exist
 215:./src/lwip/core/mem.c ****  * one empty struct mem pointing to another empty struct mem.
 216:./src/lwip/core/mem.c ****  *
 217:./src/lwip/core/mem.c ****  * @param mem this points to a struct mem which just has been freed
 218:./src/lwip/core/mem.c ****  * @internal this function is only called by mem_free() and mem_realloc()
 219:./src/lwip/core/mem.c ****  *
 220:./src/lwip/core/mem.c ****  * This assumes access to the heap is protected by the calling function
 221:./src/lwip/core/mem.c ****  * already.
 222:./src/lwip/core/mem.c ****  */
 223:./src/lwip/core/mem.c **** static void
 224:./src/lwip/core/mem.c **** plug_holes(struct mem *mem)
 225:./src/lwip/core/mem.c **** {
  42              		.loc 1 225 0
  43              		@ Function supports interworking.
  44              		@ args = 0, pretend = 0, frame = 16
  45              		@ frame_needed = 1, uses_anonymous_args = 0
  46              		@ link register save eliminated.
  47 0000 04B02DE5 		str	fp, [sp, #-4]!
  48              	.LCFI0:
  49 0004 00B08DE2 		add	fp, sp, #0
  50              	.LCFI1:
  51 0008 14D04DE2 		sub	sp, sp, #20
  52              	.LCFI2:
  53 000c 10000BE5 		str	r0, [fp, #-16]
 226:./src/lwip/core/mem.c ****   struct mem *nmem;
 227:./src/lwip/core/mem.c ****   struct mem *pmem;
 228:./src/lwip/core/mem.c **** 
 229:./src/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 230:./src/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 231:./src/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 232:./src/lwip/core/mem.c **** 
 233:./src/lwip/core/mem.c ****   /* plug hole forward */
 234:./src/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 235:./src/lwip/core/mem.c **** 
 236:./src/lwip/core/mem.c ****   nmem = (struct mem *)&ram[mem->next];
  54              		.loc 1 236 0
  55 0010 78319FE5 		ldr	r3, .L7
  56 0014 003093E5 		ldr	r3, [r3, #0]
  57 0018 0320A0E1 		mov	r2, r3
  58 001c 10301BE5 		ldr	r3, [fp, #-16]
  59 0020 B030D3E1 		ldrh	r3, [r3, #0]
  60 0024 033082E0 		add	r3, r2, r3
  61 0028 0C300BE5 		str	r3, [fp, #-12]
 237:./src/lwip/core/mem.c ****   if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  62              		.loc 1 237 0
  63 002c 10201BE5 		ldr	r2, [fp, #-16]
  64 0030 0C301BE5 		ldr	r3, [fp, #-12]
  65 0034 030052E1 		cmp	r2, r3
  66 0038 2500000A 		beq	.L2
  67 003c 0C301BE5 		ldr	r3, [fp, #-12]
  68 0040 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
  69 0044 000053E3 		cmp	r3, #0
  70 0048 2100001A 		bne	.L2
  71 004c 0C201BE5 		ldr	r2, [fp, #-12]
  72 0050 3C319FE5 		ldr	r3, .L7+4
  73 0054 003093E5 		ldr	r3, [r3, #0]
  74 0058 030052E1 		cmp	r2, r3
  75 005c 1C00000A 		beq	.L2
 238:./src/lwip/core/mem.c ****     /* if mem->next is unused and not end of ram, combine mem and mem->next */
 239:./src/lwip/core/mem.c ****     if (lfree == nmem) {
  76              		.loc 1 239 0
  77 0060 30319FE5 		ldr	r3, .L7+8
  78 0064 002093E5 		ldr	r2, [r3, #0]
  79 0068 0C301BE5 		ldr	r3, [fp, #-12]
  80 006c 030052E1 		cmp	r2, r3
  81 0070 0200001A 		bne	.L3
 240:./src/lwip/core/mem.c ****       lfree = mem;
  82              		.loc 1 240 0
  83 0074 1C319FE5 		ldr	r3, .L7+8
  84 0078 10201BE5 		ldr	r2, [fp, #-16]
  85 007c 002083E5 		str	r2, [r3, #0]
  86              	.L3:
 241:./src/lwip/core/mem.c ****     }
 242:./src/lwip/core/mem.c ****     mem->next = nmem->next;
  87              		.loc 1 242 0
  88 0080 0C301BE5 		ldr	r3, [fp, #-12]
  89 0084 B020D3E1 		ldrh	r2, [r3, #0]
  90 0088 10301BE5 		ldr	r3, [fp, #-16]
  91 008c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 243:./src/lwip/core/mem.c ****     ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  92              		.loc 1 243 0
  93 0090 F8309FE5 		ldr	r3, .L7
  94 0094 003093E5 		ldr	r3, [r3, #0]
  95 0098 0320A0E1 		mov	r2, r3
  96 009c 0C301BE5 		ldr	r3, [fp, #-12]
  97 00a0 B030D3E1 		ldrh	r3, [r3, #0]
  98 00a4 033082E0 		add	r3, r2, r3
  99 00a8 10201BE5 		ldr	r2, [fp, #-16]
 100 00ac 0228A0E1 		mov	r2, r2, asl #16
 101 00b0 2218A0E1 		mov	r1, r2, lsr #16
 102 00b4 D4209FE5 		ldr	r2, .L7
 103 00b8 002092E5 		ldr	r2, [r2, #0]
 104 00bc 0228A0E1 		mov	r2, r2, asl #16
 105 00c0 2228A0E1 		mov	r2, r2, lsr #16
 106 00c4 012062E0 		rsb	r2, r2, r1
 107 00c8 0228A0E1 		mov	r2, r2, asl #16
 108 00cc 2228A0E1 		mov	r2, r2, lsr #16
 109 00d0 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 110              	.L2:
 244:./src/lwip/core/mem.c ****   }
 245:./src/lwip/core/mem.c **** 
 246:./src/lwip/core/mem.c ****   /* plug hole backward */
 247:./src/lwip/core/mem.c ****   pmem = (struct mem *)&ram[mem->prev];
 111              		.loc 1 247 0
 112 00d4 B4309FE5 		ldr	r3, .L7
 113 00d8 003093E5 		ldr	r3, [r3, #0]
 114 00dc 0320A0E1 		mov	r2, r3
 115 00e0 10301BE5 		ldr	r3, [fp, #-16]
 116 00e4 B230D3E1 		ldrh	r3, [r3, #2]
 117 00e8 033082E0 		add	r3, r2, r3
 118 00ec 08300BE5 		str	r3, [fp, #-8]
 248:./src/lwip/core/mem.c ****   if (pmem != mem && pmem->used == 0) {
 119              		.loc 1 248 0
 120 00f0 08201BE5 		ldr	r2, [fp, #-8]
 121 00f4 10301BE5 		ldr	r3, [fp, #-16]
 122 00f8 030052E1 		cmp	r2, r3
 123 00fc 2000000A 		beq	.L6
 124 0100 08301BE5 		ldr	r3, [fp, #-8]
 125 0104 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 126 0108 000053E3 		cmp	r3, #0
 127 010c 1C00001A 		bne	.L6
 249:./src/lwip/core/mem.c ****     /* if mem->prev is unused, combine mem and mem->prev */
 250:./src/lwip/core/mem.c ****     if (lfree == mem) {
 128              		.loc 1 250 0
 129 0110 80309FE5 		ldr	r3, .L7+8
 130 0114 002093E5 		ldr	r2, [r3, #0]
 131 0118 10301BE5 		ldr	r3, [fp, #-16]
 132 011c 030052E1 		cmp	r2, r3
 133 0120 0200001A 		bne	.L5
 251:./src/lwip/core/mem.c ****       lfree = pmem;
 134              		.loc 1 251 0
 135 0124 6C309FE5 		ldr	r3, .L7+8
 136 0128 08201BE5 		ldr	r2, [fp, #-8]
 137 012c 002083E5 		str	r2, [r3, #0]
 138              	.L5:
 252:./src/lwip/core/mem.c ****     }
 253:./src/lwip/core/mem.c ****     pmem->next = mem->next;
 139              		.loc 1 253 0
 140 0130 10301BE5 		ldr	r3, [fp, #-16]
 141 0134 B020D3E1 		ldrh	r2, [r3, #0]
 142 0138 08301BE5 		ldr	r3, [fp, #-8]
 143 013c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 254:./src/lwip/core/mem.c ****     ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
 144              		.loc 1 254 0
 145 0140 48309FE5 		ldr	r3, .L7
 146 0144 003093E5 		ldr	r3, [r3, #0]
 147 0148 0320A0E1 		mov	r2, r3
 148 014c 10301BE5 		ldr	r3, [fp, #-16]
 149 0150 B030D3E1 		ldrh	r3, [r3, #0]
 150 0154 033082E0 		add	r3, r2, r3
 151 0158 08201BE5 		ldr	r2, [fp, #-8]
 152 015c 0228A0E1 		mov	r2, r2, asl #16
 153 0160 2218A0E1 		mov	r1, r2, lsr #16
 154 0164 24209FE5 		ldr	r2, .L7
 155 0168 002092E5 		ldr	r2, [r2, #0]
 156 016c 0228A0E1 		mov	r2, r2, asl #16
 157 0170 2228A0E1 		mov	r2, r2, lsr #16
 158 0174 012062E0 		rsb	r2, r2, r1
 159 0178 0228A0E1 		mov	r2, r2, asl #16
 160 017c 2228A0E1 		mov	r2, r2, lsr #16
 161 0180 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 162              	.L6:
 255:./src/lwip/core/mem.c ****   }
 256:./src/lwip/core/mem.c **** }
 163              		.loc 1 256 0
 164 0184 00D08BE2 		add	sp, fp, #0
 165 0188 0008BDE8 		ldmfd	sp!, {fp}
 166 018c 1EFF2FE1 		bx	lr
 167              	.L8:
 168              		.align	2
 169              	.L7:
 170 0190 50060000 		.word	ram
 171 0194 54060000 		.word	ram_end
 172 0198 58060000 		.word	lfree
 173              	.LFE0:
 175              		.align	2
 176              		.global	mem_init
 178              	mem_init:
 179              	.LFB1:
 257:./src/lwip/core/mem.c **** 
 258:./src/lwip/core/mem.c **** /**
 259:./src/lwip/core/mem.c ****  * Zero the heap and initialize start, end and lowest-free
 260:./src/lwip/core/mem.c ****  */
 261:./src/lwip/core/mem.c **** void
 262:./src/lwip/core/mem.c **** mem_init(void)
 263:./src/lwip/core/mem.c **** {
 180              		.loc 1 263 0
 181              		@ Function supports interworking.
 182              		@ args = 0, pretend = 0, frame = 8
 183              		@ frame_needed = 1, uses_anonymous_args = 0
 184 019c 00482DE9 		stmfd	sp!, {fp, lr}
 185              	.LCFI3:
 186 01a0 04B08DE2 		add	fp, sp, #4
 187              	.LCFI4:
 188 01a4 08D04DE2 		sub	sp, sp, #8
 189              	.LCFI5:
 264:./src/lwip/core/mem.c ****   struct mem *mem;
 265:./src/lwip/core/mem.c **** 
 266:./src/lwip/core/mem.c ****   LWIP_ASSERT("Sanity check alignment",
 267:./src/lwip/core/mem.c ****     (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
 268:./src/lwip/core/mem.c **** 
 269:./src/lwip/core/mem.c ****   /* align the heap */
 270:./src/lwip/core/mem.c ****   ram = LWIP_MEM_ALIGN(ram_heap);
 190              		.loc 1 270 0
 191 01a8 B8309FE5 		ldr	r3, .L11
 192 01ac B8209FE5 		ldr	r2, .L11+4
 193 01b0 002083E5 		str	r2, [r3, #0]
 271:./src/lwip/core/mem.c ****   /* initialize the start of the heap */
 272:./src/lwip/core/mem.c ****   mem = (struct mem *)ram;
 194              		.loc 1 272 0
 195 01b4 AC309FE5 		ldr	r3, .L11
 196 01b8 003093E5 		ldr	r3, [r3, #0]
 197 01bc 08300BE5 		str	r3, [fp, #-8]
 273:./src/lwip/core/mem.c ****   mem->next = MEM_SIZE_ALIGNED;
 198              		.loc 1 273 0
 199 01c0 08301BE5 		ldr	r3, [fp, #-8]
 200 01c4 192DA0E3 		mov	r2, #1600
 201 01c8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 274:./src/lwip/core/mem.c ****   mem->prev = 0;
 202              		.loc 1 274 0
 203 01cc 08301BE5 		ldr	r3, [fp, #-8]
 204 01d0 0020A0E3 		mov	r2, #0
 205 01d4 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 275:./src/lwip/core/mem.c ****   mem->used = 0;
 206              		.loc 1 275 0
 207 01d8 08301BE5 		ldr	r3, [fp, #-8]
 208 01dc 0020A0E3 		mov	r2, #0
 209 01e0 0420C3E5 		strb	r2, [r3, #4]
 276:./src/lwip/core/mem.c ****   /* initialize the end of the heap */
 277:./src/lwip/core/mem.c ****   ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
 210              		.loc 1 277 0
 211 01e4 7C309FE5 		ldr	r3, .L11
 212 01e8 003093E5 		ldr	r3, [r3, #0]
 213 01ec 192D83E2 		add	r2, r3, #1600
 214 01f0 78309FE5 		ldr	r3, .L11+8
 215 01f4 002083E5 		str	r2, [r3, #0]
 278:./src/lwip/core/mem.c ****   ram_end->used = 1;
 216              		.loc 1 278 0
 217 01f8 70309FE5 		ldr	r3, .L11+8
 218 01fc 003093E5 		ldr	r3, [r3, #0]
 219 0200 0120A0E3 		mov	r2, #1
 220 0204 0420C3E5 		strb	r2, [r3, #4]
 279:./src/lwip/core/mem.c ****   ram_end->next = MEM_SIZE_ALIGNED;
 221              		.loc 1 279 0
 222 0208 60309FE5 		ldr	r3, .L11+8
 223 020c 003093E5 		ldr	r3, [r3, #0]
 224 0210 192DA0E3 		mov	r2, #1600
 225 0214 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 280:./src/lwip/core/mem.c ****   ram_end->prev = MEM_SIZE_ALIGNED;
 226              		.loc 1 280 0
 227 0218 50309FE5 		ldr	r3, .L11+8
 228 021c 003093E5 		ldr	r3, [r3, #0]
 229 0220 192DA0E3 		mov	r2, #1600
 230 0224 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 281:./src/lwip/core/mem.c **** 
 282:./src/lwip/core/mem.c ****   mem_sem = sys_sem_new(1);
 231              		.loc 1 282 0
 232 0228 0100A0E3 		mov	r0, #1
 233 022c FEFFFFEB 		bl	sys_sem_new
 234 0230 0020A0E1 		mov	r2, r0
 235 0234 38309FE5 		ldr	r3, .L11+12
 236 0238 002083E5 		str	r2, [r3, #0]
 283:./src/lwip/core/mem.c **** 
 284:./src/lwip/core/mem.c ****   /* initialize the lowest-free pointer to the start of the heap */
 285:./src/lwip/core/mem.c ****   lfree = (struct mem *)ram;
 237              		.loc 1 285 0
 238 023c 24309FE5 		ldr	r3, .L11
 239 0240 003093E5 		ldr	r3, [r3, #0]
 240 0244 0320A0E1 		mov	r2, r3
 241 0248 28309FE5 		ldr	r3, .L11+16
 242 024c 002083E5 		str	r2, [r3, #0]
 286:./src/lwip/core/mem.c **** 
 287:./src/lwip/core/mem.c ****   MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 243              		.loc 1 287 0
 244 0250 24309FE5 		ldr	r3, .L11+20
 245 0254 192DA0E3 		mov	r2, #1600
 246 0258 B82AC3E1 		strh	r2, [r3, #168]	@ movhi
 288:./src/lwip/core/mem.c **** }
 247              		.loc 1 288 0
 248 025c 04D04BE2 		sub	sp, fp, #4
 249 0260 0048BDE8 		ldmfd	sp!, {fp, lr}
 250 0264 1EFF2FE1 		bx	lr
 251              	.L12:
 252              		.align	2
 253              	.L11:
 254 0268 50060000 		.word	ram
 255 026c 00000000 		.word	ram_heap
 256 0270 54060000 		.word	ram_end
 257 0274 5C060000 		.word	mem_sem
 258 0278 58060000 		.word	lfree
 259 027c 00000000 		.word	lwip_stats
 260              	.LFE1:
 262              		.align	2
 263              		.global	mem_free
 265              	mem_free:
 266              	.LFB2:
 289:./src/lwip/core/mem.c **** 
 290:./src/lwip/core/mem.c **** /**
 291:./src/lwip/core/mem.c ****  * Put a struct mem back on the heap
 292:./src/lwip/core/mem.c ****  *
 293:./src/lwip/core/mem.c ****  * @param rmem is the data portion of a struct mem as returned by a previous
 294:./src/lwip/core/mem.c ****  *             call to mem_malloc()
 295:./src/lwip/core/mem.c ****  */
 296:./src/lwip/core/mem.c **** void
 297:./src/lwip/core/mem.c **** mem_free(void *rmem)
 298:./src/lwip/core/mem.c **** {
 267              		.loc 1 298 0
 268              		@ Function supports interworking.
 269              		@ args = 0, pretend = 0, frame = 16
 270              		@ frame_needed = 1, uses_anonymous_args = 0
 271 0280 00482DE9 		stmfd	sp!, {fp, lr}
 272              	.LCFI6:
 273 0284 04B08DE2 		add	fp, sp, #4
 274              	.LCFI7:
 275 0288 10D04DE2 		sub	sp, sp, #16
 276              	.LCFI8:
 277 028c 10000BE5 		str	r0, [fp, #-16]
 299:./src/lwip/core/mem.c ****   struct mem *mem;
 300:./src/lwip/core/mem.c ****   LWIP_MEM_FREE_DECL_PROTECT();
 301:./src/lwip/core/mem.c **** 
 302:./src/lwip/core/mem.c ****   if (rmem == NULL) {
 278              		.loc 1 302 0
 279 0290 10301BE5 		ldr	r3, [fp, #-16]
 280 0294 000053E3 		cmp	r3, #0
 281 0298 4500000A 		beq	.L21
 282              	.L14:
 303:./src/lwip/core/mem.c ****     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was call
 304:./src/lwip/core/mem.c ****     return;
 305:./src/lwip/core/mem.c ****   }
 306:./src/lwip/core/mem.c ****   LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 307:./src/lwip/core/mem.c **** 
 308:./src/lwip/core/mem.c ****   LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 283              		.loc 1 308 0
 284 029c 10201BE5 		ldr	r2, [fp, #-16]
 285 02a0 1C319FE5 		ldr	r3, .L22
 286 02a4 003093E5 		ldr	r3, [r3, #0]
 287 02a8 030052E1 		cmp	r2, r3
 309:./src/lwip/core/mem.c ****     (u8_t *)rmem < (u8_t *)ram_end);
 310:./src/lwip/core/mem.c **** 
 311:./src/lwip/core/mem.c ****   if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 288              		.loc 1 311 0
 289 02ac 10201BE5 		ldr	r2, [fp, #-16]
 290 02b0 0C319FE5 		ldr	r3, .L22
 291 02b4 003093E5 		ldr	r3, [r3, #0]
 292 02b8 030052E1 		cmp	r2, r3
 293 02bc 0400003A 		bcc	.L17
 294 02c0 10201BE5 		ldr	r2, [fp, #-16]
 295 02c4 FC309FE5 		ldr	r3, .L22+4
 296 02c8 003093E5 		ldr	r3, [r3, #0]
 297 02cc 030052E1 		cmp	r2, r3
 298 02d0 0700003A 		bcc	.L18
 299              	.L17:
 312:./src/lwip/core/mem.c ****     SYS_ARCH_DECL_PROTECT(lev);
 313:./src/lwip/core/mem.c ****     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
 314:./src/lwip/core/mem.c ****     /* protect mem stats from concurrent access */
 315:./src/lwip/core/mem.c ****     SYS_ARCH_PROTECT(lev);
 316:./src/lwip/core/mem.c ****     MEM_STATS_INC(illegal);
 300              		.loc 1 316 0
 301 02d4 F0309FE5 		ldr	r3, .L22+8
 302 02d8 B03BD3E1 		ldrh	r3, [r3, #176]
 303 02dc 013083E2 		add	r3, r3, #1
 304 02e0 0338A0E1 		mov	r3, r3, asl #16
 305 02e4 2328A0E1 		mov	r2, r3, lsr #16
 306 02e8 DC309FE5 		ldr	r3, .L22+8
 307 02ec B02BC3E1 		strh	r2, [r3, #176]	@ movhi
 317:./src/lwip/core/mem.c ****     SYS_ARCH_UNPROTECT(lev);
 318:./src/lwip/core/mem.c ****     return;
 308              		.loc 1 318 0
 309 02f0 300000EA 		b	.L20
 310              	.L18:
 319:./src/lwip/core/mem.c ****   }
 320:./src/lwip/core/mem.c ****   /* protect the heap from concurrent access */
 321:./src/lwip/core/mem.c ****   LWIP_MEM_FREE_PROTECT();
 311              		.loc 1 321 0
 312 02f4 D4309FE5 		ldr	r3, .L22+12
 313 02f8 003093E5 		ldr	r3, [r3, #0]
 314 02fc 0300A0E1 		mov	r0, r3
 315 0300 0010A0E3 		mov	r1, #0
 316 0304 FEFFFFEB 		bl	sys_arch_sem_wait
 322:./src/lwip/core/mem.c ****   /* Get the corresponding struct mem ... */
 323:./src/lwip/core/mem.c ****   mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 317              		.loc 1 323 0
 318 0308 10301BE5 		ldr	r3, [fp, #-16]
 319 030c 063043E2 		sub	r3, r3, #6
 320 0310 08300BE5 		str	r3, [fp, #-8]
 324:./src/lwip/core/mem.c ****   /* ... which has to be in a used state ... */
 325:./src/lwip/core/mem.c ****   LWIP_ASSERT("mem_free: mem->used", mem->used);
 326:./src/lwip/core/mem.c ****   /* ... and is now unused. */
 327:./src/lwip/core/mem.c ****   mem->used = 0;
 321              		.loc 1 327 0
 322 0314 08301BE5 		ldr	r3, [fp, #-8]
 323 0318 0020A0E3 		mov	r2, #0
 324 031c 0420C3E5 		strb	r2, [r3, #4]
 328:./src/lwip/core/mem.c **** 
 329:./src/lwip/core/mem.c ****   if (mem < lfree) {
 325              		.loc 1 329 0
 326 0320 AC309FE5 		ldr	r3, .L22+16
 327 0324 003093E5 		ldr	r3, [r3, #0]
 328 0328 08201BE5 		ldr	r2, [fp, #-8]
 329 032c 030052E1 		cmp	r2, r3
 330 0330 0200002A 		bcs	.L19
 330:./src/lwip/core/mem.c ****     /* the newly freed struct is now the lowest */
 331:./src/lwip/core/mem.c ****     lfree = mem;
 331              		.loc 1 331 0
 332 0334 98309FE5 		ldr	r3, .L22+16
 333 0338 08201BE5 		ldr	r2, [fp, #-8]
 334 033c 002083E5 		str	r2, [r3, #0]
 335              	.L19:
 332:./src/lwip/core/mem.c ****   }
 333:./src/lwip/core/mem.c **** 
 334:./src/lwip/core/mem.c ****   MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));
 336              		.loc 1 334 0
 337 0340 84309FE5 		ldr	r3, .L22+8
 338 0344 BA2AD3E1 		ldrh	r2, [r3, #170]
 339 0348 08301BE5 		ldr	r3, [fp, #-8]
 340 034c 0338A0E1 		mov	r3, r3, asl #16
 341 0350 2318A0E1 		mov	r1, r3, lsr #16
 342 0354 68309FE5 		ldr	r3, .L22
 343 0358 003093E5 		ldr	r3, [r3, #0]
 344 035c 0338A0E1 		mov	r3, r3, asl #16
 345 0360 2338A0E1 		mov	r3, r3, lsr #16
 346 0364 013063E0 		rsb	r3, r3, r1
 347 0368 0338A0E1 		mov	r3, r3, asl #16
 348 036c 2318A0E1 		mov	r1, r3, lsr #16
 349 0370 08301BE5 		ldr	r3, [fp, #-8]
 350 0374 B030D3E1 		ldrh	r3, [r3, #0]
 351 0378 013063E0 		rsb	r3, r3, r1
 352 037c 0338A0E1 		mov	r3, r3, asl #16
 353 0380 2338A0E1 		mov	r3, r3, lsr #16
 354 0384 033082E0 		add	r3, r2, r3
 355 0388 0338A0E1 		mov	r3, r3, asl #16
 356 038c 2328A0E1 		mov	r2, r3, lsr #16
 357 0390 34309FE5 		ldr	r3, .L22+8
 358 0394 BA2AC3E1 		strh	r2, [r3, #170]	@ movhi
 335:./src/lwip/core/mem.c **** 
 336:./src/lwip/core/mem.c ****   /* finally, see if prev or next are free also */
 337:./src/lwip/core/mem.c ****   plug_holes(mem);
 359              		.loc 1 337 0
 360 0398 08001BE5 		ldr	r0, [fp, #-8]
 361 039c 17FFFFEB 		bl	plug_holes
 338:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 339:./src/lwip/core/mem.c ****   mem_free_count = 1;
 340:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 341:./src/lwip/core/mem.c ****   LWIP_MEM_FREE_UNPROTECT();
 362              		.loc 1 341 0
 363 03a0 28309FE5 		ldr	r3, .L22+12
 364 03a4 003093E5 		ldr	r3, [r3, #0]
 365 03a8 0300A0E1 		mov	r0, r3
 366 03ac FEFFFFEB 		bl	sys_sem_signal
 367 03b0 000000EA 		b	.L20
 368              	.L21:
 369              		.loc 1 304 0
 370 03b4 0000A0E1 		mov	r0, r0	@ nop
 371              	.L20:
 342:./src/lwip/core/mem.c **** }
 372              		.loc 1 342 0
 373 03b8 04D04BE2 		sub	sp, fp, #4
 374 03bc 0048BDE8 		ldmfd	sp!, {fp, lr}
 375 03c0 1EFF2FE1 		bx	lr
 376              	.L23:
 377              		.align	2
 378              	.L22:
 379 03c4 50060000 		.word	ram
 380 03c8 54060000 		.word	ram_end
 381 03cc 00000000 		.word	lwip_stats
 382 03d0 5C060000 		.word	mem_sem
 383 03d4 58060000 		.word	lfree
 384              	.LFE2:
 386              		.align	2
 387              		.global	mem_realloc
 389              	mem_realloc:
 390              	.LFB3:
 343:./src/lwip/core/mem.c **** 
 344:./src/lwip/core/mem.c **** /**
 345:./src/lwip/core/mem.c ****  * In contrast to its name, mem_realloc can only shrink memory, not expand it.
 346:./src/lwip/core/mem.c ****  * Since the only use (for now) is in pbuf_realloc (which also can only shrink),
 347:./src/lwip/core/mem.c ****  * this shouldn't be a problem!
 348:./src/lwip/core/mem.c ****  *
 349:./src/lwip/core/mem.c ****  * @param rmem pointer to memory allocated by mem_malloc the is to be shrinked
 350:./src/lwip/core/mem.c ****  * @param newsize required size after shrinking (needs to be smaller than or
 351:./src/lwip/core/mem.c ****  *                equal to the previous size)
 352:./src/lwip/core/mem.c ****  * @return for compatibility reasons: is always == rmem, at the moment
 353:./src/lwip/core/mem.c ****  *         or NULL if newsize is > old size, in which case rmem is NOT touched
 354:./src/lwip/core/mem.c ****  *         or freed!
 355:./src/lwip/core/mem.c ****  */
 356:./src/lwip/core/mem.c **** void *
 357:./src/lwip/core/mem.c **** mem_realloc(void *rmem, mem_size_t newsize)
 358:./src/lwip/core/mem.c **** {
 391              		.loc 1 358 0
 392              		@ Function supports interworking.
 393              		@ args = 0, pretend = 0, frame = 32
 394              		@ frame_needed = 1, uses_anonymous_args = 0
 395 03d8 00482DE9 		stmfd	sp!, {fp, lr}
 396              	.LCFI9:
 397 03dc 04B08DE2 		add	fp, sp, #4
 398              	.LCFI10:
 399 03e0 20D04DE2 		sub	sp, sp, #32
 400              	.LCFI11:
 401 03e4 20000BE5 		str	r0, [fp, #-32]
 402 03e8 0130A0E1 		mov	r3, r1
 403 03ec B2324BE1 		strh	r3, [fp, #-34]	@ movhi
 359:./src/lwip/core/mem.c ****   mem_size_t size;
 360:./src/lwip/core/mem.c ****   mem_size_t ptr, ptr2;
 361:./src/lwip/core/mem.c ****   struct mem *mem, *mem2;
 362:./src/lwip/core/mem.c ****   /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
 363:./src/lwip/core/mem.c ****   LWIP_MEM_FREE_DECL_PROTECT();
 364:./src/lwip/core/mem.c **** 
 365:./src/lwip/core/mem.c ****   /* Expand the size of the allocated memory region so that we can
 366:./src/lwip/core/mem.c ****      adjust for alignment. */
 367:./src/lwip/core/mem.c ****   newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 368:./src/lwip/core/mem.c **** 
 369:./src/lwip/core/mem.c ****   if(newsize < MIN_SIZE_ALIGNED) {
 404              		.loc 1 369 0
 405 03f0 B2325BE1 		ldrh	r3, [fp, #-34]
 406 03f4 0B0053E3 		cmp	r3, #11
 407 03f8 0100008A 		bhi	.L25
 370:./src/lwip/core/mem.c ****     /* every data block must be at least MIN_SIZE_ALIGNED long */
 371:./src/lwip/core/mem.c ****     newsize = MIN_SIZE_ALIGNED;
 408              		.loc 1 371 0
 409 03fc 0C30A0E3 		mov	r3, #12
 410 0400 B2324BE1 		strh	r3, [fp, #-34]	@ movhi
 411              	.L25:
 372:./src/lwip/core/mem.c ****   }
 373:./src/lwip/core/mem.c **** 
 374:./src/lwip/core/mem.c ****   if (newsize > MEM_SIZE_ALIGNED) {
 412              		.loc 1 374 0
 413 0404 B2325BE1 		ldrh	r3, [fp, #-34]
 414 0408 190D53E3 		cmp	r3, #1600
 415 040c 0100009A 		bls	.L26
 375:./src/lwip/core/mem.c ****     return NULL;
 416              		.loc 1 375 0
 417 0410 0030A0E3 		mov	r3, #0
 418 0414 C10000EA 		b	.L27
 419              	.L26:
 376:./src/lwip/core/mem.c ****   }
 377:./src/lwip/core/mem.c **** 
 378:./src/lwip/core/mem.c ****   LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 420              		.loc 1 378 0
 421 0418 20201BE5 		ldr	r2, [fp, #-32]
 422 041c 0C339FE5 		ldr	r3, .L40
 423 0420 003093E5 		ldr	r3, [r3, #0]
 424 0424 030052E1 		cmp	r2, r3
 379:./src/lwip/core/mem.c ****    (u8_t *)rmem < (u8_t *)ram_end);
 380:./src/lwip/core/mem.c **** 
 381:./src/lwip/core/mem.c ****   if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 425              		.loc 1 381 0
 426 0428 20201BE5 		ldr	r2, [fp, #-32]
 427 042c FC329FE5 		ldr	r3, .L40
 428 0430 003093E5 		ldr	r3, [r3, #0]
 429 0434 030052E1 		cmp	r2, r3
 430 0438 0400003A 		bcc	.L29
 431 043c 20201BE5 		ldr	r2, [fp, #-32]
 432 0440 EC329FE5 		ldr	r3, .L40+4
 433 0444 003093E5 		ldr	r3, [r3, #0]
 434 0448 030052E1 		cmp	r2, r3
 435 044c 0800003A 		bcc	.L30
 436              	.L29:
 382:./src/lwip/core/mem.c ****     SYS_ARCH_DECL_PROTECT(lev);
 383:./src/lwip/core/mem.c ****     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_realloc: illegal memory\n"));
 384:./src/lwip/core/mem.c ****     /* protect mem stats from concurrent access */
 385:./src/lwip/core/mem.c ****     SYS_ARCH_PROTECT(lev);
 386:./src/lwip/core/mem.c ****     MEM_STATS_INC(illegal);
 437              		.loc 1 386 0
 438 0450 E0329FE5 		ldr	r3, .L40+8
 439 0454 B03BD3E1 		ldrh	r3, [r3, #176]
 440 0458 013083E2 		add	r3, r3, #1
 441 045c 0338A0E1 		mov	r3, r3, asl #16
 442 0460 2328A0E1 		mov	r2, r3, lsr #16
 443 0464 CC329FE5 		ldr	r3, .L40+8
 444 0468 B02BC3E1 		strh	r2, [r3, #176]	@ movhi
 387:./src/lwip/core/mem.c ****     SYS_ARCH_UNPROTECT(lev);
 388:./src/lwip/core/mem.c ****     return rmem;
 445              		.loc 1 388 0
 446 046c 20301BE5 		ldr	r3, [fp, #-32]
 447 0470 AA0000EA 		b	.L27
 448              	.L30:
 389:./src/lwip/core/mem.c ****   }
 390:./src/lwip/core/mem.c ****   /* Get the corresponding struct mem ... */
 391:./src/lwip/core/mem.c ****   mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 449              		.loc 1 391 0
 450 0474 20301BE5 		ldr	r3, [fp, #-32]
 451 0478 063043E2 		sub	r3, r3, #6
 452 047c 10300BE5 		str	r3, [fp, #-16]
 392:./src/lwip/core/mem.c ****   /* ... and its offset pointer */
 393:./src/lwip/core/mem.c ****   ptr = (u8_t *)mem - ram;
 453              		.loc 1 393 0
 454 0480 10301BE5 		ldr	r3, [fp, #-16]
 455 0484 0338A0E1 		mov	r3, r3, asl #16
 456 0488 2328A0E1 		mov	r2, r3, lsr #16
 457 048c 9C329FE5 		ldr	r3, .L40
 458 0490 003093E5 		ldr	r3, [r3, #0]
 459 0494 0338A0E1 		mov	r3, r3, asl #16
 460 0498 2338A0E1 		mov	r3, r3, lsr #16
 461 049c 023063E0 		rsb	r3, r3, r2
 462 04a0 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 394:./src/lwip/core/mem.c **** 
 395:./src/lwip/core/mem.c ****   size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 463              		.loc 1 395 0
 464 04a4 10301BE5 		ldr	r3, [fp, #-16]
 465 04a8 B020D3E1 		ldrh	r2, [r3, #0]
 466 04ac B4315BE1 		ldrh	r3, [fp, #-20]	@ movhi
 467 04b0 023063E0 		rsb	r3, r3, r2
 468 04b4 0338A0E1 		mov	r3, r3, asl #16
 469 04b8 2338A0E1 		mov	r3, r3, lsr #16
 470 04bc 063043E2 		sub	r3, r3, #6
 471 04c0 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 396:./src/lwip/core/mem.c ****   LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
 397:./src/lwip/core/mem.c ****   if (newsize > size) {
 472              		.loc 1 397 0
 473 04c4 B2225BE1 		ldrh	r2, [fp, #-34]
 474 04c8 B6315BE1 		ldrh	r3, [fp, #-22]
 475 04cc 030052E1 		cmp	r2, r3
 476 04d0 0100009A 		bls	.L31
 398:./src/lwip/core/mem.c ****     /* not supported */
 399:./src/lwip/core/mem.c ****     return NULL;
 477              		.loc 1 399 0
 478 04d4 0030A0E3 		mov	r3, #0
 479 04d8 900000EA 		b	.L27
 480              	.L31:
 400:./src/lwip/core/mem.c ****   }
 401:./src/lwip/core/mem.c ****   if (newsize == size) {
 481              		.loc 1 401 0
 482 04dc B2225BE1 		ldrh	r2, [fp, #-34]
 483 04e0 B6315BE1 		ldrh	r3, [fp, #-22]
 484 04e4 030052E1 		cmp	r2, r3
 485 04e8 0100001A 		bne	.L32
 402:./src/lwip/core/mem.c ****     /* No change in size, simply return */
 403:./src/lwip/core/mem.c ****     return rmem;
 486              		.loc 1 403 0
 487 04ec 20301BE5 		ldr	r3, [fp, #-32]
 488 04f0 8A0000EA 		b	.L27
 489              	.L32:
 404:./src/lwip/core/mem.c ****   }
 405:./src/lwip/core/mem.c **** 
 406:./src/lwip/core/mem.c ****   /* protect the heap from concurrent access */
 407:./src/lwip/core/mem.c ****   LWIP_MEM_FREE_PROTECT();
 490              		.loc 1 407 0
 491 04f4 40329FE5 		ldr	r3, .L40+12
 492 04f8 003093E5 		ldr	r3, [r3, #0]
 493 04fc 0300A0E1 		mov	r0, r3
 494 0500 0010A0E3 		mov	r1, #0
 495 0504 FEFFFFEB 		bl	sys_arch_sem_wait
 408:./src/lwip/core/mem.c **** 
 409:./src/lwip/core/mem.c ****   MEM_STATS_DEC_USED(used, (size - newsize));
 496              		.loc 1 409 0
 497 0508 28329FE5 		ldr	r3, .L40+8
 498 050c BA2AD3E1 		ldrh	r2, [r3, #170]
 499 0510 B2125BE1 		ldrh	r1, [fp, #-34]	@ movhi
 500 0514 B6315BE1 		ldrh	r3, [fp, #-22]	@ movhi
 501 0518 013063E0 		rsb	r3, r3, r1
 502 051c 0338A0E1 		mov	r3, r3, asl #16
 503 0520 2338A0E1 		mov	r3, r3, lsr #16
 504 0524 033082E0 		add	r3, r2, r3
 505 0528 0338A0E1 		mov	r3, r3, asl #16
 506 052c 2328A0E1 		mov	r2, r3, lsr #16
 507 0530 00329FE5 		ldr	r3, .L40+8
 508 0534 BA2AC3E1 		strh	r2, [r3, #170]	@ movhi
 410:./src/lwip/core/mem.c **** 
 411:./src/lwip/core/mem.c ****   mem2 = (struct mem *)&ram[mem->next];
 509              		.loc 1 411 0
 510 0538 F0319FE5 		ldr	r3, .L40
 511 053c 003093E5 		ldr	r3, [r3, #0]
 512 0540 0320A0E1 		mov	r2, r3
 513 0544 10301BE5 		ldr	r3, [fp, #-16]
 514 0548 B030D3E1 		ldrh	r3, [r3, #0]
 515 054c 033082E0 		add	r3, r2, r3
 516 0550 0C300BE5 		str	r3, [fp, #-12]
 412:./src/lwip/core/mem.c ****   if(mem2->used == 0) {
 517              		.loc 1 412 0
 518 0554 0C301BE5 		ldr	r3, [fp, #-12]
 519 0558 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 520 055c 000053E3 		cmp	r3, #0
 521 0560 3400001A 		bne	.L33
 522              	.LBB2:
 413:./src/lwip/core/mem.c ****     /* The next struct is unused, we can simply move it at little */
 414:./src/lwip/core/mem.c ****     mem_size_t next;
 415:./src/lwip/core/mem.c ****     /* remember the old next pointer */
 416:./src/lwip/core/mem.c ****     next = mem2->next;
 523              		.loc 1 416 0
 524 0564 0C301BE5 		ldr	r3, [fp, #-12]
 525 0568 B030D3E1 		ldrh	r3, [r3, #0]	@ movhi
 526 056c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 417:./src/lwip/core/mem.c ****     /* create new struct mem which is moved directly after the shrinked mem */
 418:./src/lwip/core/mem.c ****     ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 527              		.loc 1 418 0
 528 0570 B4215BE1 		ldrh	r2, [fp, #-20]	@ movhi
 529 0574 B2325BE1 		ldrh	r3, [fp, #-34]	@ movhi
 530 0578 033082E0 		add	r3, r2, r3
 531 057c 0338A0E1 		mov	r3, r3, asl #16
 532 0580 2338A0E1 		mov	r3, r3, lsr #16
 533 0584 063083E2 		add	r3, r3, #6
 534 0588 B2314BE1 		strh	r3, [fp, #-18]	@ movhi
 419:./src/lwip/core/mem.c ****     if (lfree == mem2) {
 535              		.loc 1 419 0
 536 058c AC319FE5 		ldr	r3, .L40+16
 537 0590 002093E5 		ldr	r2, [r3, #0]
 538 0594 0C301BE5 		ldr	r3, [fp, #-12]
 539 0598 030052E1 		cmp	r2, r3
 540 059c 0600001A 		bne	.L34
 420:./src/lwip/core/mem.c ****       lfree = (struct mem *)&ram[ptr2];
 541              		.loc 1 420 0
 542 05a0 88319FE5 		ldr	r3, .L40
 543 05a4 003093E5 		ldr	r3, [r3, #0]
 544 05a8 0320A0E1 		mov	r2, r3
 545 05ac B2315BE1 		ldrh	r3, [fp, #-18]
 546 05b0 032082E0 		add	r2, r2, r3
 547 05b4 84319FE5 		ldr	r3, .L40+16
 548 05b8 002083E5 		str	r2, [r3, #0]
 549              	.L34:
 421:./src/lwip/core/mem.c ****     }
 422:./src/lwip/core/mem.c ****     mem2 = (struct mem *)&ram[ptr2];
 550              		.loc 1 422 0
 551 05bc 6C319FE5 		ldr	r3, .L40
 552 05c0 003093E5 		ldr	r3, [r3, #0]
 553 05c4 0320A0E1 		mov	r2, r3
 554 05c8 B2315BE1 		ldrh	r3, [fp, #-18]
 555 05cc 033082E0 		add	r3, r2, r3
 556 05d0 0C300BE5 		str	r3, [fp, #-12]
 423:./src/lwip/core/mem.c ****     mem2->used = 0;
 557              		.loc 1 423 0
 558 05d4 0C301BE5 		ldr	r3, [fp, #-12]
 559 05d8 0020A0E3 		mov	r2, #0
 560 05dc 0420C3E5 		strb	r2, [r3, #4]
 424:./src/lwip/core/mem.c ****     /* restore the next pointer */
 425:./src/lwip/core/mem.c ****     mem2->next = next;
 561              		.loc 1 425 0
 562 05e0 0C301BE5 		ldr	r3, [fp, #-12]
 563 05e4 B6205BE1 		ldrh	r2, [fp, #-6]	@ movhi
 564 05e8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 426:./src/lwip/core/mem.c ****     /* link it back to mem */
 427:./src/lwip/core/mem.c ****     mem2->prev = ptr;
 565              		.loc 1 427 0
 566 05ec 0C301BE5 		ldr	r3, [fp, #-12]
 567 05f0 B4215BE1 		ldrh	r2, [fp, #-20]	@ movhi
 568 05f4 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 428:./src/lwip/core/mem.c ****     /* link mem to it */
 429:./src/lwip/core/mem.c ****     mem->next = ptr2;
 569              		.loc 1 429 0
 570 05f8 10301BE5 		ldr	r3, [fp, #-16]
 571 05fc B2215BE1 		ldrh	r2, [fp, #-18]	@ movhi
 572 0600 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 430:./src/lwip/core/mem.c ****     /* last thing to restore linked list: as we have moved mem2,
 431:./src/lwip/core/mem.c ****      * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
 432:./src/lwip/core/mem.c ****      * the end of the heap */
 433:./src/lwip/core/mem.c ****     if (mem2->next != MEM_SIZE_ALIGNED) {
 573              		.loc 1 433 0
 574 0604 0C301BE5 		ldr	r3, [fp, #-12]
 575 0608 B030D3E1 		ldrh	r3, [r3, #0]
 576 060c 190D53E3 		cmp	r3, #1600
 577 0610 3C00000A 		beq	.L39
 434:./src/lwip/core/mem.c ****       ((struct mem *)&ram[mem2->next])->prev = ptr2;
 578              		.loc 1 434 0
 579 0614 14319FE5 		ldr	r3, .L40
 580 0618 003093E5 		ldr	r3, [r3, #0]
 581 061c 0320A0E1 		mov	r2, r3
 582 0620 0C301BE5 		ldr	r3, [fp, #-12]
 583 0624 B030D3E1 		ldrh	r3, [r3, #0]
 584 0628 033082E0 		add	r3, r2, r3
 585 062c B2215BE1 		ldrh	r2, [fp, #-18]	@ movhi
 586 0630 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 587 0634 340000EA 		b	.L36
 588              	.L33:
 589              	.LBE2:
 435:./src/lwip/core/mem.c ****     }
 436:./src/lwip/core/mem.c ****     /* no need to plug holes, we've already done that */
 437:./src/lwip/core/mem.c ****   } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 590              		.loc 1 437 0
 591 0638 B2325BE1 		ldrh	r3, [fp, #-34]
 592 063c 122083E2 		add	r2, r3, #18
 593 0640 B6315BE1 		ldrh	r3, [fp, #-22]
 594 0644 030052E1 		cmp	r2, r3
 595 0648 2F00008A 		bhi	.L36
 438:./src/lwip/core/mem.c ****     /* Next struct is used but there's room for another struct mem with
 439:./src/lwip/core/mem.c ****      * at least MIN_SIZE_ALIGNED of data.
 440:./src/lwip/core/mem.c ****      * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
 441:./src/lwip/core/mem.c ****      * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
 442:./src/lwip/core/mem.c ****      * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
 443:./src/lwip/core/mem.c ****      *       region that couldn't hold data, but when mem->next gets freed,
 444:./src/lwip/core/mem.c ****      *       the 2 regions would be combined, resulting in more free memory */
 445:./src/lwip/core/mem.c ****     ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 596              		.loc 1 445 0
 597 064c B4215BE1 		ldrh	r2, [fp, #-20]	@ movhi
 598 0650 B2325BE1 		ldrh	r3, [fp, #-34]	@ movhi
 599 0654 033082E0 		add	r3, r2, r3
 600 0658 0338A0E1 		mov	r3, r3, asl #16
 601 065c 2338A0E1 		mov	r3, r3, lsr #16
 602 0660 063083E2 		add	r3, r3, #6
 603 0664 B2314BE1 		strh	r3, [fp, #-18]	@ movhi
 446:./src/lwip/core/mem.c ****     mem2 = (struct mem *)&ram[ptr2];
 604              		.loc 1 446 0
 605 0668 C0309FE5 		ldr	r3, .L40
 606 066c 003093E5 		ldr	r3, [r3, #0]
 607 0670 0320A0E1 		mov	r2, r3
 608 0674 B2315BE1 		ldrh	r3, [fp, #-18]
 609 0678 033082E0 		add	r3, r2, r3
 610 067c 0C300BE5 		str	r3, [fp, #-12]
 447:./src/lwip/core/mem.c ****     if (mem2 < lfree) {
 611              		.loc 1 447 0
 612 0680 B8309FE5 		ldr	r3, .L40+16
 613 0684 003093E5 		ldr	r3, [r3, #0]
 614 0688 0C201BE5 		ldr	r2, [fp, #-12]
 615 068c 030052E1 		cmp	r2, r3
 616 0690 0200002A 		bcs	.L37
 448:./src/lwip/core/mem.c ****       lfree = mem2;
 617              		.loc 1 448 0
 618 0694 A4309FE5 		ldr	r3, .L40+16
 619 0698 0C201BE5 		ldr	r2, [fp, #-12]
 620 069c 002083E5 		str	r2, [r3, #0]
 621              	.L37:
 449:./src/lwip/core/mem.c ****     }
 450:./src/lwip/core/mem.c ****     mem2->used = 0;
 622              		.loc 1 450 0
 623 06a0 0C301BE5 		ldr	r3, [fp, #-12]
 624 06a4 0020A0E3 		mov	r2, #0
 625 06a8 0420C3E5 		strb	r2, [r3, #4]
 451:./src/lwip/core/mem.c ****     mem2->next = mem->next;
 626              		.loc 1 451 0
 627 06ac 10301BE5 		ldr	r3, [fp, #-16]
 628 06b0 B020D3E1 		ldrh	r2, [r3, #0]
 629 06b4 0C301BE5 		ldr	r3, [fp, #-12]
 630 06b8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 452:./src/lwip/core/mem.c ****     mem2->prev = ptr;
 631              		.loc 1 452 0
 632 06bc 0C301BE5 		ldr	r3, [fp, #-12]
 633 06c0 B4215BE1 		ldrh	r2, [fp, #-20]	@ movhi
 634 06c4 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 453:./src/lwip/core/mem.c ****     mem->next = ptr2;
 635              		.loc 1 453 0
 636 06c8 10301BE5 		ldr	r3, [fp, #-16]
 637 06cc B2215BE1 		ldrh	r2, [fp, #-18]	@ movhi
 638 06d0 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 454:./src/lwip/core/mem.c ****     if (mem2->next != MEM_SIZE_ALIGNED) {
 639              		.loc 1 454 0
 640 06d4 0C301BE5 		ldr	r3, [fp, #-12]
 641 06d8 B030D3E1 		ldrh	r3, [r3, #0]
 642 06dc 190D53E3 		cmp	r3, #1600
 643 06e0 0900000A 		beq	.L36
 455:./src/lwip/core/mem.c ****       ((struct mem *)&ram[mem2->next])->prev = ptr2;
 644              		.loc 1 455 0
 645 06e4 44309FE5 		ldr	r3, .L40
 646 06e8 003093E5 		ldr	r3, [r3, #0]
 647 06ec 0320A0E1 		mov	r2, r3
 648 06f0 0C301BE5 		ldr	r3, [fp, #-12]
 649 06f4 B030D3E1 		ldrh	r3, [r3, #0]
 650 06f8 033082E0 		add	r3, r2, r3
 651 06fc B2215BE1 		ldrh	r2, [fp, #-18]	@ movhi
 652 0700 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 653 0704 000000EA 		b	.L36
 654              	.L39:
 655              	.LBB3:
 656              		.loc 1 434 0
 657 0708 0000A0E1 		mov	r0, r0	@ nop
 658              	.L36:
 659              	.LBE3:
 456:./src/lwip/core/mem.c ****     }
 457:./src/lwip/core/mem.c ****     /* the original mem->next is used, so no need to plug holes! */
 458:./src/lwip/core/mem.c ****   }
 459:./src/lwip/core/mem.c ****   /* else {
 460:./src/lwip/core/mem.c ****     next struct mem is used but size between mem and mem2 is not big enough
 461:./src/lwip/core/mem.c ****     to create another struct mem
 462:./src/lwip/core/mem.c ****     -> don't do anyhting. 
 463:./src/lwip/core/mem.c ****     -> the remaining space stays unused since it is too small
 464:./src/lwip/core/mem.c ****   } */
 465:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 466:./src/lwip/core/mem.c ****   mem_free_count = 1;
 467:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 468:./src/lwip/core/mem.c ****   LWIP_MEM_FREE_UNPROTECT();
 660              		.loc 1 468 0
 661 070c 28309FE5 		ldr	r3, .L40+12
 662 0710 003093E5 		ldr	r3, [r3, #0]
 663 0714 0300A0E1 		mov	r0, r3
 664 0718 FEFFFFEB 		bl	sys_sem_signal
 469:./src/lwip/core/mem.c ****   return rmem;
 665              		.loc 1 469 0
 666 071c 20301BE5 		ldr	r3, [fp, #-32]
 667              	.L27:
 470:./src/lwip/core/mem.c **** }
 668              		.loc 1 470 0
 669 0720 0300A0E1 		mov	r0, r3
 670 0724 04D04BE2 		sub	sp, fp, #4
 671 0728 0048BDE8 		ldmfd	sp!, {fp, lr}
 672 072c 1EFF2FE1 		bx	lr
 673              	.L41:
 674              		.align	2
 675              	.L40:
 676 0730 50060000 		.word	ram
 677 0734 54060000 		.word	ram_end
 678 0738 00000000 		.word	lwip_stats
 679 073c 5C060000 		.word	mem_sem
 680 0740 58060000 		.word	lfree
 681              	.LFE3:
 683              		.align	2
 684              		.global	mem_malloc
 686              	mem_malloc:
 687              	.LFB4:
 471:./src/lwip/core/mem.c **** 
 472:./src/lwip/core/mem.c **** /**
 473:./src/lwip/core/mem.c ****  * Adam's mem_malloc() plus solution for bug #17922
 474:./src/lwip/core/mem.c ****  * Allocate a block of memory with a minimum of 'size' bytes.
 475:./src/lwip/core/mem.c ****  *
 476:./src/lwip/core/mem.c ****  * @param size is the minimum size of the requested block in bytes.
 477:./src/lwip/core/mem.c ****  * @return pointer to allocated memory or NULL if no free memory was found.
 478:./src/lwip/core/mem.c ****  *
 479:./src/lwip/core/mem.c ****  * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 480:./src/lwip/core/mem.c ****  */
 481:./src/lwip/core/mem.c **** void *
 482:./src/lwip/core/mem.c **** mem_malloc(mem_size_t size)
 483:./src/lwip/core/mem.c **** {
 688              		.loc 1 483 0
 689              		@ Function supports interworking.
 690              		@ args = 0, pretend = 0, frame = 24
 691              		@ frame_needed = 1, uses_anonymous_args = 0
 692 0744 00482DE9 		stmfd	sp!, {fp, lr}
 693              	.LCFI12:
 694 0748 04B08DE2 		add	fp, sp, #4
 695              	.LCFI13:
 696 074c 18D04DE2 		sub	sp, sp, #24
 697              	.LCFI14:
 698 0750 0030A0E1 		mov	r3, r0
 699 0754 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 484:./src/lwip/core/mem.c ****   mem_size_t ptr, ptr2;
 485:./src/lwip/core/mem.c ****   struct mem *mem, *mem2;
 486:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 487:./src/lwip/core/mem.c ****   u8_t local_mem_free_count = 0;
 488:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 489:./src/lwip/core/mem.c ****   LWIP_MEM_ALLOC_DECL_PROTECT();
 490:./src/lwip/core/mem.c **** 
 491:./src/lwip/core/mem.c ****   if (size == 0) {
 700              		.loc 1 491 0
 701 0758 B6315BE1 		ldrh	r3, [fp, #-22]
 702 075c 000053E3 		cmp	r3, #0
 703 0760 0100001A 		bne	.L43
 492:./src/lwip/core/mem.c ****     return NULL;
 704              		.loc 1 492 0
 705 0764 0030A0E3 		mov	r3, #0
 706 0768 D60000EA 		b	.L44
 707              	.L43:
 493:./src/lwip/core/mem.c ****   }
 494:./src/lwip/core/mem.c **** 
 495:./src/lwip/core/mem.c ****   /* Expand the size of the allocated memory region so that we can
 496:./src/lwip/core/mem.c ****      adjust for alignment. */
 497:./src/lwip/core/mem.c ****   size = LWIP_MEM_ALIGN_SIZE(size);
 498:./src/lwip/core/mem.c **** 
 499:./src/lwip/core/mem.c ****   if(size < MIN_SIZE_ALIGNED) {
 708              		.loc 1 499 0
 709 076c B6315BE1 		ldrh	r3, [fp, #-22]
 710 0770 0B0053E3 		cmp	r3, #11
 711 0774 0100008A 		bhi	.L45
 500:./src/lwip/core/mem.c ****     /* every data block must be at least MIN_SIZE_ALIGNED long */
 501:./src/lwip/core/mem.c ****     size = MIN_SIZE_ALIGNED;
 712              		.loc 1 501 0
 713 0778 0C30A0E3 		mov	r3, #12
 714 077c B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 715              	.L45:
 502:./src/lwip/core/mem.c ****   }
 503:./src/lwip/core/mem.c **** 
 504:./src/lwip/core/mem.c ****   if (size > MEM_SIZE_ALIGNED) {
 716              		.loc 1 504 0
 717 0780 B6315BE1 		ldrh	r3, [fp, #-22]
 718 0784 190D53E3 		cmp	r3, #1600
 719 0788 0100009A 		bls	.L46
 505:./src/lwip/core/mem.c ****     return NULL;
 720              		.loc 1 505 0
 721 078c 0030A0E3 		mov	r3, #0
 722 0790 CC0000EA 		b	.L44
 723              	.L46:
 506:./src/lwip/core/mem.c ****   }
 507:./src/lwip/core/mem.c **** 
 508:./src/lwip/core/mem.c ****   /* protect the heap from concurrent access */
 509:./src/lwip/core/mem.c ****   sys_arch_sem_wait(mem_sem, 0);
 724              		.loc 1 509 0
 725 0794 3C339FE5 		ldr	r3, .L59
 726 0798 003093E5 		ldr	r3, [r3, #0]
 727 079c 0300A0E1 		mov	r0, r3
 728 07a0 0010A0E3 		mov	r1, #0
 729 07a4 FEFFFFEB 		bl	sys_arch_sem_wait
 510:./src/lwip/core/mem.c ****   LWIP_MEM_ALLOC_PROTECT();
 511:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 512:./src/lwip/core/mem.c ****   /* run as long as a mem_free disturbed mem_malloc */
 513:./src/lwip/core/mem.c ****   do {
 514:./src/lwip/core/mem.c ****     local_mem_free_count = 0;
 515:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 516:./src/lwip/core/mem.c **** 
 517:./src/lwip/core/mem.c ****     /* Scan through the heap searching for a free block that is big enough,
 518:./src/lwip/core/mem.c ****      * beginning with the lowest free block.
 519:./src/lwip/core/mem.c ****      */
 520:./src/lwip/core/mem.c ****     for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
 730              		.loc 1 520 0
 731 07a8 2C339FE5 		ldr	r3, .L59+4
 732 07ac 003093E5 		ldr	r3, [r3, #0]
 733 07b0 0338A0E1 		mov	r3, r3, asl #16
 734 07b4 2328A0E1 		mov	r2, r3, lsr #16
 735 07b8 20339FE5 		ldr	r3, .L59+8
 736 07bc 003093E5 		ldr	r3, [r3, #0]
 737 07c0 0338A0E1 		mov	r3, r3, asl #16
 738 07c4 2338A0E1 		mov	r3, r3, lsr #16
 739 07c8 023063E0 		rsb	r3, r3, r2
 740 07cc B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 741 07d0 AB0000EA 		b	.L47
 742              	.L57:
 521:./src/lwip/core/mem.c ****          ptr = ((struct mem *)&ram[ptr])->next) {
 522:./src/lwip/core/mem.c ****       mem = (struct mem *)&ram[ptr];
 743              		.loc 1 522 0
 744 07d4 04339FE5 		ldr	r3, .L59+8
 745 07d8 003093E5 		ldr	r3, [r3, #0]
 746 07dc 0320A0E1 		mov	r2, r3
 747 07e0 B0315BE1 		ldrh	r3, [fp, #-16]
 748 07e4 033082E0 		add	r3, r2, r3
 749 07e8 0C300BE5 		str	r3, [fp, #-12]
 523:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 524:./src/lwip/core/mem.c ****       mem_free_count = 0;
 525:./src/lwip/core/mem.c ****       LWIP_MEM_ALLOC_UNPROTECT();
 526:./src/lwip/core/mem.c ****       /* allow mem_free to run */
 527:./src/lwip/core/mem.c ****       LWIP_MEM_ALLOC_PROTECT();
 528:./src/lwip/core/mem.c ****       if (mem_free_count != 0) {
 529:./src/lwip/core/mem.c ****         local_mem_free_count = mem_free_count;
 530:./src/lwip/core/mem.c ****       }
 531:./src/lwip/core/mem.c ****       mem_free_count = 0;
 532:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 533:./src/lwip/core/mem.c **** 
 534:./src/lwip/core/mem.c ****       if ((!mem->used) &&
 750              		.loc 1 534 0
 751 07ec 0C301BE5 		ldr	r3, [fp, #-12]
 752 07f0 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 753 07f4 000053E3 		cmp	r3, #0
 754 07f8 9A00001A 		bne	.L48
 535:./src/lwip/core/mem.c ****           (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 755              		.loc 1 535 0
 756 07fc 0C301BE5 		ldr	r3, [fp, #-12]
 757 0800 B030D3E1 		ldrh	r3, [r3, #0]
 758 0804 0320A0E1 		mov	r2, r3
 759 0808 B0315BE1 		ldrh	r3, [fp, #-16]
 760 080c 023063E0 		rsb	r3, r3, r2
 761 0810 062043E2 		sub	r2, r3, #6
 762 0814 B6315BE1 		ldrh	r3, [fp, #-22]
 763              		.loc 1 534 0
 764 0818 030052E1 		cmp	r2, r3
 765 081c 9100003A 		bcc	.L48
 536:./src/lwip/core/mem.c ****         /* mem is not used and at least perfect fit is possible:
 537:./src/lwip/core/mem.c ****          * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
 538:./src/lwip/core/mem.c **** 
 539:./src/lwip/core/mem.c ****         if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 766              		.loc 1 539 0
 767 0820 0C301BE5 		ldr	r3, [fp, #-12]
 768 0824 B030D3E1 		ldrh	r3, [r3, #0]
 769 0828 0320A0E1 		mov	r2, r3
 770 082c B0315BE1 		ldrh	r3, [fp, #-16]
 771 0830 023063E0 		rsb	r3, r3, r2
 772 0834 062043E2 		sub	r2, r3, #6
 773 0838 B6315BE1 		ldrh	r3, [fp, #-22]
 774 083c 123083E2 		add	r3, r3, #18
 775 0840 030052E1 		cmp	r2, r3
 776 0844 3E00003A 		bcc	.L49
 540:./src/lwip/core/mem.c ****           /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containin
 541:./src/lwip/core/mem.c ****            * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
 542:./src/lwip/core/mem.c ****            * -> split large block, create empty remainder,
 543:./src/lwip/core/mem.c ****            * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
 544:./src/lwip/core/mem.c ****            * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
 545:./src/lwip/core/mem.c ****            * struct mem would fit in but no data between mem2 and mem2->next
 546:./src/lwip/core/mem.c ****            * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
 547:./src/lwip/core/mem.c ****            *       region that couldn't hold data, but when mem->next gets freed,
 548:./src/lwip/core/mem.c ****            *       the 2 regions would be combined, resulting in more free memory
 549:./src/lwip/core/mem.c ****            */
 550:./src/lwip/core/mem.c ****           ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 777              		.loc 1 550 0
 778 0848 B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 779 084c B6315BE1 		ldrh	r3, [fp, #-22]	@ movhi
 780 0850 033082E0 		add	r3, r2, r3
 781 0854 0338A0E1 		mov	r3, r3, asl #16
 782 0858 2338A0E1 		mov	r3, r3, lsr #16
 783 085c 063083E2 		add	r3, r3, #6
 784 0860 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 551:./src/lwip/core/mem.c ****           /* create mem2 struct */
 552:./src/lwip/core/mem.c ****           mem2 = (struct mem *)&ram[ptr2];
 785              		.loc 1 552 0
 786 0864 74329FE5 		ldr	r3, .L59+8
 787 0868 003093E5 		ldr	r3, [r3, #0]
 788 086c 0320A0E1 		mov	r2, r3
 789 0870 BE305BE1 		ldrh	r3, [fp, #-14]
 790 0874 033082E0 		add	r3, r2, r3
 791 0878 08300BE5 		str	r3, [fp, #-8]
 553:./src/lwip/core/mem.c ****           mem2->used = 0;
 792              		.loc 1 553 0
 793 087c 08301BE5 		ldr	r3, [fp, #-8]
 794 0880 0020A0E3 		mov	r2, #0
 795 0884 0420C3E5 		strb	r2, [r3, #4]
 554:./src/lwip/core/mem.c ****           mem2->next = mem->next;
 796              		.loc 1 554 0
 797 0888 0C301BE5 		ldr	r3, [fp, #-12]
 798 088c B020D3E1 		ldrh	r2, [r3, #0]
 799 0890 08301BE5 		ldr	r3, [fp, #-8]
 800 0894 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 555:./src/lwip/core/mem.c ****           mem2->prev = ptr;
 801              		.loc 1 555 0
 802 0898 08301BE5 		ldr	r3, [fp, #-8]
 803 089c B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 804 08a0 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 556:./src/lwip/core/mem.c ****           /* and insert it between mem and mem->next */
 557:./src/lwip/core/mem.c ****           mem->next = ptr2;
 805              		.loc 1 557 0
 806 08a4 0C301BE5 		ldr	r3, [fp, #-12]
 807 08a8 BE205BE1 		ldrh	r2, [fp, #-14]	@ movhi
 808 08ac B020C3E1 		strh	r2, [r3, #0]	@ movhi
 558:./src/lwip/core/mem.c ****           mem->used = 1;
 809              		.loc 1 558 0
 810 08b0 0C301BE5 		ldr	r3, [fp, #-12]
 811 08b4 0120A0E3 		mov	r2, #1
 812 08b8 0420C3E5 		strb	r2, [r3, #4]
 559:./src/lwip/core/mem.c **** 
 560:./src/lwip/core/mem.c ****           if (mem2->next != MEM_SIZE_ALIGNED) {
 813              		.loc 1 560 0
 814 08bc 08301BE5 		ldr	r3, [fp, #-8]
 815 08c0 B030D3E1 		ldrh	r3, [r3, #0]
 816 08c4 190D53E3 		cmp	r3, #1600
 817 08c8 0700000A 		beq	.L50
 561:./src/lwip/core/mem.c ****             ((struct mem *)&ram[mem2->next])->prev = ptr2;
 818              		.loc 1 561 0
 819 08cc 0C329FE5 		ldr	r3, .L59+8
 820 08d0 003093E5 		ldr	r3, [r3, #0]
 821 08d4 0320A0E1 		mov	r2, r3
 822 08d8 08301BE5 		ldr	r3, [fp, #-8]
 823 08dc B030D3E1 		ldrh	r3, [r3, #0]
 824 08e0 033082E0 		add	r3, r2, r3
 825 08e4 BE205BE1 		ldrh	r2, [fp, #-14]	@ movhi
 826 08e8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 827              	.L50:
 562:./src/lwip/core/mem.c ****           }
 563:./src/lwip/core/mem.c ****           MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 828              		.loc 1 563 0
 829 08ec F0319FE5 		ldr	r3, .L59+12
 830 08f0 BA2AD3E1 		ldrh	r2, [r3, #170]
 831 08f4 B6315BE1 		ldrh	r3, [fp, #-22]	@ movhi
 832 08f8 033082E0 		add	r3, r2, r3
 833 08fc 0338A0E1 		mov	r3, r3, asl #16
 834 0900 2338A0E1 		mov	r3, r3, lsr #16
 835 0904 063083E2 		add	r3, r3, #6
 836 0908 0338A0E1 		mov	r3, r3, asl #16
 837 090c 2328A0E1 		mov	r2, r3, lsr #16
 838 0910 CC319FE5 		ldr	r3, .L59+12
 839 0914 BA2AC3E1 		strh	r2, [r3, #170]	@ movhi
 840 0918 C4319FE5 		ldr	r3, .L59+12
 841 091c BC2AD3E1 		ldrh	r2, [r3, #172]
 842 0920 BC319FE5 		ldr	r3, .L59+12
 843 0924 BA3AD3E1 		ldrh	r3, [r3, #170]
 844 0928 030052E1 		cmp	r2, r3
 845 092c 2700002A 		bcs	.L52
 846 0930 AC319FE5 		ldr	r3, .L59+12
 847 0934 BA2AD3E1 		ldrh	r2, [r3, #170]
 848 0938 A4319FE5 		ldr	r3, .L59+12
 849 093c BC2AC3E1 		strh	r2, [r3, #172]	@ movhi
 850 0940 220000EA 		b	.L52
 851              	.L49:
 564:./src/lwip/core/mem.c ****         } else {
 565:./src/lwip/core/mem.c ****           /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
 566:./src/lwip/core/mem.c ****            * be used at this point: if not we have 2 unused structs in a row, plug_holes should hav
 567:./src/lwip/core/mem.c ****            * take care of this).
 568:./src/lwip/core/mem.c ****            * -> near fit or excact fit: do not split, no mem2 creation
 569:./src/lwip/core/mem.c ****            * also can't move mem->next directly behind mem, since mem->next
 570:./src/lwip/core/mem.c ****            * will always be used at this point!
 571:./src/lwip/core/mem.c ****            */
 572:./src/lwip/core/mem.c ****           mem->used = 1;
 852              		.loc 1 572 0
 853 0944 0C301BE5 		ldr	r3, [fp, #-12]
 854 0948 0120A0E3 		mov	r2, #1
 855 094c 0420C3E5 		strb	r2, [r3, #4]
 573:./src/lwip/core/mem.c ****           MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
 856              		.loc 1 573 0
 857 0950 8C319FE5 		ldr	r3, .L59+12
 858 0954 BA2AD3E1 		ldrh	r2, [r3, #170]
 859 0958 0C301BE5 		ldr	r3, [fp, #-12]
 860 095c B010D3E1 		ldrh	r1, [r3, #0]
 861 0960 78319FE5 		ldr	r3, .L59+8
 862 0964 003093E5 		ldr	r3, [r3, #0]
 863 0968 0338A0E1 		mov	r3, r3, asl #16
 864 096c 2308A0E1 		mov	r0, r3, lsr #16
 865 0970 0C301BE5 		ldr	r3, [fp, #-12]
 866 0974 0338A0E1 		mov	r3, r3, asl #16
 867 0978 2338A0E1 		mov	r3, r3, lsr #16
 868 097c 003063E0 		rsb	r3, r3, r0
 869 0980 0338A0E1 		mov	r3, r3, asl #16
 870 0984 2338A0E1 		mov	r3, r3, lsr #16
 871 0988 033081E0 		add	r3, r1, r3
 872 098c 0338A0E1 		mov	r3, r3, asl #16
 873 0990 2338A0E1 		mov	r3, r3, lsr #16
 874 0994 033082E0 		add	r3, r2, r3
 875 0998 0338A0E1 		mov	r3, r3, asl #16
 876 099c 2328A0E1 		mov	r2, r3, lsr #16
 877 09a0 3C319FE5 		ldr	r3, .L59+12
 878 09a4 BA2AC3E1 		strh	r2, [r3, #170]	@ movhi
 879 09a8 34319FE5 		ldr	r3, .L59+12
 880 09ac BC2AD3E1 		ldrh	r2, [r3, #172]
 881 09b0 2C319FE5 		ldr	r3, .L59+12
 882 09b4 BA3AD3E1 		ldrh	r3, [r3, #170]
 883 09b8 030052E1 		cmp	r2, r3
 884 09bc 0300002A 		bcs	.L52
 885 09c0 1C319FE5 		ldr	r3, .L59+12
 886 09c4 BA2AD3E1 		ldrh	r2, [r3, #170]
 887 09c8 14319FE5 		ldr	r3, .L59+12
 888 09cc BC2AC3E1 		strh	r2, [r3, #172]	@ movhi
 889              	.L52:
 574:./src/lwip/core/mem.c ****         }
 575:./src/lwip/core/mem.c **** 
 576:./src/lwip/core/mem.c ****         if (mem == lfree) {
 890              		.loc 1 576 0
 891 09d0 04319FE5 		ldr	r3, .L59+4
 892 09d4 003093E5 		ldr	r3, [r3, #0]
 893 09d8 0C201BE5 		ldr	r2, [fp, #-12]
 894 09dc 030052E1 		cmp	r2, r3
 895 09e0 1900001A 		bne	.L53
 577:./src/lwip/core/mem.c ****           /* Find next free block after mem and update lowest free pointer */
 578:./src/lwip/core/mem.c ****           while (lfree->used && lfree != ram_end) {
 896              		.loc 1 578 0
 897 09e4 080000EA 		b	.L54
 898              	.L56:
 579:./src/lwip/core/mem.c ****             LWIP_MEM_ALLOC_UNPROTECT();
 580:./src/lwip/core/mem.c ****             /* prevent high interrupt latency... */
 581:./src/lwip/core/mem.c ****             LWIP_MEM_ALLOC_PROTECT();
 582:./src/lwip/core/mem.c ****             lfree = (struct mem *)&ram[lfree->next];
 899              		.loc 1 582 0
 900 09e8 F0309FE5 		ldr	r3, .L59+8
 901 09ec 003093E5 		ldr	r3, [r3, #0]
 902 09f0 0320A0E1 		mov	r2, r3
 903 09f4 E0309FE5 		ldr	r3, .L59+4
 904 09f8 003093E5 		ldr	r3, [r3, #0]
 905 09fc B030D3E1 		ldrh	r3, [r3, #0]
 906 0a00 032082E0 		add	r2, r2, r3
 907 0a04 D0309FE5 		ldr	r3, .L59+4
 908 0a08 002083E5 		str	r2, [r3, #0]
 909              	.L54:
 910              		.loc 1 578 0
 911 0a0c C8309FE5 		ldr	r3, .L59+4
 912 0a10 003093E5 		ldr	r3, [r3, #0]
 913 0a14 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 914 0a18 000053E3 		cmp	r3, #0
 915 0a1c 0500000A 		beq	.L55
 916 0a20 B4309FE5 		ldr	r3, .L59+4
 917 0a24 002093E5 		ldr	r2, [r3, #0]
 918 0a28 B8309FE5 		ldr	r3, .L59+16
 919 0a2c 003093E5 		ldr	r3, [r3, #0]
 920 0a30 030052E1 		cmp	r2, r3
 921 0a34 EBFFFF1A 		bne	.L56
 922              	.L55:
 583:./src/lwip/core/mem.c ****           }
 584:./src/lwip/core/mem.c ****           LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 923              		.loc 1 584 0
 924 0a38 9C309FE5 		ldr	r3, .L59+4
 925 0a3c 002093E5 		ldr	r2, [r3, #0]
 926 0a40 A0309FE5 		ldr	r3, .L59+16
 927 0a44 003093E5 		ldr	r3, [r3, #0]
 928 0a48 030052E1 		cmp	r2, r3
 929              	.L53:
 585:./src/lwip/core/mem.c ****         }
 586:./src/lwip/core/mem.c ****         LWIP_MEM_ALLOC_UNPROTECT();
 587:./src/lwip/core/mem.c ****         sys_sem_signal(mem_sem);
 930              		.loc 1 587 0
 931 0a4c 84309FE5 		ldr	r3, .L59
 932 0a50 003093E5 		ldr	r3, [r3, #0]
 933 0a54 0300A0E1 		mov	r0, r3
 934 0a58 FEFFFFEB 		bl	sys_sem_signal
 588:./src/lwip/core/mem.c ****         LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 589:./src/lwip/core/mem.c ****          (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
 590:./src/lwip/core/mem.c ****         LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 591:./src/lwip/core/mem.c ****          ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
 592:./src/lwip/core/mem.c ****         LWIP_ASSERT("mem_malloc: sanity check alignment",
 593:./src/lwip/core/mem.c ****           (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
 594:./src/lwip/core/mem.c **** 
 595:./src/lwip/core/mem.c ****         return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 935              		.loc 1 595 0
 936 0a5c 0C301BE5 		ldr	r3, [fp, #-12]
 937 0a60 063083E2 		add	r3, r3, #6
 938 0a64 170000EA 		b	.L44
 939              	.L48:
 940              		.loc 1 521 0
 941 0a68 70309FE5 		ldr	r3, .L59+8
 942 0a6c 003093E5 		ldr	r3, [r3, #0]
 943 0a70 0320A0E1 		mov	r2, r3
 944 0a74 B0315BE1 		ldrh	r3, [fp, #-16]
 945 0a78 033082E0 		add	r3, r2, r3
 946 0a7c B030D3E1 		ldrh	r3, [r3, #0]	@ movhi
 947 0a80 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 948              	.L47:
 949              		.loc 1 520 0
 950 0a84 B0215BE1 		ldrh	r2, [fp, #-16]
 951 0a88 B6315BE1 		ldrh	r3, [fp, #-22]
 952 0a8c 193D63E2 		rsb	r3, r3, #1600
 953 0a90 030052E1 		cmp	r2, r3
 954 0a94 4EFFFFBA 		blt	.L57
 596:./src/lwip/core/mem.c ****       }
 597:./src/lwip/core/mem.c ****     }
 598:./src/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 599:./src/lwip/core/mem.c ****     /* if we got interrupted by a mem_free, try again */
 600:./src/lwip/core/mem.c ****   } while(local_mem_free_count != 0);
 601:./src/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 602:./src/lwip/core/mem.c ****   LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n
 603:./src/lwip/core/mem.c ****   MEM_STATS_INC(err);
 955              		.loc 1 603 0
 956 0a98 44309FE5 		ldr	r3, .L59+12
 957 0a9c BE3AD3E1 		ldrh	r3, [r3, #174]
 958 0aa0 013083E2 		add	r3, r3, #1
 959 0aa4 0338A0E1 		mov	r3, r3, asl #16
 960 0aa8 2328A0E1 		mov	r2, r3, lsr #16
 961 0aac 30309FE5 		ldr	r3, .L59+12
 962 0ab0 BE2AC3E1 		strh	r2, [r3, #174]	@ movhi
 604:./src/lwip/core/mem.c ****   LWIP_MEM_ALLOC_UNPROTECT();
 605:./src/lwip/core/mem.c ****   sys_sem_signal(mem_sem);
 963              		.loc 1 605 0
 964 0ab4 1C309FE5 		ldr	r3, .L59
 965 0ab8 003093E5 		ldr	r3, [r3, #0]
 966 0abc 0300A0E1 		mov	r0, r3
 967 0ac0 FEFFFFEB 		bl	sys_sem_signal
 606:./src/lwip/core/mem.c ****   return NULL;
 968              		.loc 1 606 0
 969 0ac4 0030A0E3 		mov	r3, #0
 970              	.L44:
 607:./src/lwip/core/mem.c **** }
 971              		.loc 1 607 0
 972 0ac8 0300A0E1 		mov	r0, r3
 973 0acc 04D04BE2 		sub	sp, fp, #4
 974 0ad0 0048BDE8 		ldmfd	sp!, {fp, lr}
 975 0ad4 1EFF2FE1 		bx	lr
 976              	.L60:
 977              		.align	2
 978              	.L59:
 979 0ad8 5C060000 		.word	mem_sem
 980 0adc 58060000 		.word	lfree
 981 0ae0 50060000 		.word	ram
 982 0ae4 00000000 		.word	lwip_stats
 983 0ae8 54060000 		.word	ram_end
 984              	.LFE4:
 986              		.align	2
 987              		.global	mem_calloc
 989              	mem_calloc:
 990              	.LFB5:
 608:./src/lwip/core/mem.c **** 
 609:./src/lwip/core/mem.c **** #endif /* MEM_USE_POOLS */
 610:./src/lwip/core/mem.c **** /**
 611:./src/lwip/core/mem.c ****  * Contiguously allocates enough space for count objects that are size bytes
 612:./src/lwip/core/mem.c ****  * of memory each and returns a pointer to the allocated memory.
 613:./src/lwip/core/mem.c ****  *
 614:./src/lwip/core/mem.c ****  * The allocated memory is filled with bytes of value zero.
 615:./src/lwip/core/mem.c ****  *
 616:./src/lwip/core/mem.c ****  * @param count number of objects to allocate
 617:./src/lwip/core/mem.c ****  * @param size size of the objects to allocate
 618:./src/lwip/core/mem.c ****  * @return pointer to allocated memory / NULL pointer if there is an error
 619:./src/lwip/core/mem.c ****  */
 620:./src/lwip/core/mem.c **** void *mem_calloc(mem_size_t count, mem_size_t size)
 621:./src/lwip/core/mem.c **** {
 991              		.loc 1 621 0
 992              		@ Function supports interworking.
 993              		@ args = 0, pretend = 0, frame = 16
 994              		@ frame_needed = 1, uses_anonymous_args = 0
 995 0aec 00482DE9 		stmfd	sp!, {fp, lr}
 996              	.LCFI15:
 997 0af0 04B08DE2 		add	fp, sp, #4
 998              	.LCFI16:
 999 0af4 10D04DE2 		sub	sp, sp, #16
 1000              	.LCFI17:
 1001 0af8 0020A0E1 		mov	r2, r0
 1002 0afc 0130A0E1 		mov	r3, r1
 1003 0b00 BE204BE1 		strh	r2, [fp, #-14]	@ movhi
 1004 0b04 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 622:./src/lwip/core/mem.c ****   void *p;
 623:./src/lwip/core/mem.c **** 
 624:./src/lwip/core/mem.c ****   /* allocate 'count' objects of size 'size' */
 625:./src/lwip/core/mem.c ****   p = mem_malloc(count * size);
 1005              		.loc 1 625 0
 1006 0b08 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 1007 0b0c B0215BE1 		ldrh	r2, [fp, #-16]	@ movhi
 1008 0b10 920303E0 		mul	r3, r2, r3
 1009 0b14 0338A0E1 		mov	r3, r3, asl #16
 1010 0b18 2338A0E1 		mov	r3, r3, lsr #16
 1011 0b1c 0300A0E1 		mov	r0, r3
 1012 0b20 FEFFFFEB 		bl	mem_malloc
 1013 0b24 0030A0E1 		mov	r3, r0
 1014 0b28 08300BE5 		str	r3, [fp, #-8]
 626:./src/lwip/core/mem.c ****   if (p) {
 1015              		.loc 1 626 0
 1016 0b2c 08301BE5 		ldr	r3, [fp, #-8]
 1017 0b30 000053E3 		cmp	r3, #0
 1018 0b34 0600000A 		beq	.L62
 627:./src/lwip/core/mem.c ****     /* zero the memory */
 628:./src/lwip/core/mem.c ****     memset(p, 0, count * size);
 1019              		.loc 1 628 0
 1020 0b38 BE305BE1 		ldrh	r3, [fp, #-14]
 1021 0b3c B0215BE1 		ldrh	r2, [fp, #-16]
 1022 0b40 920303E0 		mul	r3, r2, r3
 1023 0b44 08001BE5 		ldr	r0, [fp, #-8]
 1024 0b48 0010A0E3 		mov	r1, #0
 1025 0b4c 0320A0E1 		mov	r2, r3
 1026 0b50 FEFFFFEB 		bl	memset
 1027              	.L62:
 629:./src/lwip/core/mem.c ****   }
 630:./src/lwip/core/mem.c ****   return p;
 1028              		.loc 1 630 0
 1029 0b54 08301BE5 		ldr	r3, [fp, #-8]
 631:./src/lwip/core/mem.c **** }
 1030              		.loc 1 631 0
 1031 0b58 0300A0E1 		mov	r0, r3
 1032 0b5c 04D04BE2 		sub	sp, fp, #4
 1033 0b60 0048BDE8 		ldmfd	sp!, {fp, lr}
 1034 0b64 1EFF2FE1 		bx	lr
 1035              	.LFE5:
 1187              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 mem.c
     /tmp/ccw6eyS8.s:21     .bss:00000000 $d
     /tmp/ccw6eyS8.s:22     .bss:00000000 ram_heap
     /tmp/ccw6eyS8.s:25     .bss:00000650 ram
     /tmp/ccw6eyS8.s:28     .bss:00000654 ram_end
     /tmp/ccw6eyS8.s:31     .bss:00000658 lfree
     /tmp/ccw6eyS8.s:34     .bss:0000065c mem_sem
     /tmp/ccw6eyS8.s:37     .text:00000000 $a
     /tmp/ccw6eyS8.s:39     .text:00000000 plug_holes
     /tmp/ccw6eyS8.s:170    .text:00000190 $d
     /tmp/ccw6eyS8.s:175    .text:0000019c $a
     /tmp/ccw6eyS8.s:178    .text:0000019c mem_init
     /tmp/ccw6eyS8.s:254    .text:00000268 $d
     /tmp/ccw6eyS8.s:262    .text:00000280 $a
     /tmp/ccw6eyS8.s:265    .text:00000280 mem_free
     /tmp/ccw6eyS8.s:379    .text:000003c4 $d
     /tmp/ccw6eyS8.s:386    .text:000003d8 $a
     /tmp/ccw6eyS8.s:389    .text:000003d8 mem_realloc
     /tmp/ccw6eyS8.s:676    .text:00000730 $d
     /tmp/ccw6eyS8.s:683    .text:00000744 $a
     /tmp/ccw6eyS8.s:686    .text:00000744 mem_malloc
     /tmp/ccw6eyS8.s:979    .text:00000ad8 $d
     /tmp/ccw6eyS8.s:986    .text:00000aec $a
     /tmp/ccw6eyS8.s:989    .text:00000aec mem_calloc
     /tmp/ccw6eyS8.s:1050   .debug_frame:00000010 $d

UNDEFINED SYMBOLS
sys_sem_new
lwip_stats
sys_arch_sem_wait
sys_sem_signal
memset
