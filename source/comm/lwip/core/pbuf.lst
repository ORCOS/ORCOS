   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"pbuf.c"
  19              	.Ltext0:
  20              		.bss
  21              	pbuf_free_ooseq_queued:
  22 0000 00       		.space	1
  23              		.text
  24              		.align	2
  26              	pbuf_free_ooseq:
  27              	.LFB0:
  28              		.file 1 "./src/lwip/core/pbuf.c"
   1:./src/lwip/core/pbuf.c **** /**
   2:./src/lwip/core/pbuf.c ****  * @file
   3:./src/lwip/core/pbuf.c ****  * Packet buffer management
   4:./src/lwip/core/pbuf.c ****  *
   5:./src/lwip/core/pbuf.c ****  * Packets are built from the pbuf data structure. It supports dynamic
   6:./src/lwip/core/pbuf.c ****  * memory allocation for packet contents or can reference externally
   7:./src/lwip/core/pbuf.c ****  * managed packet contents both in RAM and ROM. Quick allocation for
   8:./src/lwip/core/pbuf.c ****  * incoming packets is provided through pools with fixed sized pbufs.
   9:./src/lwip/core/pbuf.c ****  *
  10:./src/lwip/core/pbuf.c ****  * A packet may span over multiple pbufs, chained as a singly linked
  11:./src/lwip/core/pbuf.c ****  * list. This is called a "pbuf chain".
  12:./src/lwip/core/pbuf.c ****  *
  13:./src/lwip/core/pbuf.c ****  * Multiple packets may be queued, also using this singly linked list.
  14:./src/lwip/core/pbuf.c ****  * This is called a "packet queue".
  15:./src/lwip/core/pbuf.c ****  * 
  16:./src/lwip/core/pbuf.c ****  * So, a packet queue consists of one or more pbuf chains, each of
  17:./src/lwip/core/pbuf.c ****  * which consist of one or more pbufs. CURRENTLY, PACKET QUEUES ARE
  18:./src/lwip/core/pbuf.c ****  * NOT SUPPORTED!!! Use helper structs to queue multiple packets.
  19:./src/lwip/core/pbuf.c ****  * 
  20:./src/lwip/core/pbuf.c ****  * The differences between a pbuf chain and a packet queue are very
  21:./src/lwip/core/pbuf.c ****  * precise but subtle. 
  22:./src/lwip/core/pbuf.c ****  *
  23:./src/lwip/core/pbuf.c ****  * The last pbuf of a packet has a ->tot_len field that equals the
  24:./src/lwip/core/pbuf.c ****  * ->len field. It can be found by traversing the list. If the last
  25:./src/lwip/core/pbuf.c ****  * pbuf of a packet has a ->next field other than NULL, more packets
  26:./src/lwip/core/pbuf.c ****  * are on the queue.
  27:./src/lwip/core/pbuf.c ****  *
  28:./src/lwip/core/pbuf.c ****  * Therefore, looping through a pbuf of a single packet, has an
  29:./src/lwip/core/pbuf.c ****  * loop end condition (tot_len == p->len), NOT (next == NULL).
  30:./src/lwip/core/pbuf.c ****  */
  31:./src/lwip/core/pbuf.c **** 
  32:./src/lwip/core/pbuf.c **** /*
  33:./src/lwip/core/pbuf.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  34:./src/lwip/core/pbuf.c ****  * All rights reserved.
  35:./src/lwip/core/pbuf.c ****  *
  36:./src/lwip/core/pbuf.c ****  * Redistribution and use in source and binary forms, with or without modification,
  37:./src/lwip/core/pbuf.c ****  * are permitted provided that the following conditions are met:
  38:./src/lwip/core/pbuf.c ****  *
  39:./src/lwip/core/pbuf.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  40:./src/lwip/core/pbuf.c ****  *    this list of conditions and the following disclaimer.
  41:./src/lwip/core/pbuf.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  42:./src/lwip/core/pbuf.c ****  *    this list of conditions and the following disclaimer in the documentation
  43:./src/lwip/core/pbuf.c ****  *    and/or other materials provided with the distribution.
  44:./src/lwip/core/pbuf.c ****  * 3. The name of the author may not be used to endorse or promote products
  45:./src/lwip/core/pbuf.c ****  *    derived from this software without specific prior written permission.
  46:./src/lwip/core/pbuf.c ****  *
  47:./src/lwip/core/pbuf.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  48:./src/lwip/core/pbuf.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  49:./src/lwip/core/pbuf.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  50:./src/lwip/core/pbuf.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  51:./src/lwip/core/pbuf.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  52:./src/lwip/core/pbuf.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  53:./src/lwip/core/pbuf.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  54:./src/lwip/core/pbuf.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  55:./src/lwip/core/pbuf.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  56:./src/lwip/core/pbuf.c ****  * OF SUCH DAMAGE.
  57:./src/lwip/core/pbuf.c ****  *
  58:./src/lwip/core/pbuf.c ****  * This file is part of the lwIP TCP/IP stack.
  59:./src/lwip/core/pbuf.c ****  *
  60:./src/lwip/core/pbuf.c ****  * Author: Adam Dunkels <adam@sics.se>
  61:./src/lwip/core/pbuf.c ****  *
  62:./src/lwip/core/pbuf.c ****  */
  63:./src/lwip/core/pbuf.c **** 
  64:./src/lwip/core/pbuf.c **** #include "lwip/opt.h"
  65:./src/lwip/core/pbuf.c **** 
  66:./src/lwip/core/pbuf.c **** #include "lwip/stats.h"
  67:./src/lwip/core/pbuf.c **** #include "lwip/def.h"
  68:./src/lwip/core/pbuf.c **** #include "lwip/mem.h"
  69:./src/lwip/core/pbuf.c **** #include "lwip/memp.h"
  70:./src/lwip/core/pbuf.c **** #include "lwip/pbuf.h"
  71:./src/lwip/core/pbuf.c **** #include "lwip/sys.h"
  72:./src/lwip/core/pbuf.c **** #include "arch/perf.h"
  73:./src/lwip/core/pbuf.c **** #if TCP_QUEUE_OOSEQ
  74:./src/lwip/core/pbuf.c **** #include "lwip/tcp.h"
  75:./src/lwip/core/pbuf.c **** #endif
  76:./src/lwip/core/pbuf.c **** 
  77:./src/lwip/core/pbuf.c **** #include <string.h>
  78:./src/lwip/core/pbuf.c **** 
  79:./src/lwip/core/pbuf.c **** #define SIZEOF_STRUCT_PBUF        LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf))
  80:./src/lwip/core/pbuf.c **** /* Since the pool is created in memp, PBUF_POOL_BUFSIZE will be automatically
  81:./src/lwip/core/pbuf.c ****    aligned there. Therefore, PBUF_POOL_BUFSIZE_ALIGNED can be used here. */
  82:./src/lwip/core/pbuf.c **** #define PBUF_POOL_BUFSIZE_ALIGNED LWIP_MEM_ALIGN_SIZE(PBUF_POOL_BUFSIZE)
  83:./src/lwip/core/pbuf.c **** 
  84:./src/lwip/core/pbuf.c **** #if !TCP_QUEUE_OOSEQ || NO_SYS
  85:./src/lwip/core/pbuf.c **** #define PBUF_POOL_IS_EMPTY()
  86:./src/lwip/core/pbuf.c **** #else /* !TCP_QUEUE_OOSEQ || NO_SYS */
  87:./src/lwip/core/pbuf.c **** /** Define this to 0 to prevent freeing ooseq pbufs when the PBUF_POOL is empty */
  88:./src/lwip/core/pbuf.c **** #ifndef PBUF_POOL_FREE_OOSEQ
  89:./src/lwip/core/pbuf.c **** #define PBUF_POOL_FREE_OOSEQ 1
  90:./src/lwip/core/pbuf.c **** #endif /* PBUF_POOL_FREE_OOSEQ */
  91:./src/lwip/core/pbuf.c **** 
  92:./src/lwip/core/pbuf.c **** #if PBUF_POOL_FREE_OOSEQ
  93:./src/lwip/core/pbuf.c **** #include "lwip/tcpip.h"
  94:./src/lwip/core/pbuf.c **** #define PBUF_POOL_IS_EMPTY() pbuf_pool_is_empty()
  95:./src/lwip/core/pbuf.c **** static u8_t pbuf_free_ooseq_queued;
  96:./src/lwip/core/pbuf.c **** /**
  97:./src/lwip/core/pbuf.c ****  * Attempt to reclaim some memory from queued out-of-sequence TCP segments
  98:./src/lwip/core/pbuf.c ****  * if we run out of pool pbufs. It's better to give priority to new packets
  99:./src/lwip/core/pbuf.c ****  * if we're running out.
 100:./src/lwip/core/pbuf.c ****  *
 101:./src/lwip/core/pbuf.c ****  * This must be done in the correct thread context therefore this function
 102:./src/lwip/core/pbuf.c ****  * can only be used with NO_SYS=0 and through tcpip_callback.
 103:./src/lwip/core/pbuf.c ****  */
 104:./src/lwip/core/pbuf.c **** static void
 105:./src/lwip/core/pbuf.c **** pbuf_free_ooseq(void* arg)
 106:./src/lwip/core/pbuf.c **** {
  29              		.loc 1 106 0
  30              		@ Function supports interworking.
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 00482DE9 		stmfd	sp!, {fp, lr}
  34              	.LCFI0:
  35 0004 04B08DE2 		add	fp, sp, #4
  36              	.LCFI1:
  37 0008 10D04DE2 		sub	sp, sp, #16
  38              	.LCFI2:
  39 000c 10000BE5 		str	r0, [fp, #-16]
 107:./src/lwip/core/pbuf.c ****   struct tcp_pcb* pcb;
 108:./src/lwip/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 109:./src/lwip/core/pbuf.c ****   LWIP_UNUSED_ARG(arg);
 110:./src/lwip/core/pbuf.c **** 
 111:./src/lwip/core/pbuf.c ****   SYS_ARCH_PROTECT(old_level);
 112:./src/lwip/core/pbuf.c ****   pbuf_free_ooseq_queued = 0;
  40              		.loc 1 112 0
  41 0010 68309FE5 		ldr	r3, .L7
  42 0014 0020A0E3 		mov	r2, #0
  43 0018 0020C3E5 		strb	r2, [r3, #0]
 113:./src/lwip/core/pbuf.c ****   SYS_ARCH_UNPROTECT(old_level);
 114:./src/lwip/core/pbuf.c **** 
 115:./src/lwip/core/pbuf.c ****   for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
  44              		.loc 1 115 0
  45 001c 60309FE5 		ldr	r3, .L7+4
  46 0020 003093E5 		ldr	r3, [r3, #0]
  47 0024 08300BE5 		str	r3, [fp, #-8]
  48 0028 0E0000EA 		b	.L2
  49              	.L5:
 116:./src/lwip/core/pbuf.c ****     if (NULL != pcb->ooseq) {
  50              		.loc 1 116 0
  51 002c 08301BE5 		ldr	r3, [fp, #-8]
  52 0030 783093E5 		ldr	r3, [r3, #120]
  53 0034 000053E3 		cmp	r3, #0
  54 0038 0700000A 		beq	.L3
 117:./src/lwip/core/pbuf.c ****       /** Free the ooseq pbufs of one PCB only */
 118:./src/lwip/core/pbuf.c ****       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n")
 119:./src/lwip/core/pbuf.c ****       tcp_segs_free(pcb->ooseq);
  55              		.loc 1 119 0
  56 003c 08301BE5 		ldr	r3, [fp, #-8]
  57 0040 783093E5 		ldr	r3, [r3, #120]
  58 0044 0300A0E1 		mov	r0, r3
  59 0048 FEFFFFEB 		bl	tcp_segs_free
 120:./src/lwip/core/pbuf.c ****       pcb->ooseq = NULL;
  60              		.loc 1 120 0
  61 004c 08301BE5 		ldr	r3, [fp, #-8]
  62 0050 0020A0E3 		mov	r2, #0
  63 0054 782083E5 		str	r2, [r3, #120]
 121:./src/lwip/core/pbuf.c ****       return;
  64              		.loc 1 121 0
  65 0058 050000EA 		b	.L6
  66              	.L3:
  67              		.loc 1 115 0
  68 005c 08301BE5 		ldr	r3, [fp, #-8]
  69 0060 0C3093E5 		ldr	r3, [r3, #12]
  70 0064 08300BE5 		str	r3, [fp, #-8]
  71              	.L2:
  72 0068 08301BE5 		ldr	r3, [fp, #-8]
  73 006c 000053E3 		cmp	r3, #0
  74 0070 EDFFFF1A 		bne	.L5
  75              	.L6:
 122:./src/lwip/core/pbuf.c ****     }
 123:./src/lwip/core/pbuf.c ****   }
 124:./src/lwip/core/pbuf.c **** }
  76              		.loc 1 124 0
  77 0074 04D04BE2 		sub	sp, fp, #4
  78 0078 0048BDE8 		ldmfd	sp!, {fp, lr}
  79 007c 1EFF2FE1 		bx	lr
  80              	.L8:
  81              		.align	2
  82              	.L7:
  83 0080 00000000 		.word	pbuf_free_ooseq_queued
  84 0084 00000000 		.word	tcp_active_pcbs
  85              	.LFE0:
  87              		.align	2
  89              	pbuf_pool_is_empty:
  90              	.LFB1:
 125:./src/lwip/core/pbuf.c **** 
 126:./src/lwip/core/pbuf.c **** /** Queue a call to pbuf_free_ooseq if not already queued. */
 127:./src/lwip/core/pbuf.c **** static void
 128:./src/lwip/core/pbuf.c **** pbuf_pool_is_empty(void)
 129:./src/lwip/core/pbuf.c **** {
  91              		.loc 1 129 0
  92              		@ Function supports interworking.
  93              		@ args = 0, pretend = 0, frame = 8
  94              		@ frame_needed = 1, uses_anonymous_args = 0
  95 0088 00482DE9 		stmfd	sp!, {fp, lr}
  96              	.LCFI3:
  97 008c 04B08DE2 		add	fp, sp, #4
  98              	.LCFI4:
  99 0090 08D04DE2 		sub	sp, sp, #8
 100              	.LCFI5:
 130:./src/lwip/core/pbuf.c ****   u8_t queued;
 131:./src/lwip/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 132:./src/lwip/core/pbuf.c **** 
 133:./src/lwip/core/pbuf.c ****   SYS_ARCH_PROTECT(old_level);
 134:./src/lwip/core/pbuf.c ****   queued = pbuf_free_ooseq_queued;
 101              		.loc 1 134 0
 102 0094 54309FE5 		ldr	r3, .L12
 103 0098 0030D3E5 		ldrb	r3, [r3, #0]
 104 009c 05304BE5 		strb	r3, [fp, #-5]
 135:./src/lwip/core/pbuf.c ****   pbuf_free_ooseq_queued = 1;
 105              		.loc 1 135 0
 106 00a0 48309FE5 		ldr	r3, .L12
 107 00a4 0120A0E3 		mov	r2, #1
 108 00a8 0020C3E5 		strb	r2, [r3, #0]
 136:./src/lwip/core/pbuf.c ****   SYS_ARCH_UNPROTECT(old_level);
 137:./src/lwip/core/pbuf.c **** 
 138:./src/lwip/core/pbuf.c ****   if(!queued) {
 109              		.loc 1 138 0
 110 00ac 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 111 00b0 000053E3 		cmp	r3, #0
 112 00b4 0A00001A 		bne	.L11
 139:./src/lwip/core/pbuf.c ****     /* queue a call to pbuf_free_ooseq if not already queued */
 140:./src/lwip/core/pbuf.c ****     if(tcpip_callback_with_block(pbuf_free_ooseq, NULL, 0) != ERR_OK) {
 113              		.loc 1 140 0
 114 00b8 34009FE5 		ldr	r0, .L12+4
 115 00bc 0010A0E3 		mov	r1, #0
 116 00c0 0020A0E3 		mov	r2, #0
 117 00c4 FEFFFFEB 		bl	tcpip_callback_with_block
 118 00c8 0030A0E1 		mov	r3, r0
 119 00cc FF3003E2 		and	r3, r3, #255
 120 00d0 000053E3 		cmp	r3, #0
 121 00d4 0200000A 		beq	.L11
 141:./src/lwip/core/pbuf.c ****       SYS_ARCH_PROTECT(old_level);
 142:./src/lwip/core/pbuf.c ****       pbuf_free_ooseq_queued = 0;
 122              		.loc 1 142 0
 123 00d8 10309FE5 		ldr	r3, .L12
 124 00dc 0020A0E3 		mov	r2, #0
 125 00e0 0020C3E5 		strb	r2, [r3, #0]
 126              	.L11:
 143:./src/lwip/core/pbuf.c ****       SYS_ARCH_UNPROTECT(old_level);
 144:./src/lwip/core/pbuf.c ****     }
 145:./src/lwip/core/pbuf.c ****   }
 146:./src/lwip/core/pbuf.c **** }
 127              		.loc 1 146 0
 128 00e4 04D04BE2 		sub	sp, fp, #4
 129 00e8 0048BDE8 		ldmfd	sp!, {fp, lr}
 130 00ec 1EFF2FE1 		bx	lr
 131              	.L13:
 132              		.align	2
 133              	.L12:
 134 00f0 00000000 		.word	pbuf_free_ooseq_queued
 135 00f4 00000000 		.word	pbuf_free_ooseq
 136              	.LFE1:
 138              		.align	2
 139              		.global	pbuf_alloc
 141              	pbuf_alloc:
 142              	.LFB2:
 147:./src/lwip/core/pbuf.c **** #endif /* PBUF_POOL_FREE_OOSEQ */
 148:./src/lwip/core/pbuf.c **** #endif /* !TCP_QUEUE_OOSEQ || NO_SYS */
 149:./src/lwip/core/pbuf.c **** 
 150:./src/lwip/core/pbuf.c **** /**
 151:./src/lwip/core/pbuf.c ****  * Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type).
 152:./src/lwip/core/pbuf.c ****  *
 153:./src/lwip/core/pbuf.c ****  * The actual memory allocated for the pbuf is determined by the
 154:./src/lwip/core/pbuf.c ****  * layer at which the pbuf is allocated and the requested size
 155:./src/lwip/core/pbuf.c ****  * (from the size parameter).
 156:./src/lwip/core/pbuf.c ****  *
 157:./src/lwip/core/pbuf.c ****  * @param layer flag to define header size
 158:./src/lwip/core/pbuf.c ****  * @param length size of the pbuf's payload
 159:./src/lwip/core/pbuf.c ****  * @param type this parameter decides how and where the pbuf
 160:./src/lwip/core/pbuf.c ****  * should be allocated as follows:
 161:./src/lwip/core/pbuf.c ****  *
 162:./src/lwip/core/pbuf.c ****  * - PBUF_RAM: buffer memory for pbuf is allocated as one large
 163:./src/lwip/core/pbuf.c ****  *             chunk. This includes protocol headers as well.
 164:./src/lwip/core/pbuf.c ****  * - PBUF_ROM: no buffer memory is allocated for the pbuf, even for
 165:./src/lwip/core/pbuf.c ****  *             protocol headers. Additional headers must be prepended
 166:./src/lwip/core/pbuf.c ****  *             by allocating another pbuf and chain in to the front of
 167:./src/lwip/core/pbuf.c ****  *             the ROM pbuf. It is assumed that the memory used is really
 168:./src/lwip/core/pbuf.c ****  *             similar to ROM in that it is immutable and will not be
 169:./src/lwip/core/pbuf.c ****  *             changed. Memory which is dynamic should generally not
 170:./src/lwip/core/pbuf.c ****  *             be attached to PBUF_ROM pbufs. Use PBUF_REF instead.
 171:./src/lwip/core/pbuf.c ****  * - PBUF_REF: no buffer memory is allocated for the pbuf, even for
 172:./src/lwip/core/pbuf.c ****  *             protocol headers. It is assumed that the pbuf is only
 173:./src/lwip/core/pbuf.c ****  *             being used in a single thread. If the pbuf gets queued,
 174:./src/lwip/core/pbuf.c ****  *             then pbuf_take should be called to copy the buffer.
 175:./src/lwip/core/pbuf.c ****  * - PBUF_POOL: the pbuf is allocated as a pbuf chain, with pbufs from
 176:./src/lwip/core/pbuf.c ****  *              the pbuf pool that is allocated during pbuf_init().
 177:./src/lwip/core/pbuf.c ****  *
 178:./src/lwip/core/pbuf.c ****  * @return the allocated pbuf. If multiple pbufs where allocated, this
 179:./src/lwip/core/pbuf.c ****  * is the first pbuf of a pbuf chain.
 180:./src/lwip/core/pbuf.c ****  */
 181:./src/lwip/core/pbuf.c **** struct pbuf *
 182:./src/lwip/core/pbuf.c **** pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
 183:./src/lwip/core/pbuf.c **** {
 143              		.loc 1 183 0
 144              		@ Function supports interworking.
 145              		@ args = 0, pretend = 0, frame = 32
 146              		@ frame_needed = 1, uses_anonymous_args = 0
 147 00f8 00482DE9 		stmfd	sp!, {fp, lr}
 148              	.LCFI6:
 149 00fc 04B08DE2 		add	fp, sp, #4
 150              	.LCFI7:
 151 0100 20D04DE2 		sub	sp, sp, #32
 152              	.LCFI8:
 153 0104 0230A0E1 		mov	r3, r2
 154 0108 0020A0E1 		mov	r2, r0
 155 010c 1D204BE5 		strb	r2, [fp, #-29]
 156 0110 B0124BE1 		strh	r1, [fp, #-32]	@ movhi
 157 0114 21304BE5 		strb	r3, [fp, #-33]
 184:./src/lwip/core/pbuf.c ****   struct pbuf *p, *q, *r;
 185:./src/lwip/core/pbuf.c ****   u16_t offset;
 186:./src/lwip/core/pbuf.c ****   s32_t rem_len; /* remaining length */
 187:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
 188:./src/lwip/core/pbuf.c **** 
 189:./src/lwip/core/pbuf.c ****   /* determine header offset */
 190:./src/lwip/core/pbuf.c ****   offset = 0;
 158              		.loc 1 190 0
 159 0118 0030A0E3 		mov	r3, #0
 160 011c BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 191:./src/lwip/core/pbuf.c ****   switch (layer) {
 161              		.loc 1 191 0
 162 0120 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 163 0124 030053E3 		cmp	r3, #3
 164 0128 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 165 012c 0D0000EA 		b	.L15
 166              	.L20:
 167 0130 40010000 		.word	.L16
 168 0134 4C010000 		.word	.L17
 169 0138 58010000 		.word	.L18
 170 013c 70010000 		.word	.L38
 171              	.L16:
 192:./src/lwip/core/pbuf.c ****   case PBUF_TRANSPORT:
 193:./src/lwip/core/pbuf.c ****     /* add room for transport (often TCP) layer header */
 194:./src/lwip/core/pbuf.c ****     offset += PBUF_TRANSPORT_HLEN;
 172              		.loc 1 194 0
 173 0140 BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 174 0144 143083E2 		add	r3, r3, #20
 175 0148 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 176              	.L17:
 195:./src/lwip/core/pbuf.c ****     /* FALLTHROUGH */
 196:./src/lwip/core/pbuf.c ****   case PBUF_IP:
 197:./src/lwip/core/pbuf.c ****     /* add room for IP layer header */
 198:./src/lwip/core/pbuf.c ****     offset += PBUF_IP_HLEN;
 177              		.loc 1 198 0
 178 014c BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 179 0150 143083E2 		add	r3, r3, #20
 180 0154 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 181              	.L18:
 199:./src/lwip/core/pbuf.c ****     /* FALLTHROUGH */
 200:./src/lwip/core/pbuf.c ****   case PBUF_LINK:
 201:./src/lwip/core/pbuf.c ****     /* add room for link layer header */
 202:./src/lwip/core/pbuf.c ****     offset += PBUF_LINK_HLEN;
 182              		.loc 1 202 0
 183 0158 BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 184 015c 0E3083E2 		add	r3, r3, #14
 185 0160 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 203:./src/lwip/core/pbuf.c ****     break;
 186              		.loc 1 203 0
 187 0164 020000EA 		b	.L21
 188              	.L15:
 204:./src/lwip/core/pbuf.c ****   case PBUF_RAW:
 205:./src/lwip/core/pbuf.c ****     break;
 206:./src/lwip/core/pbuf.c ****   default:
 207:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 208:./src/lwip/core/pbuf.c ****     return NULL;
 189              		.loc 1 208 0
 190 0168 0030A0E3 		mov	r3, #0
 191 016c BC0000EA 		b	.L22
 192              	.L38:
 193              		.loc 1 205 0
 194 0170 0000A0E1 		mov	r0, r0	@ nop
 195              	.L21:
 209:./src/lwip/core/pbuf.c ****   }
 210:./src/lwip/core/pbuf.c **** 
 211:./src/lwip/core/pbuf.c ****   switch (type) {
 196              		.loc 1 211 0
 197 0174 21305BE5 		ldrb	r3, [fp, #-33]	@ zero_extendqisi2
 198 0178 030053E3 		cmp	r3, #3
 199 017c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 200 0180 AE0000EA 		b	.L23
 201              	.L27:
 202 0184 44030000 		.word	.L24
 203 0188 D8030000 		.word	.L25
 204 018c D8030000 		.word	.L25
 205 0190 94010000 		.word	.L26
 206              	.L26:
 212:./src/lwip/core/pbuf.c ****   case PBUF_POOL:
 213:./src/lwip/core/pbuf.c ****     /* allocate head of pbuf chain into p */
 214:./src/lwip/core/pbuf.c ****     p = memp_malloc(MEMP_PBUF_POOL);
 207              		.loc 1 214 0
 208 0194 0C00A0E3 		mov	r0, #12
 209 0198 FEFFFFEB 		bl	memp_malloc
 210 019c 0030A0E1 		mov	r3, r0
 211 01a0 18300BE5 		str	r3, [fp, #-24]
 215:./src/lwip/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
 216:./src/lwip/core/pbuf.c ****     if (p == NULL) {
 212              		.loc 1 216 0
 213 01a4 18301BE5 		ldr	r3, [fp, #-24]
 214 01a8 000053E3 		cmp	r3, #0
 215 01ac 0200001A 		bne	.L28
 217:./src/lwip/core/pbuf.c ****       PBUF_POOL_IS_EMPTY();
 216              		.loc 1 217 0
 217 01b0 B4FFFFEB 		bl	pbuf_pool_is_empty
 218:./src/lwip/core/pbuf.c ****       return NULL;
 218              		.loc 1 218 0
 219 01b4 0030A0E3 		mov	r3, #0
 220 01b8 A90000EA 		b	.L22
 221              	.L28:
 219:./src/lwip/core/pbuf.c ****     }
 220:./src/lwip/core/pbuf.c ****     p->type = type;
 222              		.loc 1 220 0
 223 01bc 18301BE5 		ldr	r3, [fp, #-24]
 224 01c0 21205BE5 		ldrb	r2, [fp, #-33]
 225 01c4 0C20C3E5 		strb	r2, [r3, #12]
 221:./src/lwip/core/pbuf.c ****     p->next = NULL;
 226              		.loc 1 221 0
 227 01c8 18301BE5 		ldr	r3, [fp, #-24]
 228 01cc 0020A0E3 		mov	r2, #0
 229 01d0 002083E5 		str	r2, [r3, #0]
 222:./src/lwip/core/pbuf.c **** 
 223:./src/lwip/core/pbuf.c ****     /* make the payload pointer point 'offset' bytes into pbuf data memory */
 224:./src/lwip/core/pbuf.c ****     p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 230              		.loc 1 224 0
 231 01d4 BA305BE1 		ldrh	r3, [fp, #-10]
 232 01d8 102083E2 		add	r2, r3, #16
 233 01dc 18301BE5 		ldr	r3, [fp, #-24]
 234 01e0 032082E0 		add	r2, r2, r3
 235 01e4 18301BE5 		ldr	r3, [fp, #-24]
 236 01e8 042083E5 		str	r2, [r3, #4]
 225:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
 226:./src/lwip/core/pbuf.c ****             ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
 227:./src/lwip/core/pbuf.c ****     /* the total length of the pbuf chain is the requested size */
 228:./src/lwip/core/pbuf.c ****     p->tot_len = length;
 237              		.loc 1 228 0
 238 01ec 18301BE5 		ldr	r3, [fp, #-24]
 239 01f0 B0225BE1 		ldrh	r2, [fp, #-32]	@ movhi
 240 01f4 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 229:./src/lwip/core/pbuf.c ****     /* set the length of the first pbuf in the chain */
 230:./src/lwip/core/pbuf.c ****     p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 241              		.loc 1 230 0
 242 01f8 BA305BE1 		ldrh	r3, [fp, #-10]
 243 01fc 933F63E2 		rsb	r3, r3, #588
 244 0200 023083E2 		add	r3, r3, #2
 245 0204 B0225BE1 		ldrh	r2, [fp, #-32]
 246 0208 020053E1 		cmp	r3, r2
 247 020c 0230A0A1 		movge	r3, r2
 248 0210 0338A0E1 		mov	r3, r3, asl #16
 249 0214 2328A0E1 		mov	r2, r3, lsr #16
 250 0218 18301BE5 		ldr	r3, [fp, #-24]
 251 021c BA20C3E1 		strh	r2, [r3, #10]	@ movhi
 231:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 232:./src/lwip/core/pbuf.c ****                 ((u8_t*)p->payload + p->len <=
 233:./src/lwip/core/pbuf.c ****                  (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
 234:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 235:./src/lwip/core/pbuf.c ****       (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
 236:./src/lwip/core/pbuf.c ****     /* set reference count (needed here in case we fail) */
 237:./src/lwip/core/pbuf.c ****     p->ref = 1;
 252              		.loc 1 237 0
 253 0220 18301BE5 		ldr	r3, [fp, #-24]
 254 0224 0120A0E3 		mov	r2, #1
 255 0228 BE20C3E1 		strh	r2, [r3, #14]	@ movhi
 238:./src/lwip/core/pbuf.c **** 
 239:./src/lwip/core/pbuf.c ****     /* now allocate the tail of the pbuf chain */
 240:./src/lwip/core/pbuf.c **** 
 241:./src/lwip/core/pbuf.c ****     /* remember first pbuf for linkage in next iteration */
 242:./src/lwip/core/pbuf.c ****     r = p;
 256              		.loc 1 242 0
 257 022c 18301BE5 		ldr	r3, [fp, #-24]
 258 0230 10300BE5 		str	r3, [fp, #-16]
 243:./src/lwip/core/pbuf.c ****     /* remaining length to be allocated */
 244:./src/lwip/core/pbuf.c ****     rem_len = length - p->len;
 259              		.loc 1 244 0
 260 0234 B0225BE1 		ldrh	r2, [fp, #-32]
 261 0238 18301BE5 		ldr	r3, [fp, #-24]
 262 023c BA30D3E1 		ldrh	r3, [r3, #10]
 263 0240 023063E0 		rsb	r3, r3, r2
 264 0244 08300BE5 		str	r3, [fp, #-8]
 245:./src/lwip/core/pbuf.c ****     /* any remaining pbufs to be allocated? */
 246:./src/lwip/core/pbuf.c ****     while (rem_len > 0) {
 265              		.loc 1 246 0
 266 0248 390000EA 		b	.L29
 267              	.L33:
 247:./src/lwip/core/pbuf.c ****       q = memp_malloc(MEMP_PBUF_POOL);
 268              		.loc 1 247 0
 269 024c 0C00A0E3 		mov	r0, #12
 270 0250 FEFFFFEB 		bl	memp_malloc
 271 0254 0030A0E1 		mov	r3, r0
 272 0258 14300BE5 		str	r3, [fp, #-20]
 248:./src/lwip/core/pbuf.c ****       if (q == NULL) {
 273              		.loc 1 248 0
 274 025c 14301BE5 		ldr	r3, [fp, #-20]
 275 0260 000053E3 		cmp	r3, #0
 276 0264 0400001A 		bne	.L30
 249:./src/lwip/core/pbuf.c ****         PBUF_POOL_IS_EMPTY();
 277              		.loc 1 249 0
 278 0268 86FFFFEB 		bl	pbuf_pool_is_empty
 250:./src/lwip/core/pbuf.c ****         /* free chain so far allocated */
 251:./src/lwip/core/pbuf.c ****         pbuf_free(p);
 279              		.loc 1 251 0
 280 026c 18001BE5 		ldr	r0, [fp, #-24]
 281 0270 FEFFFFEB 		bl	pbuf_free
 252:./src/lwip/core/pbuf.c ****         /* bail out unsuccesfully */
 253:./src/lwip/core/pbuf.c ****         return NULL;
 282              		.loc 1 253 0
 283 0274 0030A0E3 		mov	r3, #0
 284 0278 790000EA 		b	.L22
 285              	.L30:
 254:./src/lwip/core/pbuf.c ****       }
 255:./src/lwip/core/pbuf.c ****       q->type = type;
 286              		.loc 1 255 0
 287 027c 14301BE5 		ldr	r3, [fp, #-20]
 288 0280 21205BE5 		ldrb	r2, [fp, #-33]
 289 0284 0C20C3E5 		strb	r2, [r3, #12]
 256:./src/lwip/core/pbuf.c ****       q->flags = 0;
 290              		.loc 1 256 0
 291 0288 14301BE5 		ldr	r3, [fp, #-20]
 292 028c 0020A0E3 		mov	r2, #0
 293 0290 0D20C3E5 		strb	r2, [r3, #13]
 257:./src/lwip/core/pbuf.c ****       q->next = NULL;
 294              		.loc 1 257 0
 295 0294 14301BE5 		ldr	r3, [fp, #-20]
 296 0298 0020A0E3 		mov	r2, #0
 297 029c 002083E5 		str	r2, [r3, #0]
 258:./src/lwip/core/pbuf.c ****       /* make previous pbuf point to this pbuf */
 259:./src/lwip/core/pbuf.c ****       r->next = q;
 298              		.loc 1 259 0
 299 02a0 10301BE5 		ldr	r3, [fp, #-16]
 300 02a4 14201BE5 		ldr	r2, [fp, #-20]
 301 02a8 002083E5 		str	r2, [r3, #0]
 260:./src/lwip/core/pbuf.c ****       /* set total length of this pbuf and next in chain */
 261:./src/lwip/core/pbuf.c ****       LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 262:./src/lwip/core/pbuf.c ****       q->tot_len = (u16_t)rem_len;
 302              		.loc 1 262 0
 303 02ac 08301BE5 		ldr	r3, [fp, #-8]
 304 02b0 0338A0E1 		mov	r3, r3, asl #16
 305 02b4 2328A0E1 		mov	r2, r3, lsr #16
 306 02b8 14301BE5 		ldr	r3, [fp, #-20]
 307 02bc B820C3E1 		strh	r2, [r3, #8]	@ movhi
 263:./src/lwip/core/pbuf.c ****       /* this pbuf length is pool size, unless smaller sized tail */
 264:./src/lwip/core/pbuf.c ****       q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 308              		.loc 1 264 0
 309 02c0 08301BE5 		ldr	r3, [fp, #-8]
 310 02c4 0338A0E1 		mov	r3, r3, asl #16
 311 02c8 2328A0E1 		mov	r2, r3, lsr #16
 312 02cc 933FA0E3 		mov	r3, #588
 313 02d0 013083E2 		add	r3, r3, #1
 314 02d4 030052E1 		cmp	r2, r3
 315 02d8 0300008A 		bhi	.L31
 316 02dc 08301BE5 		ldr	r3, [fp, #-8]
 317 02e0 0338A0E1 		mov	r3, r3, asl #16
 318 02e4 2338A0E1 		mov	r3, r3, lsr #16
 319 02e8 010000EA 		b	.L32
 320              	.L31:
 321 02ec 933FA0E3 		mov	r3, #588
 322 02f0 023083E2 		add	r3, r3, #2
 323              	.L32:
 324 02f4 14201BE5 		ldr	r2, [fp, #-20]
 325 02f8 BA30C2E1 		strh	r3, [r2, #10]	@ movhi
 265:./src/lwip/core/pbuf.c ****       q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 326              		.loc 1 265 0
 327 02fc 14301BE5 		ldr	r3, [fp, #-20]
 328 0300 102083E2 		add	r2, r3, #16
 329 0304 14301BE5 		ldr	r3, [fp, #-20]
 330 0308 042083E5 		str	r2, [r3, #4]
 266:./src/lwip/core/pbuf.c ****       LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 267:./src/lwip/core/pbuf.c ****               ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
 268:./src/lwip/core/pbuf.c ****       LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 269:./src/lwip/core/pbuf.c ****                   ((u8_t*)p->payload + p->len <=
 270:./src/lwip/core/pbuf.c ****                    (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
 271:./src/lwip/core/pbuf.c ****       q->ref = 1;
 331              		.loc 1 271 0
 332 030c 14301BE5 		ldr	r3, [fp, #-20]
 333 0310 0120A0E3 		mov	r2, #1
 334 0314 BE20C3E1 		strh	r2, [r3, #14]	@ movhi
 272:./src/lwip/core/pbuf.c ****       /* calculate remaining length to be allocated */
 273:./src/lwip/core/pbuf.c ****       rem_len -= q->len;
 335              		.loc 1 273 0
 336 0318 14301BE5 		ldr	r3, [fp, #-20]
 337 031c BA30D3E1 		ldrh	r3, [r3, #10]
 338 0320 08201BE5 		ldr	r2, [fp, #-8]
 339 0324 023063E0 		rsb	r3, r3, r2
 340 0328 08300BE5 		str	r3, [fp, #-8]
 274:./src/lwip/core/pbuf.c ****       /* remember this pbuf for linkage in next iteration */
 275:./src/lwip/core/pbuf.c ****       r = q;
 341              		.loc 1 275 0
 342 032c 14301BE5 		ldr	r3, [fp, #-20]
 343 0330 10300BE5 		str	r3, [fp, #-16]
 344              	.L29:
 345              		.loc 1 246 0
 346 0334 08301BE5 		ldr	r3, [fp, #-8]
 347 0338 000053E3 		cmp	r3, #0
 348 033c C2FFFFCA 		bgt	.L33
 276:./src/lwip/core/pbuf.c ****     }
 277:./src/lwip/core/pbuf.c ****     /* end of chain */
 278:./src/lwip/core/pbuf.c ****     /*r->next = NULL;*/
 279:./src/lwip/core/pbuf.c **** 
 280:./src/lwip/core/pbuf.c ****     break;
 349              		.loc 1 280 0
 350 0340 400000EA 		b	.L34
 351              	.L24:
 281:./src/lwip/core/pbuf.c ****   case PBUF_RAM:
 282:./src/lwip/core/pbuf.c ****     /* If pbuf is to be allocated in RAM, allocate memory for it. */
 283:./src/lwip/core/pbuf.c ****     p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_
 352              		.loc 1 283 0
 353 0344 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 354 0348 B0325BE1 		ldrh	r3, [fp, #-32]	@ movhi
 355 034c 033082E0 		add	r3, r2, r3
 356 0350 0338A0E1 		mov	r3, r3, asl #16
 357 0354 2338A0E1 		mov	r3, r3, lsr #16
 358 0358 103083E2 		add	r3, r3, #16
 359 035c 0338A0E1 		mov	r3, r3, asl #16
 360 0360 2338A0E1 		mov	r3, r3, lsr #16
 361 0364 0300A0E1 		mov	r0, r3
 362 0368 FEFFFFEB 		bl	mem_malloc
 363 036c 0030A0E1 		mov	r3, r0
 364 0370 18300BE5 		str	r3, [fp, #-24]
 284:./src/lwip/core/pbuf.c ****     if (p == NULL) {
 365              		.loc 1 284 0
 366 0374 18301BE5 		ldr	r3, [fp, #-24]
 367 0378 000053E3 		cmp	r3, #0
 368 037c 0100001A 		bne	.L35
 285:./src/lwip/core/pbuf.c ****       return NULL;
 369              		.loc 1 285 0
 370 0380 0030A0E3 		mov	r3, #0
 371 0384 360000EA 		b	.L22
 372              	.L35:
 286:./src/lwip/core/pbuf.c ****     }
 287:./src/lwip/core/pbuf.c ****     /* Set up internal structure of the pbuf. */
 288:./src/lwip/core/pbuf.c ****     p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 373              		.loc 1 288 0
 374 0388 BA305BE1 		ldrh	r3, [fp, #-10]
 375 038c 102083E2 		add	r2, r3, #16
 376 0390 18301BE5 		ldr	r3, [fp, #-24]
 377 0394 032082E0 		add	r2, r2, r3
 378 0398 18301BE5 		ldr	r3, [fp, #-24]
 379 039c 042083E5 		str	r2, [r3, #4]
 289:./src/lwip/core/pbuf.c ****     p->len = p->tot_len = length;
 380              		.loc 1 289 0
 381 03a0 18301BE5 		ldr	r3, [fp, #-24]
 382 03a4 B0225BE1 		ldrh	r2, [fp, #-32]	@ movhi
 383 03a8 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 384 03ac 18301BE5 		ldr	r3, [fp, #-24]
 385 03b0 B820D3E1 		ldrh	r2, [r3, #8]
 386 03b4 18301BE5 		ldr	r3, [fp, #-24]
 387 03b8 BA20C3E1 		strh	r2, [r3, #10]	@ movhi
 290:./src/lwip/core/pbuf.c ****     p->next = NULL;
 388              		.loc 1 290 0
 389 03bc 18301BE5 		ldr	r3, [fp, #-24]
 390 03c0 0020A0E3 		mov	r2, #0
 391 03c4 002083E5 		str	r2, [r3, #0]
 291:./src/lwip/core/pbuf.c ****     p->type = type;
 392              		.loc 1 291 0
 393 03c8 18301BE5 		ldr	r3, [fp, #-24]
 394 03cc 21205BE5 		ldrb	r2, [fp, #-33]
 395 03d0 0C20C3E5 		strb	r2, [r3, #12]
 292:./src/lwip/core/pbuf.c **** 
 293:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 294:./src/lwip/core/pbuf.c ****            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
 295:./src/lwip/core/pbuf.c ****     break;
 396              		.loc 1 295 0
 397 03d4 1B0000EA 		b	.L34
 398              	.L25:
 296:./src/lwip/core/pbuf.c ****   /* pbuf references existing (non-volatile static constant) ROM payload? */
 297:./src/lwip/core/pbuf.c ****   case PBUF_ROM:
 298:./src/lwip/core/pbuf.c ****   /* pbuf references existing (externally allocated) RAM payload? */
 299:./src/lwip/core/pbuf.c ****   case PBUF_REF:
 300:./src/lwip/core/pbuf.c ****     /* only allocate memory for the pbuf structure */
 301:./src/lwip/core/pbuf.c ****     p = memp_malloc(MEMP_PBUF);
 399              		.loc 1 301 0
 400 03d8 0B00A0E3 		mov	r0, #11
 401 03dc FEFFFFEB 		bl	memp_malloc
 402 03e0 0030A0E1 		mov	r3, r0
 403 03e4 18300BE5 		str	r3, [fp, #-24]
 302:./src/lwip/core/pbuf.c ****     if (p == NULL) {
 404              		.loc 1 302 0
 405 03e8 18301BE5 		ldr	r3, [fp, #-24]
 406 03ec 000053E3 		cmp	r3, #0
 407 03f0 0100001A 		bne	.L36
 303:./src/lwip/core/pbuf.c ****       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 304:./src/lwip/core/pbuf.c ****                   ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
 305:./src/lwip/core/pbuf.c ****                   (type == PBUF_ROM) ? "ROM" : "REF"));
 306:./src/lwip/core/pbuf.c ****       return NULL;
 408              		.loc 1 306 0
 409 03f4 0030A0E3 		mov	r3, #0
 410 03f8 190000EA 		b	.L22
 411              	.L36:
 307:./src/lwip/core/pbuf.c ****     }
 308:./src/lwip/core/pbuf.c ****     /* caller must set this field properly, afterwards */
 309:./src/lwip/core/pbuf.c ****     p->payload = NULL;
 412              		.loc 1 309 0
 413 03fc 18301BE5 		ldr	r3, [fp, #-24]
 414 0400 0020A0E3 		mov	r2, #0
 415 0404 042083E5 		str	r2, [r3, #4]
 310:./src/lwip/core/pbuf.c ****     p->len = p->tot_len = length;
 416              		.loc 1 310 0
 417 0408 18301BE5 		ldr	r3, [fp, #-24]
 418 040c B0225BE1 		ldrh	r2, [fp, #-32]	@ movhi
 419 0410 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 420 0414 18301BE5 		ldr	r3, [fp, #-24]
 421 0418 B820D3E1 		ldrh	r2, [r3, #8]
 422 041c 18301BE5 		ldr	r3, [fp, #-24]
 423 0420 BA20C3E1 		strh	r2, [r3, #10]	@ movhi
 311:./src/lwip/core/pbuf.c ****     p->next = NULL;
 424              		.loc 1 311 0
 425 0424 18301BE5 		ldr	r3, [fp, #-24]
 426 0428 0020A0E3 		mov	r2, #0
 427 042c 002083E5 		str	r2, [r3, #0]
 312:./src/lwip/core/pbuf.c ****     p->type = type;
 428              		.loc 1 312 0
 429 0430 18301BE5 		ldr	r3, [fp, #-24]
 430 0434 21205BE5 		ldrb	r2, [fp, #-33]
 431 0438 0C20C3E5 		strb	r2, [r3, #12]
 313:./src/lwip/core/pbuf.c ****     break;
 432              		.loc 1 313 0
 433 043c 010000EA 		b	.L34
 434              	.L23:
 314:./src/lwip/core/pbuf.c ****   default:
 315:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 316:./src/lwip/core/pbuf.c ****     return NULL;
 435              		.loc 1 316 0
 436 0440 0030A0E3 		mov	r3, #0
 437 0444 060000EA 		b	.L22
 438              	.L34:
 317:./src/lwip/core/pbuf.c ****   }
 318:./src/lwip/core/pbuf.c ****   /* set reference count */
 319:./src/lwip/core/pbuf.c ****   p->ref = 1;
 439              		.loc 1 319 0
 440 0448 18301BE5 		ldr	r3, [fp, #-24]
 441 044c 0120A0E3 		mov	r2, #1
 442 0450 BE20C3E1 		strh	r2, [r3, #14]	@ movhi
 320:./src/lwip/core/pbuf.c ****   /* set flags */
 321:./src/lwip/core/pbuf.c ****   p->flags = 0;
 443              		.loc 1 321 0
 444 0454 18301BE5 		ldr	r3, [fp, #-24]
 445 0458 0020A0E3 		mov	r2, #0
 446 045c 0D20C3E5 		strb	r2, [r3, #13]
 322:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)
 323:./src/lwip/core/pbuf.c ****   return p;
 447              		.loc 1 323 0
 448 0460 18301BE5 		ldr	r3, [fp, #-24]
 449              	.L22:
 324:./src/lwip/core/pbuf.c **** }
 450              		.loc 1 324 0
 451 0464 0300A0E1 		mov	r0, r3
 452 0468 04D04BE2 		sub	sp, fp, #4
 453 046c 0048BDE8 		ldmfd	sp!, {fp, lr}
 454 0470 1EFF2FE1 		bx	lr
 455              	.LFE2:
 457              		.align	2
 458              		.global	pbuf_realloc
 460              	pbuf_realloc:
 461              	.LFB3:
 325:./src/lwip/core/pbuf.c **** 
 326:./src/lwip/core/pbuf.c **** 
 327:./src/lwip/core/pbuf.c **** /**
 328:./src/lwip/core/pbuf.c ****  * Shrink a pbuf chain to a desired length.
 329:./src/lwip/core/pbuf.c ****  *
 330:./src/lwip/core/pbuf.c ****  * @param p pbuf to shrink.
 331:./src/lwip/core/pbuf.c ****  * @param new_len desired new length of pbuf chain
 332:./src/lwip/core/pbuf.c ****  *
 333:./src/lwip/core/pbuf.c ****  * Depending on the desired length, the first few pbufs in a chain might
 334:./src/lwip/core/pbuf.c ****  * be skipped and left unchanged. The new last pbuf in the chain will be
 335:./src/lwip/core/pbuf.c ****  * resized, and any remaining pbufs will be freed.
 336:./src/lwip/core/pbuf.c ****  *
 337:./src/lwip/core/pbuf.c ****  * @note If the pbuf is ROM/REF, only the ->tot_len and ->len fields are adjusted.
 338:./src/lwip/core/pbuf.c ****  * @note May not be called on a packet queue.
 339:./src/lwip/core/pbuf.c ****  *
 340:./src/lwip/core/pbuf.c ****  * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 341:./src/lwip/core/pbuf.c ****  */
 342:./src/lwip/core/pbuf.c **** void
 343:./src/lwip/core/pbuf.c **** pbuf_realloc(struct pbuf *p, u16_t new_len)
 344:./src/lwip/core/pbuf.c **** {
 462              		.loc 1 344 0
 463              		@ Function supports interworking.
 464              		@ args = 0, pretend = 0, frame = 24
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0474 00482DE9 		stmfd	sp!, {fp, lr}
 467              	.LCFI9:
 468 0478 04B08DE2 		add	fp, sp, #4
 469              	.LCFI10:
 470 047c 18D04DE2 		sub	sp, sp, #24
 471              	.LCFI11:
 472 0480 18000BE5 		str	r0, [fp, #-24]
 473 0484 0130A0E1 		mov	r3, r1
 474 0488 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 345:./src/lwip/core/pbuf.c ****   struct pbuf *q;
 346:./src/lwip/core/pbuf.c ****   u16_t rem_len; /* remaining length */
 347:./src/lwip/core/pbuf.c ****   s32_t grow;
 348:./src/lwip/core/pbuf.c **** 
 349:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 350:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 475              		.loc 1 350 0
 476 048c 18301BE5 		ldr	r3, [fp, #-24]
 477 0490 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 478 0494 030053E3 		cmp	r3, #3
 479 0498 0600000A 		beq	.L40
 480 049c 18301BE5 		ldr	r3, [fp, #-24]
 481 04a0 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 482 04a4 010053E3 		cmp	r3, #1
 483 04a8 0200000A 		beq	.L40
 484 04ac 18301BE5 		ldr	r3, [fp, #-24]
 485 04b0 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 486 04b4 000053E3 		cmp	r3, #0
 487              	.L40:
 351:./src/lwip/core/pbuf.c ****               p->type == PBUF_ROM ||
 352:./src/lwip/core/pbuf.c ****               p->type == PBUF_RAM ||
 353:./src/lwip/core/pbuf.c ****               p->type == PBUF_REF);
 354:./src/lwip/core/pbuf.c **** 
 355:./src/lwip/core/pbuf.c ****   /* desired length larger than current length? */
 356:./src/lwip/core/pbuf.c ****   if (new_len >= p->tot_len) {
 488              		.loc 1 356 0
 489 04b8 18301BE5 		ldr	r3, [fp, #-24]
 490 04bc B830D3E1 		ldrh	r3, [r3, #8]
 491 04c0 BA215BE1 		ldrh	r2, [fp, #-26]
 492 04c4 030052E1 		cmp	r2, r3
 493 04c8 4F00002A 		bcs	.L48
 494              	.L41:
 357:./src/lwip/core/pbuf.c ****     /* enlarging not yet supported */
 358:./src/lwip/core/pbuf.c ****     return;
 359:./src/lwip/core/pbuf.c ****   }
 360:./src/lwip/core/pbuf.c **** 
 361:./src/lwip/core/pbuf.c ****   /* the pbuf chain grows by (new_len - p->tot_len) bytes
 362:./src/lwip/core/pbuf.c ****    * (which may be negative in case of shrinking) */
 363:./src/lwip/core/pbuf.c ****   grow = new_len - p->tot_len;
 495              		.loc 1 363 0
 496 04cc BA215BE1 		ldrh	r2, [fp, #-26]
 497 04d0 18301BE5 		ldr	r3, [fp, #-24]
 498 04d4 B830D3E1 		ldrh	r3, [r3, #8]
 499 04d8 023063E0 		rsb	r3, r3, r2
 500 04dc 08300BE5 		str	r3, [fp, #-8]
 364:./src/lwip/core/pbuf.c **** 
 365:./src/lwip/core/pbuf.c ****   /* first, step over any pbufs that should remain in the chain */
 366:./src/lwip/core/pbuf.c ****   rem_len = new_len;
 501              		.loc 1 366 0
 502 04e0 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 503 04e4 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 367:./src/lwip/core/pbuf.c ****   q = p;
 504              		.loc 1 367 0
 505 04e8 18301BE5 		ldr	r3, [fp, #-24]
 506 04ec 10300BE5 		str	r3, [fp, #-16]
 368:./src/lwip/core/pbuf.c ****   /* should this pbuf be kept? */
 369:./src/lwip/core/pbuf.c ****   while (rem_len > q->len) {
 507              		.loc 1 369 0
 508 04f0 110000EA 		b	.L43
 509              	.L44:
 370:./src/lwip/core/pbuf.c ****     /* decrease remaining length by pbuf length */
 371:./src/lwip/core/pbuf.c ****     rem_len -= q->len;
 510              		.loc 1 371 0
 511 04f4 10301BE5 		ldr	r3, [fp, #-16]
 512 04f8 BA30D3E1 		ldrh	r3, [r3, #10]
 513 04fc BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 514 0500 023063E0 		rsb	r3, r3, r2
 515 0504 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 372:./src/lwip/core/pbuf.c ****     /* decrease total length indicator */
 373:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 374:./src/lwip/core/pbuf.c ****     q->tot_len += (u16_t)grow;
 516              		.loc 1 374 0
 517 0508 10301BE5 		ldr	r3, [fp, #-16]
 518 050c B820D3E1 		ldrh	r2, [r3, #8]
 519 0510 08301BE5 		ldr	r3, [fp, #-8]
 520 0514 0338A0E1 		mov	r3, r3, asl #16
 521 0518 2338A0E1 		mov	r3, r3, lsr #16
 522 051c 033082E0 		add	r3, r2, r3
 523 0520 0338A0E1 		mov	r3, r3, asl #16
 524 0524 2328A0E1 		mov	r2, r3, lsr #16
 525 0528 10301BE5 		ldr	r3, [fp, #-16]
 526 052c B820C3E1 		strh	r2, [r3, #8]	@ movhi
 375:./src/lwip/core/pbuf.c ****     /* proceed to next pbuf in chain */
 376:./src/lwip/core/pbuf.c ****     q = q->next;
 527              		.loc 1 376 0
 528 0530 10301BE5 		ldr	r3, [fp, #-16]
 529 0534 003093E5 		ldr	r3, [r3, #0]
 530 0538 10300BE5 		str	r3, [fp, #-16]
 531              	.L43:
 532              		.loc 1 369 0
 533 053c 10301BE5 		ldr	r3, [fp, #-16]
 534 0540 BA30D3E1 		ldrh	r3, [r3, #10]
 535 0544 BA205BE1 		ldrh	r2, [fp, #-10]
 536 0548 030052E1 		cmp	r2, r3
 537 054c E8FFFF8A 		bhi	.L44
 377:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 378:./src/lwip/core/pbuf.c ****   }
 379:./src/lwip/core/pbuf.c ****   /* we have now reached the new last pbuf (in q) */
 380:./src/lwip/core/pbuf.c ****   /* rem_len == desired length for pbuf q */
 381:./src/lwip/core/pbuf.c **** 
 382:./src/lwip/core/pbuf.c ****   /* shrink allocated memory for PBUF_RAM */
 383:./src/lwip/core/pbuf.c ****   /* (other types merely adjust their length fields */
 384:./src/lwip/core/pbuf.c ****   if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 538              		.loc 1 384 0
 539 0550 10301BE5 		ldr	r3, [fp, #-16]
 540 0554 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 541 0558 000053E3 		cmp	r3, #0
 542 055c 1700001A 		bne	.L45
 543 0560 10301BE5 		ldr	r3, [fp, #-16]
 544 0564 BA30D3E1 		ldrh	r3, [r3, #10]
 545 0568 BA205BE1 		ldrh	r2, [fp, #-10]
 546 056c 030052E1 		cmp	r2, r3
 547 0570 1200000A 		beq	.L45
 385:./src/lwip/core/pbuf.c ****     /* reallocate and adjust the length of the pbuf that will be split */
 386:./src/lwip/core/pbuf.c ****     q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
 548              		.loc 1 386 0
 549 0574 10301BE5 		ldr	r3, [fp, #-16]
 550 0578 043093E5 		ldr	r3, [r3, #4]
 551 057c 0338A0E1 		mov	r3, r3, asl #16
 552 0580 2328A0E1 		mov	r2, r3, lsr #16
 553 0584 10301BE5 		ldr	r3, [fp, #-16]
 554 0588 0338A0E1 		mov	r3, r3, asl #16
 555 058c 2338A0E1 		mov	r3, r3, lsr #16
 556 0590 023063E0 		rsb	r3, r3, r2
 557 0594 0338A0E1 		mov	r3, r3, asl #16
 558 0598 2328A0E1 		mov	r2, r3, lsr #16
 559 059c BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 560 05a0 033082E0 		add	r3, r2, r3
 561 05a4 0338A0E1 		mov	r3, r3, asl #16
 562 05a8 2338A0E1 		mov	r3, r3, lsr #16
 563 05ac 10001BE5 		ldr	r0, [fp, #-16]
 564 05b0 0310A0E1 		mov	r1, r3
 565 05b4 FEFFFFEB 		bl	mem_realloc
 566 05b8 0030A0E1 		mov	r3, r0
 567 05bc 10300BE5 		str	r3, [fp, #-16]
 568              	.L45:
 387:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
 388:./src/lwip/core/pbuf.c ****   }
 389:./src/lwip/core/pbuf.c ****   /* adjust length fields for new last pbuf */
 390:./src/lwip/core/pbuf.c ****   q->len = rem_len;
 569              		.loc 1 390 0
 570 05c0 10301BE5 		ldr	r3, [fp, #-16]
 571 05c4 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 572 05c8 BA20C3E1 		strh	r2, [r3, #10]	@ movhi
 391:./src/lwip/core/pbuf.c ****   q->tot_len = q->len;
 573              		.loc 1 391 0
 574 05cc 10301BE5 		ldr	r3, [fp, #-16]
 575 05d0 BA20D3E1 		ldrh	r2, [r3, #10]
 576 05d4 10301BE5 		ldr	r3, [fp, #-16]
 577 05d8 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 392:./src/lwip/core/pbuf.c **** 
 393:./src/lwip/core/pbuf.c ****   /* any remaining pbufs in chain? */
 394:./src/lwip/core/pbuf.c ****   if (q->next != NULL) {
 578              		.loc 1 394 0
 579 05dc 10301BE5 		ldr	r3, [fp, #-16]
 580 05e0 003093E5 		ldr	r3, [r3, #0]
 581 05e4 000053E3 		cmp	r3, #0
 582 05e8 0300000A 		beq	.L46
 395:./src/lwip/core/pbuf.c ****     /* free remaining pbufs in chain */
 396:./src/lwip/core/pbuf.c ****     pbuf_free(q->next);
 583              		.loc 1 396 0
 584 05ec 10301BE5 		ldr	r3, [fp, #-16]
 585 05f0 003093E5 		ldr	r3, [r3, #0]
 586 05f4 0300A0E1 		mov	r0, r3
 587 05f8 FEFFFFEB 		bl	pbuf_free
 588              	.L46:
 397:./src/lwip/core/pbuf.c ****   }
 398:./src/lwip/core/pbuf.c ****   /* q is last packet in chain */
 399:./src/lwip/core/pbuf.c ****   q->next = NULL;
 589              		.loc 1 399 0
 590 05fc 10301BE5 		ldr	r3, [fp, #-16]
 591 0600 0020A0E3 		mov	r2, #0
 592 0604 002083E5 		str	r2, [r3, #0]
 593 0608 000000EA 		b	.L47
 594              	.L48:
 595              		.loc 1 358 0
 596 060c 0000A0E1 		mov	r0, r0	@ nop
 597              	.L47:
 400:./src/lwip/core/pbuf.c **** 
 401:./src/lwip/core/pbuf.c **** }
 598              		.loc 1 401 0
 599 0610 04D04BE2 		sub	sp, fp, #4
 600 0614 0048BDE8 		ldmfd	sp!, {fp, lr}
 601 0618 1EFF2FE1 		bx	lr
 602              	.LFE3:
 604              		.align	2
 605              		.global	pbuf_header
 607              	pbuf_header:
 608              	.LFB4:
 402:./src/lwip/core/pbuf.c **** 
 403:./src/lwip/core/pbuf.c **** /**
 404:./src/lwip/core/pbuf.c ****  * Adjusts the payload pointer to hide or reveal headers in the payload.
 405:./src/lwip/core/pbuf.c ****  *
 406:./src/lwip/core/pbuf.c ****  * Adjusts the ->payload pointer so that space for a header
 407:./src/lwip/core/pbuf.c ****  * (dis)appears in the pbuf payload.
 408:./src/lwip/core/pbuf.c ****  *
 409:./src/lwip/core/pbuf.c ****  * The ->payload, ->tot_len and ->len fields are adjusted.
 410:./src/lwip/core/pbuf.c ****  *
 411:./src/lwip/core/pbuf.c ****  * @param p pbuf to change the header size.
 412:./src/lwip/core/pbuf.c ****  * @param header_size_increment Number of bytes to increment header size which
 413:./src/lwip/core/pbuf.c ****  * increases the size of the pbuf. New space is on the front.
 414:./src/lwip/core/pbuf.c ****  * (Using a negative value decreases the header size.)
 415:./src/lwip/core/pbuf.c ****  * If hdr_size_inc is 0, this function does nothing and returns succesful.
 416:./src/lwip/core/pbuf.c ****  *
 417:./src/lwip/core/pbuf.c ****  * PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so
 418:./src/lwip/core/pbuf.c ****  * the call will fail. A check is made that the increase in header size does
 419:./src/lwip/core/pbuf.c ****  * not move the payload pointer in front of the start of the buffer.
 420:./src/lwip/core/pbuf.c ****  * @return non-zero on failure, zero on success.
 421:./src/lwip/core/pbuf.c ****  *
 422:./src/lwip/core/pbuf.c ****  */
 423:./src/lwip/core/pbuf.c **** u8_t
 424:./src/lwip/core/pbuf.c **** pbuf_header(struct pbuf *p, s16_t header_size_increment)
 425:./src/lwip/core/pbuf.c **** {
 609              		.loc 1 425 0
 610              		@ Function supports interworking.
 611              		@ args = 0, pretend = 0, frame = 24
 612              		@ frame_needed = 1, uses_anonymous_args = 0
 613              		@ link register save eliminated.
 614 061c 04B02DE5 		str	fp, [sp, #-4]!
 615              	.LCFI12:
 616 0620 00B08DE2 		add	fp, sp, #0
 617              	.LCFI13:
 618 0624 1CD04DE2 		sub	sp, sp, #28
 619              	.LCFI14:
 620 0628 18000BE5 		str	r0, [fp, #-24]
 621 062c 0130A0E1 		mov	r3, r1
 622 0630 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 426:./src/lwip/core/pbuf.c ****   u16_t type;
 427:./src/lwip/core/pbuf.c ****   void *payload;
 428:./src/lwip/core/pbuf.c ****   u16_t increment_magnitude;
 429:./src/lwip/core/pbuf.c **** 
 430:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("p != NULL", p != NULL);
 431:./src/lwip/core/pbuf.c ****   if ((header_size_increment == 0) || (p == NULL))
 623              		.loc 1 431 0
 624 0634 FA315BE1 		ldrsh	r3, [fp, #-26]
 625 0638 000053E3 		cmp	r3, #0
 626 063c 0200000A 		beq	.L50
 627 0640 18301BE5 		ldr	r3, [fp, #-24]
 628 0644 000053E3 		cmp	r3, #0
 629 0648 0100001A 		bne	.L51
 630              	.L50:
 432:./src/lwip/core/pbuf.c ****     return 0;
 631              		.loc 1 432 0
 632 064c 0030A0E3 		mov	r3, #0
 633 0650 5B0000EA 		b	.L52
 634              	.L51:
 433:./src/lwip/core/pbuf.c ****  
 434:./src/lwip/core/pbuf.c ****   if (header_size_increment < 0){
 635              		.loc 1 434 0
 636 0654 FA315BE1 		ldrsh	r3, [fp, #-26]
 637 0658 000053E3 		cmp	r3, #0
 638 065c 0B0000AA 		bge	.L53
 435:./src/lwip/core/pbuf.c ****     increment_magnitude = -header_size_increment;
 639              		.loc 1 435 0
 640 0660 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 641 0664 003063E2 		rsb	r3, r3, #0
 642 0668 0338A0E1 		mov	r3, r3, asl #16
 643 066c 2338A0E1 		mov	r3, r3, lsr #16
 644 0670 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 436:./src/lwip/core/pbuf.c ****     /* Check that we aren't going to move off the end of the pbuf */
 437:./src/lwip/core/pbuf.c ****     LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 645              		.loc 1 437 0
 646 0674 18301BE5 		ldr	r3, [fp, #-24]
 647 0678 BA30D3E1 		ldrh	r3, [r3, #10]
 648 067c B6205BE1 		ldrh	r2, [fp, #-6]
 649 0680 030052E1 		cmp	r2, r3
 650 0684 0300009A 		bls	.L55
 651 0688 0130A0E3 		mov	r3, #1
 652 068c 4C0000EA 		b	.L52
 653              	.L53:
 438:./src/lwip/core/pbuf.c ****   } else {
 439:./src/lwip/core/pbuf.c ****     increment_magnitude = header_size_increment;
 654              		.loc 1 439 0
 655 0690 BA315BE1 		ldrh	r3, [fp, #-26]	@ movhi
 656 0694 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 657              	.L55:
 440:./src/lwip/core/pbuf.c **** #if 0
 441:./src/lwip/core/pbuf.c ****     /* Can't assert these as some callers speculatively call
 442:./src/lwip/core/pbuf.c ****          pbuf_header() to see if it's OK.  Will return 1 below instead. */
 443:./src/lwip/core/pbuf.c ****     /* Check that we've got the correct type of pbuf to work with */
 444:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
 445:./src/lwip/core/pbuf.c ****                 p->type == PBUF_RAM || p->type == PBUF_POOL);
 446:./src/lwip/core/pbuf.c ****     /* Check that we aren't going to move off the beginning of the pbuf */
 447:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
 448:./src/lwip/core/pbuf.c ****                 (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
 449:./src/lwip/core/pbuf.c **** #endif
 450:./src/lwip/core/pbuf.c ****   }
 451:./src/lwip/core/pbuf.c **** 
 452:./src/lwip/core/pbuf.c ****   type = p->type;
 658              		.loc 1 452 0
 659 0698 18301BE5 		ldr	r3, [fp, #-24]
 660 069c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 661 06a0 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 453:./src/lwip/core/pbuf.c ****   /* remember current payload pointer */
 454:./src/lwip/core/pbuf.c ****   payload = p->payload;
 662              		.loc 1 454 0
 663 06a4 18301BE5 		ldr	r3, [fp, #-24]
 664 06a8 043093E5 		ldr	r3, [r3, #4]
 665 06ac 0C300BE5 		str	r3, [fp, #-12]
 455:./src/lwip/core/pbuf.c **** 
 456:./src/lwip/core/pbuf.c ****   /* pbuf types containing payloads? */
 457:./src/lwip/core/pbuf.c ****   if (type == PBUF_RAM || type == PBUF_POOL) {
 666              		.loc 1 457 0
 667 06b0 BE305BE1 		ldrh	r3, [fp, #-14]
 668 06b4 000053E3 		cmp	r3, #0
 669 06b8 0200000A 		beq	.L56
 670 06bc BE305BE1 		ldrh	r3, [fp, #-14]
 671 06c0 030053E3 		cmp	r3, #3
 672 06c4 1200001A 		bne	.L57
 673              	.L56:
 458:./src/lwip/core/pbuf.c ****     /* set new payload pointer */
 459:./src/lwip/core/pbuf.c ****     p->payload = (u8_t *)p->payload - header_size_increment;
 674              		.loc 1 459 0
 675 06c8 18301BE5 		ldr	r3, [fp, #-24]
 676 06cc 042093E5 		ldr	r2, [r3, #4]
 677 06d0 FA315BE1 		ldrsh	r3, [fp, #-26]
 678 06d4 003063E2 		rsb	r3, r3, #0
 679 06d8 032082E0 		add	r2, r2, r3
 680 06dc 18301BE5 		ldr	r3, [fp, #-24]
 681 06e0 042083E5 		str	r2, [r3, #4]
 460:./src/lwip/core/pbuf.c ****     /* boundary check fails? */
 461:./src/lwip/core/pbuf.c ****     if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 682              		.loc 1 461 0
 683 06e4 18301BE5 		ldr	r3, [fp, #-24]
 684 06e8 043093E5 		ldr	r3, [r3, #4]
 685 06ec 0320A0E1 		mov	r2, r3
 686 06f0 18301BE5 		ldr	r3, [fp, #-24]
 687 06f4 103083E2 		add	r3, r3, #16
 688 06f8 030052E1 		cmp	r2, r3
 689 06fc 1E00002A 		bcs	.L64
 462:./src/lwip/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 463:./src/lwip/core/pbuf.c ****         ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
 464:./src/lwip/core/pbuf.c ****         (void *)p->payload, (void *)(p + 1)));
 465:./src/lwip/core/pbuf.c ****       /* restore old payload pointer */
 466:./src/lwip/core/pbuf.c ****       p->payload = payload;
 690              		.loc 1 466 0
 691 0700 18301BE5 		ldr	r3, [fp, #-24]
 692 0704 0C201BE5 		ldr	r2, [fp, #-12]
 693 0708 042083E5 		str	r2, [r3, #4]
 467:./src/lwip/core/pbuf.c ****       /* bail out unsuccesfully */
 468:./src/lwip/core/pbuf.c ****       return 1;
 694              		.loc 1 468 0
 695 070c 0130A0E3 		mov	r3, #1
 696 0710 2B0000EA 		b	.L52
 697              	.L57:
 469:./src/lwip/core/pbuf.c ****     }
 470:./src/lwip/core/pbuf.c ****   /* pbuf types refering to external payloads? */
 471:./src/lwip/core/pbuf.c ****   } else if (type == PBUF_REF || type == PBUF_ROM) {
 698              		.loc 1 471 0
 699 0714 BE305BE1 		ldrh	r3, [fp, #-14]
 700 0718 020053E3 		cmp	r3, #2
 701 071c 0200000A 		beq	.L60
 702 0720 BE305BE1 		ldrh	r3, [fp, #-14]
 703 0724 010053E3 		cmp	r3, #1
 704 0728 1100001A 		bne	.L61
 705              	.L60:
 472:./src/lwip/core/pbuf.c ****     /* hide a header in the payload? */
 473:./src/lwip/core/pbuf.c ****     if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 706              		.loc 1 473 0
 707 072c FA315BE1 		ldrsh	r3, [fp, #-26]
 708 0730 000053E3 		cmp	r3, #0
 709 0734 0C0000AA 		bge	.L62
 710 0738 18301BE5 		ldr	r3, [fp, #-24]
 711 073c BA30D3E1 		ldrh	r3, [r3, #10]
 712 0740 B6205BE1 		ldrh	r2, [fp, #-6]
 713 0744 030052E1 		cmp	r2, r3
 714 0748 0700008A 		bhi	.L62
 474:./src/lwip/core/pbuf.c ****       /* increase payload pointer */
 475:./src/lwip/core/pbuf.c ****       p->payload = (u8_t *)p->payload - header_size_increment;
 715              		.loc 1 475 0
 716 074c 18301BE5 		ldr	r3, [fp, #-24]
 717 0750 042093E5 		ldr	r2, [r3, #4]
 718 0754 FA315BE1 		ldrsh	r3, [fp, #-26]
 719 0758 003063E2 		rsb	r3, r3, #0
 720 075c 032082E0 		add	r2, r2, r3
 721 0760 18301BE5 		ldr	r3, [fp, #-24]
 722 0764 042083E5 		str	r2, [r3, #4]
 723              		.loc 1 471 0
 724 0768 040000EA 		b	.L59
 725              	.L62:
 476:./src/lwip/core/pbuf.c ****     } else {
 477:./src/lwip/core/pbuf.c ****       /* cannot expand payload to front (yet!)
 478:./src/lwip/core/pbuf.c ****        * bail out unsuccesfully */
 479:./src/lwip/core/pbuf.c ****       return 1;
 726              		.loc 1 479 0
 727 076c 0130A0E3 		mov	r3, #1
 728 0770 130000EA 		b	.L52
 729              	.L61:
 480:./src/lwip/core/pbuf.c ****     }
 481:./src/lwip/core/pbuf.c ****   }
 482:./src/lwip/core/pbuf.c ****   else {
 483:./src/lwip/core/pbuf.c ****     /* Unknown type */
 484:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("bad pbuf type", 0);
 485:./src/lwip/core/pbuf.c ****     return 1;
 730              		.loc 1 485 0
 731 0774 0130A0E3 		mov	r3, #1
 732 0778 110000EA 		b	.L52
 733              	.L64:
 734              		.loc 1 457 0
 735 077c 0000A0E1 		mov	r0, r0	@ nop
 736              	.L59:
 486:./src/lwip/core/pbuf.c ****   }
 487:./src/lwip/core/pbuf.c ****   /* modify pbuf length fields */
 488:./src/lwip/core/pbuf.c ****   p->len += header_size_increment;
 737              		.loc 1 488 0
 738 0780 18301BE5 		ldr	r3, [fp, #-24]
 739 0784 BA20D3E1 		ldrh	r2, [r3, #10]
 740 0788 BA315BE1 		ldrh	r3, [fp, #-26]
 741 078c 033082E0 		add	r3, r2, r3
 742 0790 0338A0E1 		mov	r3, r3, asl #16
 743 0794 2328A0E1 		mov	r2, r3, lsr #16
 744 0798 18301BE5 		ldr	r3, [fp, #-24]
 745 079c BA20C3E1 		strh	r2, [r3, #10]	@ movhi
 489:./src/lwip/core/pbuf.c ****   p->tot_len += header_size_increment;
 746              		.loc 1 489 0
 747 07a0 18301BE5 		ldr	r3, [fp, #-24]
 748 07a4 B820D3E1 		ldrh	r2, [r3, #8]
 749 07a8 BA315BE1 		ldrh	r3, [fp, #-26]
 750 07ac 033082E0 		add	r3, r2, r3
 751 07b0 0338A0E1 		mov	r3, r3, asl #16
 752 07b4 2328A0E1 		mov	r2, r3, lsr #16
 753 07b8 18301BE5 		ldr	r3, [fp, #-24]
 754 07bc B820C3E1 		strh	r2, [r3, #8]	@ movhi
 490:./src/lwip/core/pbuf.c **** 
 491:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
 492:./src/lwip/core/pbuf.c ****     (void *)payload, (void *)p->payload, header_size_increment));
 493:./src/lwip/core/pbuf.c **** 
 494:./src/lwip/core/pbuf.c ****   return 0;
 755              		.loc 1 494 0
 756 07c0 0030A0E3 		mov	r3, #0
 757              	.L52:
 495:./src/lwip/core/pbuf.c **** }
 758              		.loc 1 495 0
 759 07c4 0300A0E1 		mov	r0, r3
 760 07c8 00D08BE2 		add	sp, fp, #0
 761 07cc 0008BDE8 		ldmfd	sp!, {fp}
 762 07d0 1EFF2FE1 		bx	lr
 763              	.LFE4:
 765              		.align	2
 766              		.global	pbuf_free
 768              	pbuf_free:
 769              	.LFB5:
 496:./src/lwip/core/pbuf.c **** 
 497:./src/lwip/core/pbuf.c **** /**
 498:./src/lwip/core/pbuf.c ****  * Dereference a pbuf chain or queue and deallocate any no-longer-used
 499:./src/lwip/core/pbuf.c ****  * pbufs at the head of this chain or queue.
 500:./src/lwip/core/pbuf.c ****  *
 501:./src/lwip/core/pbuf.c ****  * Decrements the pbuf reference count. If it reaches zero, the pbuf is
 502:./src/lwip/core/pbuf.c ****  * deallocated.
 503:./src/lwip/core/pbuf.c ****  *
 504:./src/lwip/core/pbuf.c ****  * For a pbuf chain, this is repeated for each pbuf in the chain,
 505:./src/lwip/core/pbuf.c ****  * up to the first pbuf which has a non-zero reference count after
 506:./src/lwip/core/pbuf.c ****  * decrementing. So, when all reference counts are one, the whole
 507:./src/lwip/core/pbuf.c ****  * chain is free'd.
 508:./src/lwip/core/pbuf.c ****  *
 509:./src/lwip/core/pbuf.c ****  * @param p The pbuf (chain) to be dereferenced.
 510:./src/lwip/core/pbuf.c ****  *
 511:./src/lwip/core/pbuf.c ****  * @return the number of pbufs that were de-allocated
 512:./src/lwip/core/pbuf.c ****  * from the head of the chain.
 513:./src/lwip/core/pbuf.c ****  *
 514:./src/lwip/core/pbuf.c ****  * @note MUST NOT be called on a packet queue (Not verified to work yet).
 515:./src/lwip/core/pbuf.c ****  * @note the reference counter of a pbuf equals the number of pointers
 516:./src/lwip/core/pbuf.c ****  * that refer to the pbuf (or into the pbuf).
 517:./src/lwip/core/pbuf.c ****  *
 518:./src/lwip/core/pbuf.c ****  * @internal examples:
 519:./src/lwip/core/pbuf.c ****  *
 520:./src/lwip/core/pbuf.c ****  * Assuming existing chains a->b->c with the following reference
 521:./src/lwip/core/pbuf.c ****  * counts, calling pbuf_free(a) results in:
 522:./src/lwip/core/pbuf.c ****  * 
 523:./src/lwip/core/pbuf.c ****  * 1->2->3 becomes ...1->3
 524:./src/lwip/core/pbuf.c ****  * 3->3->3 becomes 2->3->3
 525:./src/lwip/core/pbuf.c ****  * 1->1->2 becomes ......1
 526:./src/lwip/core/pbuf.c ****  * 2->1->1 becomes 1->1->1
 527:./src/lwip/core/pbuf.c ****  * 1->1->1 becomes .......
 528:./src/lwip/core/pbuf.c ****  *
 529:./src/lwip/core/pbuf.c ****  */
 530:./src/lwip/core/pbuf.c **** u8_t
 531:./src/lwip/core/pbuf.c **** pbuf_free(struct pbuf *p)
 532:./src/lwip/core/pbuf.c **** {
 770              		.loc 1 532 0
 771              		@ Function supports interworking.
 772              		@ args = 0, pretend = 0, frame = 24
 773              		@ frame_needed = 1, uses_anonymous_args = 0
 774 07d4 00482DE9 		stmfd	sp!, {fp, lr}
 775              	.LCFI15:
 776 07d8 04B08DE2 		add	fp, sp, #4
 777              	.LCFI16:
 778 07dc 18D04DE2 		sub	sp, sp, #24
 779              	.LCFI17:
 780 07e0 18000BE5 		str	r0, [fp, #-24]
 533:./src/lwip/core/pbuf.c ****   u16_t type;
 534:./src/lwip/core/pbuf.c ****   struct pbuf *q;
 535:./src/lwip/core/pbuf.c ****   u8_t count;
 536:./src/lwip/core/pbuf.c **** 
 537:./src/lwip/core/pbuf.c ****   if (p == NULL) {
 781              		.loc 1 537 0
 782 07e4 18301BE5 		ldr	r3, [fp, #-24]
 783 07e8 000053E3 		cmp	r3, #0
 784 07ec 0100001A 		bne	.L66
 538:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("p != NULL", p != NULL);
 539:./src/lwip/core/pbuf.c ****     /* if assertions are disabled, proceed with debug output */
 540:./src/lwip/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 541:./src/lwip/core/pbuf.c ****       ("pbuf_free(p == NULL) was called.\n"));
 542:./src/lwip/core/pbuf.c ****     return 0;
 785              		.loc 1 542 0
 786 07f0 0030A0E3 		mov	r3, #0
 787 07f4 3F0000EA 		b	.L67
 788              	.L66:
 543:./src/lwip/core/pbuf.c ****   }
 544:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
 545:./src/lwip/core/pbuf.c **** 
 546:./src/lwip/core/pbuf.c ****   PERF_START;
 547:./src/lwip/core/pbuf.c **** 
 548:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("pbuf_free: sane type",
 789              		.loc 1 548 0
 790 07f8 18301BE5 		ldr	r3, [fp, #-24]
 791 07fc 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 792 0800 000053E3 		cmp	r3, #0
 793 0804 0600000A 		beq	.L68
 794 0808 18301BE5 		ldr	r3, [fp, #-24]
 795 080c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 796 0810 010053E3 		cmp	r3, #1
 797 0814 0200000A 		beq	.L68
 798 0818 18301BE5 		ldr	r3, [fp, #-24]
 799 081c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 800 0820 020053E3 		cmp	r3, #2
 801              	.L68:
 549:./src/lwip/core/pbuf.c ****     p->type == PBUF_RAM || p->type == PBUF_ROM ||
 550:./src/lwip/core/pbuf.c ****     p->type == PBUF_REF || p->type == PBUF_POOL);
 551:./src/lwip/core/pbuf.c **** 
 552:./src/lwip/core/pbuf.c ****   count = 0;
 802              		.loc 1 552 0
 803 0824 0030A0E3 		mov	r3, #0
 804 0828 07304BE5 		strb	r3, [fp, #-7]
 553:./src/lwip/core/pbuf.c ****   /* de-allocate all consecutive pbufs from the head of the chain that
 554:./src/lwip/core/pbuf.c ****    * obtain a zero reference count after decrementing*/
 555:./src/lwip/core/pbuf.c ****   while (p != NULL) {
 805              		.loc 1 555 0
 806 082c 2D0000EA 		b	.L69
 807              	.L75:
 808              	.LBB2:
 556:./src/lwip/core/pbuf.c ****     u16_t ref;
 557:./src/lwip/core/pbuf.c ****     SYS_ARCH_DECL_PROTECT(old_level);
 558:./src/lwip/core/pbuf.c ****     /* Since decrementing ref cannot be guaranteed to be a single machine operation
 559:./src/lwip/core/pbuf.c ****      * we must protect it. We put the new ref into a local variable to prevent
 560:./src/lwip/core/pbuf.c ****      * further protection. */
 561:./src/lwip/core/pbuf.c ****     SYS_ARCH_PROTECT(old_level);
 562:./src/lwip/core/pbuf.c ****     /* all pbufs in a chain are referenced at least once */
 563:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 564:./src/lwip/core/pbuf.c ****     /* decrease reference count (number of pointers to pbuf) */
 565:./src/lwip/core/pbuf.c ****     ref = --(p->ref);
 809              		.loc 1 565 0
 810 0830 18301BE5 		ldr	r3, [fp, #-24]
 811 0834 BE30D3E1 		ldrh	r3, [r3, #14]
 812 0838 013043E2 		sub	r3, r3, #1
 813 083c 0338A0E1 		mov	r3, r3, asl #16
 814 0840 2328A0E1 		mov	r2, r3, lsr #16
 815 0844 18301BE5 		ldr	r3, [fp, #-24]
 816 0848 BE20C3E1 		strh	r2, [r3, #14]	@ movhi
 817 084c 18301BE5 		ldr	r3, [fp, #-24]
 818 0850 BE30D3E1 		ldrh	r3, [r3, #14]	@ movhi
 819 0854 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 566:./src/lwip/core/pbuf.c ****     SYS_ARCH_UNPROTECT(old_level);
 567:./src/lwip/core/pbuf.c ****     /* this pbuf is no longer referenced to? */
 568:./src/lwip/core/pbuf.c ****     if (ref == 0) {
 820              		.loc 1 568 0
 821 0858 B6305BE1 		ldrh	r3, [fp, #-6]
 822 085c 000053E3 		cmp	r3, #0
 823 0860 1E00001A 		bne	.L70
 569:./src/lwip/core/pbuf.c ****       /* remember next pbuf in chain for next iteration */
 570:./src/lwip/core/pbuf.c ****       q = p->next;
 824              		.loc 1 570 0
 825 0864 18301BE5 		ldr	r3, [fp, #-24]
 826 0868 003093E5 		ldr	r3, [r3, #0]
 827 086c 0C300BE5 		str	r3, [fp, #-12]
 571:./src/lwip/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
 572:./src/lwip/core/pbuf.c ****       type = p->type;
 828              		.loc 1 572 0
 829 0870 18301BE5 		ldr	r3, [fp, #-24]
 830 0874 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 831 0878 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 573:./src/lwip/core/pbuf.c ****       /* is this a pbuf from the pool? */
 574:./src/lwip/core/pbuf.c ****       if (type == PBUF_POOL) {
 832              		.loc 1 574 0
 833 087c BE305BE1 		ldrh	r3, [fp, #-14]
 834 0880 030053E3 		cmp	r3, #3
 835 0884 0300001A 		bne	.L71
 575:./src/lwip/core/pbuf.c ****         memp_free(MEMP_PBUF_POOL, p);
 836              		.loc 1 575 0
 837 0888 0C00A0E3 		mov	r0, #12
 838 088c 18101BE5 		ldr	r1, [fp, #-24]
 839 0890 FEFFFFEB 		bl	memp_free
 840 0894 0B0000EA 		b	.L72
 841              	.L71:
 576:./src/lwip/core/pbuf.c ****       /* is this a ROM or RAM referencing pbuf? */
 577:./src/lwip/core/pbuf.c ****       } else if (type == PBUF_ROM || type == PBUF_REF) {
 842              		.loc 1 577 0
 843 0898 BE305BE1 		ldrh	r3, [fp, #-14]
 844 089c 010053E3 		cmp	r3, #1
 845 08a0 0200000A 		beq	.L73
 846 08a4 BE305BE1 		ldrh	r3, [fp, #-14]
 847 08a8 020053E3 		cmp	r3, #2
 848 08ac 0300001A 		bne	.L74
 849              	.L73:
 578:./src/lwip/core/pbuf.c ****         memp_free(MEMP_PBUF, p);
 850              		.loc 1 578 0
 851 08b0 0B00A0E3 		mov	r0, #11
 852 08b4 18101BE5 		ldr	r1, [fp, #-24]
 853 08b8 FEFFFFEB 		bl	memp_free
 854              		.loc 1 577 0
 855 08bc 010000EA 		b	.L72
 856              	.L74:
 579:./src/lwip/core/pbuf.c ****       /* type == PBUF_RAM */
 580:./src/lwip/core/pbuf.c ****       } else {
 581:./src/lwip/core/pbuf.c ****         mem_free(p);
 857              		.loc 1 581 0
 858 08c0 18001BE5 		ldr	r0, [fp, #-24]
 859 08c4 FEFFFFEB 		bl	mem_free
 860              	.L72:
 582:./src/lwip/core/pbuf.c ****       }
 583:./src/lwip/core/pbuf.c ****       count++;
 861              		.loc 1 583 0
 862 08c8 07305BE5 		ldrb	r3, [fp, #-7]
 863 08cc 013083E2 		add	r3, r3, #1
 864 08d0 07304BE5 		strb	r3, [fp, #-7]
 584:./src/lwip/core/pbuf.c ****       /* proceed to next pbuf */
 585:./src/lwip/core/pbuf.c ****       p = q;
 865              		.loc 1 585 0
 866 08d4 0C301BE5 		ldr	r3, [fp, #-12]
 867 08d8 18300BE5 		str	r3, [fp, #-24]
 868 08dc 010000EA 		b	.L69
 869              	.L70:
 586:./src/lwip/core/pbuf.c ****     /* p->ref > 0, this pbuf is still referenced to */
 587:./src/lwip/core/pbuf.c ****     /* (and so the remaining pbufs in chain as well) */
 588:./src/lwip/core/pbuf.c ****     } else {
 589:./src/lwip/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", 
 590:./src/lwip/core/pbuf.c ****       /* stop walking through the chain */
 591:./src/lwip/core/pbuf.c ****       p = NULL;
 870              		.loc 1 591 0
 871 08e0 0030A0E3 		mov	r3, #0
 872 08e4 18300BE5 		str	r3, [fp, #-24]
 873              	.L69:
 874              	.LBE2:
 875              		.loc 1 555 0
 876 08e8 18301BE5 		ldr	r3, [fp, #-24]
 877 08ec 000053E3 		cmp	r3, #0
 878 08f0 CEFFFF1A 		bne	.L75
 592:./src/lwip/core/pbuf.c ****     }
 593:./src/lwip/core/pbuf.c ****   }
 594:./src/lwip/core/pbuf.c ****   PERF_STOP("pbuf_free");
 595:./src/lwip/core/pbuf.c ****   /* return number of de-allocated pbufs */
 596:./src/lwip/core/pbuf.c ****   return count;
 879              		.loc 1 596 0
 880 08f4 07305BE5 		ldrb	r3, [fp, #-7]	@ zero_extendqisi2
 881              	.L67:
 597:./src/lwip/core/pbuf.c **** }
 882              		.loc 1 597 0
 883 08f8 0300A0E1 		mov	r0, r3
 884 08fc 04D04BE2 		sub	sp, fp, #4
 885 0900 0048BDE8 		ldmfd	sp!, {fp, lr}
 886 0904 1EFF2FE1 		bx	lr
 887              	.LFE5:
 889              		.align	2
 890              		.global	pbuf_clen
 892              	pbuf_clen:
 893              	.LFB6:
 598:./src/lwip/core/pbuf.c **** 
 599:./src/lwip/core/pbuf.c **** /**
 600:./src/lwip/core/pbuf.c ****  * Count number of pbufs in a chain
 601:./src/lwip/core/pbuf.c ****  *
 602:./src/lwip/core/pbuf.c ****  * @param p first pbuf of chain
 603:./src/lwip/core/pbuf.c ****  * @return the number of pbufs in a chain
 604:./src/lwip/core/pbuf.c ****  */
 605:./src/lwip/core/pbuf.c **** 
 606:./src/lwip/core/pbuf.c **** u8_t
 607:./src/lwip/core/pbuf.c **** pbuf_clen(struct pbuf *p)
 608:./src/lwip/core/pbuf.c **** {
 894              		.loc 1 608 0
 895              		@ Function supports interworking.
 896              		@ args = 0, pretend = 0, frame = 16
 897              		@ frame_needed = 1, uses_anonymous_args = 0
 898              		@ link register save eliminated.
 899 0908 04B02DE5 		str	fp, [sp, #-4]!
 900              	.LCFI18:
 901 090c 00B08DE2 		add	fp, sp, #0
 902              	.LCFI19:
 903 0910 14D04DE2 		sub	sp, sp, #20
 904              	.LCFI20:
 905 0914 10000BE5 		str	r0, [fp, #-16]
 609:./src/lwip/core/pbuf.c ****   u8_t len;
 610:./src/lwip/core/pbuf.c **** 
 611:./src/lwip/core/pbuf.c ****   len = 0;
 906              		.loc 1 611 0
 907 0918 0030A0E3 		mov	r3, #0
 908 091c 05304BE5 		strb	r3, [fp, #-5]
 612:./src/lwip/core/pbuf.c ****   while (p != NULL) {
 909              		.loc 1 612 0
 910 0920 050000EA 		b	.L78
 911              	.L79:
 613:./src/lwip/core/pbuf.c ****     ++len;
 912              		.loc 1 613 0
 913 0924 05305BE5 		ldrb	r3, [fp, #-5]
 914 0928 013083E2 		add	r3, r3, #1
 915 092c 05304BE5 		strb	r3, [fp, #-5]
 614:./src/lwip/core/pbuf.c ****     p = p->next;
 916              		.loc 1 614 0
 917 0930 10301BE5 		ldr	r3, [fp, #-16]
 918 0934 003093E5 		ldr	r3, [r3, #0]
 919 0938 10300BE5 		str	r3, [fp, #-16]
 920              	.L78:
 921              		.loc 1 612 0
 922 093c 10301BE5 		ldr	r3, [fp, #-16]
 923 0940 000053E3 		cmp	r3, #0
 924 0944 F6FFFF1A 		bne	.L79
 615:./src/lwip/core/pbuf.c ****   }
 616:./src/lwip/core/pbuf.c ****   return len;
 925              		.loc 1 616 0
 926 0948 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 617:./src/lwip/core/pbuf.c **** }
 927              		.loc 1 617 0
 928 094c 0300A0E1 		mov	r0, r3
 929 0950 00D08BE2 		add	sp, fp, #0
 930 0954 0008BDE8 		ldmfd	sp!, {fp}
 931 0958 1EFF2FE1 		bx	lr
 932              	.LFE6:
 934              		.align	2
 935              		.global	pbuf_ref
 937              	pbuf_ref:
 938              	.LFB7:
 618:./src/lwip/core/pbuf.c **** 
 619:./src/lwip/core/pbuf.c **** /**
 620:./src/lwip/core/pbuf.c ****  * Increment the reference count of the pbuf.
 621:./src/lwip/core/pbuf.c ****  *
 622:./src/lwip/core/pbuf.c ****  * @param p pbuf to increase reference counter of
 623:./src/lwip/core/pbuf.c ****  *
 624:./src/lwip/core/pbuf.c ****  */
 625:./src/lwip/core/pbuf.c **** void
 626:./src/lwip/core/pbuf.c **** pbuf_ref(struct pbuf *p)
 627:./src/lwip/core/pbuf.c **** {
 939              		.loc 1 627 0
 940              		@ Function supports interworking.
 941              		@ args = 0, pretend = 0, frame = 8
 942              		@ frame_needed = 1, uses_anonymous_args = 0
 943              		@ link register save eliminated.
 944 095c 04B02DE5 		str	fp, [sp, #-4]!
 945              	.LCFI21:
 946 0960 00B08DE2 		add	fp, sp, #0
 947              	.LCFI22:
 948 0964 0CD04DE2 		sub	sp, sp, #12
 949              	.LCFI23:
 950 0968 08000BE5 		str	r0, [fp, #-8]
 628:./src/lwip/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 629:./src/lwip/core/pbuf.c ****   /* pbuf given? */
 630:./src/lwip/core/pbuf.c ****   if (p != NULL) {
 951              		.loc 1 630 0
 952 096c 08301BE5 		ldr	r3, [fp, #-8]
 953 0970 000053E3 		cmp	r3, #0
 954 0974 0600000A 		beq	.L83
 631:./src/lwip/core/pbuf.c ****     SYS_ARCH_PROTECT(old_level);
 632:./src/lwip/core/pbuf.c ****     ++(p->ref);
 955              		.loc 1 632 0
 956 0978 08301BE5 		ldr	r3, [fp, #-8]
 957 097c BE30D3E1 		ldrh	r3, [r3, #14]
 958 0980 013083E2 		add	r3, r3, #1
 959 0984 0338A0E1 		mov	r3, r3, asl #16
 960 0988 2328A0E1 		mov	r2, r3, lsr #16
 961 098c 08301BE5 		ldr	r3, [fp, #-8]
 962 0990 BE20C3E1 		strh	r2, [r3, #14]	@ movhi
 963              	.L83:
 633:./src/lwip/core/pbuf.c ****     SYS_ARCH_UNPROTECT(old_level);
 634:./src/lwip/core/pbuf.c ****   }
 635:./src/lwip/core/pbuf.c **** }
 964              		.loc 1 635 0
 965 0994 00D08BE2 		add	sp, fp, #0
 966 0998 0008BDE8 		ldmfd	sp!, {fp}
 967 099c 1EFF2FE1 		bx	lr
 968              	.LFE7:
 970              		.align	2
 971              		.global	pbuf_cat
 973              	pbuf_cat:
 974              	.LFB8:
 636:./src/lwip/core/pbuf.c **** 
 637:./src/lwip/core/pbuf.c **** /**
 638:./src/lwip/core/pbuf.c ****  * Concatenate two pbufs (each may be a pbuf chain) and take over
 639:./src/lwip/core/pbuf.c ****  * the caller's reference of the tail pbuf.
 640:./src/lwip/core/pbuf.c ****  * 
 641:./src/lwip/core/pbuf.c ****  * @note The caller MAY NOT reference the tail pbuf afterwards.
 642:./src/lwip/core/pbuf.c ****  * Use pbuf_chain() for that purpose.
 643:./src/lwip/core/pbuf.c ****  * 
 644:./src/lwip/core/pbuf.c ****  * @see pbuf_chain()
 645:./src/lwip/core/pbuf.c ****  */
 646:./src/lwip/core/pbuf.c **** 
 647:./src/lwip/core/pbuf.c **** void
 648:./src/lwip/core/pbuf.c **** pbuf_cat(struct pbuf *h, struct pbuf *t)
 649:./src/lwip/core/pbuf.c **** {
 975              		.loc 1 649 0
 976              		@ Function supports interworking.
 977              		@ args = 0, pretend = 0, frame = 16
 978              		@ frame_needed = 1, uses_anonymous_args = 0
 979              		@ link register save eliminated.
 980 09a0 04B02DE5 		str	fp, [sp, #-4]!
 981              	.LCFI24:
 982 09a4 00B08DE2 		add	fp, sp, #0
 983              	.LCFI25:
 984 09a8 14D04DE2 		sub	sp, sp, #20
 985              	.LCFI26:
 986 09ac 10000BE5 		str	r0, [fp, #-16]
 987 09b0 14100BE5 		str	r1, [fp, #-20]
 650:./src/lwip/core/pbuf.c ****   struct pbuf *p;
 651:./src/lwip/core/pbuf.c **** 
 652:./src/lwip/core/pbuf.c ****   LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 988              		.loc 1 652 0
 989 09b4 10301BE5 		ldr	r3, [fp, #-16]
 990 09b8 000053E3 		cmp	r3, #0
 991 09bc 2100000A 		beq	.L90
 992 09c0 14301BE5 		ldr	r3, [fp, #-20]
 993 09c4 000053E3 		cmp	r3, #0
 994 09c8 1E00000A 		beq	.L90
 995              	.L86:
 653:./src/lwip/core/pbuf.c ****              ((h != NULL) && (t != NULL)), return;);
 654:./src/lwip/core/pbuf.c **** 
 655:./src/lwip/core/pbuf.c ****   /* proceed to last pbuf of chain */
 656:./src/lwip/core/pbuf.c ****   for (p = h; p->next != NULL; p = p->next) {
 996              		.loc 1 656 0
 997 09cc 10301BE5 		ldr	r3, [fp, #-16]
 998 09d0 08300BE5 		str	r3, [fp, #-8]
 999 09d4 0B0000EA 		b	.L88
 1000              	.L89:
 657:./src/lwip/core/pbuf.c ****     /* add total length of second chain to all totals of first chain */
 658:./src/lwip/core/pbuf.c ****     p->tot_len += t->tot_len;
 1001              		.loc 1 658 0
 1002 09d8 08301BE5 		ldr	r3, [fp, #-8]
 1003 09dc B820D3E1 		ldrh	r2, [r3, #8]
 1004 09e0 14301BE5 		ldr	r3, [fp, #-20]
 1005 09e4 B830D3E1 		ldrh	r3, [r3, #8]
 1006 09e8 033082E0 		add	r3, r2, r3
 1007 09ec 0338A0E1 		mov	r3, r3, asl #16
 1008 09f0 2328A0E1 		mov	r2, r3, lsr #16
 1009 09f4 08301BE5 		ldr	r3, [fp, #-8]
 1010 09f8 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 1011              		.loc 1 656 0
 1012 09fc 08301BE5 		ldr	r3, [fp, #-8]
 1013 0a00 003093E5 		ldr	r3, [r3, #0]
 1014 0a04 08300BE5 		str	r3, [fp, #-8]
 1015              	.L88:
 1016 0a08 08301BE5 		ldr	r3, [fp, #-8]
 1017 0a0c 003093E5 		ldr	r3, [r3, #0]
 1018 0a10 000053E3 		cmp	r3, #0
 1019 0a14 EFFFFF1A 		bne	.L89
 659:./src/lwip/core/pbuf.c ****   }
 660:./src/lwip/core/pbuf.c ****   /* { p is last pbuf of first h chain, p->next == NULL } */
 661:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 662:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("p->next == NULL", p->next == NULL);
 663:./src/lwip/core/pbuf.c ****   /* add total length of second chain to last pbuf total of first chain */
 664:./src/lwip/core/pbuf.c ****   p->tot_len += t->tot_len;
 1020              		.loc 1 664 0
 1021 0a18 08301BE5 		ldr	r3, [fp, #-8]
 1022 0a1c B820D3E1 		ldrh	r2, [r3, #8]
 1023 0a20 14301BE5 		ldr	r3, [fp, #-20]
 1024 0a24 B830D3E1 		ldrh	r3, [r3, #8]
 1025 0a28 033082E0 		add	r3, r2, r3
 1026 0a2c 0338A0E1 		mov	r3, r3, asl #16
 1027 0a30 2328A0E1 		mov	r2, r3, lsr #16
 1028 0a34 08301BE5 		ldr	r3, [fp, #-8]
 1029 0a38 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 665:./src/lwip/core/pbuf.c ****   /* chain last pbuf of head (p) with first of tail (t) */
 666:./src/lwip/core/pbuf.c ****   p->next = t;
 1030              		.loc 1 666 0
 1031 0a3c 08301BE5 		ldr	r3, [fp, #-8]
 1032 0a40 14201BE5 		ldr	r2, [fp, #-20]
 1033 0a44 002083E5 		str	r2, [r3, #0]
 1034              	.L90:
 667:./src/lwip/core/pbuf.c ****   /* p->next now references t, but the caller will drop its reference to t,
 668:./src/lwip/core/pbuf.c ****    * so netto there is no change to the reference count of t.
 669:./src/lwip/core/pbuf.c ****    */
 670:./src/lwip/core/pbuf.c **** }
 1035              		.loc 1 670 0
 1036 0a48 00D08BE2 		add	sp, fp, #0
 1037 0a4c 0008BDE8 		ldmfd	sp!, {fp}
 1038 0a50 1EFF2FE1 		bx	lr
 1039              	.LFE8:
 1041              		.align	2
 1042              		.global	pbuf_chain
 1044              	pbuf_chain:
 1045              	.LFB9:
 671:./src/lwip/core/pbuf.c **** 
 672:./src/lwip/core/pbuf.c **** /**
 673:./src/lwip/core/pbuf.c ****  * Chain two pbufs (or pbuf chains) together.
 674:./src/lwip/core/pbuf.c ****  * 
 675:./src/lwip/core/pbuf.c ****  * The caller MUST call pbuf_free(t) once it has stopped
 676:./src/lwip/core/pbuf.c ****  * using it. Use pbuf_cat() instead if you no longer use t.
 677:./src/lwip/core/pbuf.c ****  * 
 678:./src/lwip/core/pbuf.c ****  * @param h head pbuf (chain)
 679:./src/lwip/core/pbuf.c ****  * @param t tail pbuf (chain)
 680:./src/lwip/core/pbuf.c ****  * @note The pbufs MUST belong to the same packet.
 681:./src/lwip/core/pbuf.c ****  * @note MAY NOT be called on a packet queue.
 682:./src/lwip/core/pbuf.c ****  *
 683:./src/lwip/core/pbuf.c ****  * The ->tot_len fields of all pbufs of the head chain are adjusted.
 684:./src/lwip/core/pbuf.c ****  * The ->next field of the last pbuf of the head chain is adjusted.
 685:./src/lwip/core/pbuf.c ****  * The ->ref field of the first pbuf of the tail chain is adjusted.
 686:./src/lwip/core/pbuf.c ****  *
 687:./src/lwip/core/pbuf.c ****  */
 688:./src/lwip/core/pbuf.c **** void
 689:./src/lwip/core/pbuf.c **** pbuf_chain(struct pbuf *h, struct pbuf *t)
 690:./src/lwip/core/pbuf.c **** {
 1046              		.loc 1 690 0
 1047              		@ Function supports interworking.
 1048              		@ args = 0, pretend = 0, frame = 8
 1049              		@ frame_needed = 1, uses_anonymous_args = 0
 1050 0a54 00482DE9 		stmfd	sp!, {fp, lr}
 1051              	.LCFI27:
 1052 0a58 04B08DE2 		add	fp, sp, #4
 1053              	.LCFI28:
 1054 0a5c 08D04DE2 		sub	sp, sp, #8
 1055              	.LCFI29:
 1056 0a60 08000BE5 		str	r0, [fp, #-8]
 1057 0a64 0C100BE5 		str	r1, [fp, #-12]
 691:./src/lwip/core/pbuf.c ****   pbuf_cat(h, t);
 1058              		.loc 1 691 0
 1059 0a68 08001BE5 		ldr	r0, [fp, #-8]
 1060 0a6c 0C101BE5 		ldr	r1, [fp, #-12]
 1061 0a70 FEFFFFEB 		bl	pbuf_cat
 692:./src/lwip/core/pbuf.c ****   /* t is now referenced by h */
 693:./src/lwip/core/pbuf.c ****   pbuf_ref(t);
 1062              		.loc 1 693 0
 1063 0a74 0C001BE5 		ldr	r0, [fp, #-12]
 1064 0a78 FEFFFFEB 		bl	pbuf_ref
 694:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t)
 695:./src/lwip/core/pbuf.c **** }
 1065              		.loc 1 695 0
 1066 0a7c 04D04BE2 		sub	sp, fp, #4
 1067 0a80 0048BDE8 		ldmfd	sp!, {fp, lr}
 1068 0a84 1EFF2FE1 		bx	lr
 1069              	.LFE9:
 1071              		.align	2
 1072              		.global	pbuf_dechain
 1074              	pbuf_dechain:
 1075              	.LFB10:
 696:./src/lwip/core/pbuf.c **** 
 697:./src/lwip/core/pbuf.c **** /**
 698:./src/lwip/core/pbuf.c ****  * Dechains the first pbuf from its succeeding pbufs in the chain.
 699:./src/lwip/core/pbuf.c ****  *
 700:./src/lwip/core/pbuf.c ****  * Makes p->tot_len field equal to p->len.
 701:./src/lwip/core/pbuf.c ****  * @param p pbuf to dechain
 702:./src/lwip/core/pbuf.c ****  * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 703:./src/lwip/core/pbuf.c ****  * @note May not be called on a packet queue.
 704:./src/lwip/core/pbuf.c ****  */
 705:./src/lwip/core/pbuf.c **** struct pbuf *
 706:./src/lwip/core/pbuf.c **** pbuf_dechain(struct pbuf *p)
 707:./src/lwip/core/pbuf.c **** {
 1076              		.loc 1 707 0
 1077              		@ Function supports interworking.
 1078              		@ args = 0, pretend = 0, frame = 16
 1079              		@ frame_needed = 1, uses_anonymous_args = 0
 1080 0a88 00482DE9 		stmfd	sp!, {fp, lr}
 1081              	.LCFI30:
 1082 0a8c 04B08DE2 		add	fp, sp, #4
 1083              	.LCFI31:
 1084 0a90 10D04DE2 		sub	sp, sp, #16
 1085              	.LCFI32:
 1086 0a94 10000BE5 		str	r0, [fp, #-16]
 708:./src/lwip/core/pbuf.c ****   struct pbuf *q;
 709:./src/lwip/core/pbuf.c ****   u8_t tail_gone = 1;
 1087              		.loc 1 709 0
 1088 0a98 0130A0E3 		mov	r3, #1
 1089 0a9c 05304BE5 		strb	r3, [fp, #-5]
 710:./src/lwip/core/pbuf.c ****   /* tail */
 711:./src/lwip/core/pbuf.c ****   q = p->next;
 1090              		.loc 1 711 0
 1091 0aa0 10301BE5 		ldr	r3, [fp, #-16]
 1092 0aa4 003093E5 		ldr	r3, [r3, #0]
 1093 0aa8 0C300BE5 		str	r3, [fp, #-12]
 712:./src/lwip/core/pbuf.c ****   /* pbuf has successor in chain? */
 713:./src/lwip/core/pbuf.c ****   if (q != NULL) {
 1094              		.loc 1 713 0
 1095 0aac 0C301BE5 		ldr	r3, [fp, #-12]
 1096 0ab0 000053E3 		cmp	r3, #0
 1097 0ab4 1300000A 		beq	.L94
 714:./src/lwip/core/pbuf.c ****     /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
 715:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 716:./src/lwip/core/pbuf.c ****     /* enforce invariant if assertion is disabled */
 717:./src/lwip/core/pbuf.c ****     q->tot_len = p->tot_len - p->len;
 1098              		.loc 1 717 0
 1099 0ab8 10301BE5 		ldr	r3, [fp, #-16]
 1100 0abc B820D3E1 		ldrh	r2, [r3, #8]
 1101 0ac0 10301BE5 		ldr	r3, [fp, #-16]
 1102 0ac4 BA30D3E1 		ldrh	r3, [r3, #10]
 1103 0ac8 023063E0 		rsb	r3, r3, r2
 1104 0acc 0338A0E1 		mov	r3, r3, asl #16
 1105 0ad0 2328A0E1 		mov	r2, r3, lsr #16
 1106 0ad4 0C301BE5 		ldr	r3, [fp, #-12]
 1107 0ad8 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 718:./src/lwip/core/pbuf.c ****     /* decouple pbuf from remainder */
 719:./src/lwip/core/pbuf.c ****     p->next = NULL;
 1108              		.loc 1 719 0
 1109 0adc 10301BE5 		ldr	r3, [fp, #-16]
 1110 0ae0 0020A0E3 		mov	r2, #0
 1111 0ae4 002083E5 		str	r2, [r3, #0]
 720:./src/lwip/core/pbuf.c ****     /* total length of pbuf p is its own length only */
 721:./src/lwip/core/pbuf.c ****     p->tot_len = p->len;
 1112              		.loc 1 721 0
 1113 0ae8 10301BE5 		ldr	r3, [fp, #-16]
 1114 0aec BA20D3E1 		ldrh	r2, [r3, #10]
 1115 0af0 10301BE5 		ldr	r3, [fp, #-16]
 1116 0af4 B820C3E1 		strh	r2, [r3, #8]	@ movhi
 722:./src/lwip/core/pbuf.c ****     /* q is no longer referenced by p, free it */
 723:./src/lwip/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
 724:./src/lwip/core/pbuf.c ****     tail_gone = pbuf_free(q);
 1117              		.loc 1 724 0
 1118 0af8 0C001BE5 		ldr	r0, [fp, #-12]
 1119 0afc FEFFFFEB 		bl	pbuf_free
 1120 0b00 0030A0E1 		mov	r3, r0
 1121 0b04 05304BE5 		strb	r3, [fp, #-5]
 1122              	.L94:
 725:./src/lwip/core/pbuf.c ****     if (tail_gone > 0) {
 726:./src/lwip/core/pbuf.c ****       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
 727:./src/lwip/core/pbuf.c ****                   ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
 728:./src/lwip/core/pbuf.c ****     }
 729:./src/lwip/core/pbuf.c ****     /* return remaining tail or NULL if deallocated */
 730:./src/lwip/core/pbuf.c ****   }
 731:./src/lwip/core/pbuf.c ****   /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
 732:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 733:./src/lwip/core/pbuf.c ****   return ((tail_gone > 0) ? NULL : q);
 1123              		.loc 1 733 0
 1124 0b08 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1125 0b0c 000053E3 		cmp	r3, #0
 1126 0b10 0100001A 		bne	.L95
 1127 0b14 0C301BE5 		ldr	r3, [fp, #-12]
 1128 0b18 000000EA 		b	.L96
 1129              	.L95:
 1130 0b1c 0030A0E3 		mov	r3, #0
 1131              	.L96:
 734:./src/lwip/core/pbuf.c **** }
 1132              		.loc 1 734 0
 1133 0b20 0300A0E1 		mov	r0, r3
 1134 0b24 04D04BE2 		sub	sp, fp, #4
 1135 0b28 0048BDE8 		ldmfd	sp!, {fp, lr}
 1136 0b2c 1EFF2FE1 		bx	lr
 1137              	.LFE10:
 1139              		.align	2
 1140              		.global	pbuf_copy
 1142              	pbuf_copy:
 1143              	.LFB11:
 735:./src/lwip/core/pbuf.c **** 
 736:./src/lwip/core/pbuf.c **** /**
 737:./src/lwip/core/pbuf.c ****  *
 738:./src/lwip/core/pbuf.c ****  * Create PBUF_RAM copies of pbufs.
 739:./src/lwip/core/pbuf.c ****  *
 740:./src/lwip/core/pbuf.c ****  * Used to queue packets on behalf of the lwIP stack, such as
 741:./src/lwip/core/pbuf.c ****  * ARP based queueing.
 742:./src/lwip/core/pbuf.c ****  *
 743:./src/lwip/core/pbuf.c ****  * @note You MUST explicitly use p = pbuf_take(p);
 744:./src/lwip/core/pbuf.c ****  *
 745:./src/lwip/core/pbuf.c ****  * @note Only one packet is copied, no packet queue!
 746:./src/lwip/core/pbuf.c ****  *
 747:./src/lwip/core/pbuf.c ****  * @param p_to pbuf destination of the copy
 748:./src/lwip/core/pbuf.c ****  * @param p_from pbuf source of the copy
 749:./src/lwip/core/pbuf.c ****  *
 750:./src/lwip/core/pbuf.c ****  * @return ERR_OK if pbuf was copied
 751:./src/lwip/core/pbuf.c ****  *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 752:./src/lwip/core/pbuf.c ****  *                 enough to hold p_from
 753:./src/lwip/core/pbuf.c ****  */
 754:./src/lwip/core/pbuf.c **** err_t
 755:./src/lwip/core/pbuf.c **** pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
 756:./src/lwip/core/pbuf.c **** {
 1144              		.loc 1 756 0
 1145              		@ Function supports interworking.
 1146              		@ args = 0, pretend = 0, frame = 16
 1147              		@ frame_needed = 1, uses_anonymous_args = 0
 1148 0b30 00482DE9 		stmfd	sp!, {fp, lr}
 1149              	.LCFI33:
 1150 0b34 04B08DE2 		add	fp, sp, #4
 1151              	.LCFI34:
 1152 0b38 10D04DE2 		sub	sp, sp, #16
 1153              	.LCFI35:
 1154 0b3c 10000BE5 		str	r0, [fp, #-16]
 1155 0b40 14100BE5 		str	r1, [fp, #-20]
 757:./src/lwip/core/pbuf.c ****   u16_t offset_to=0, offset_from=0, len;
 1156              		.loc 1 757 0
 1157 0b44 0030A0E3 		mov	r3, #0
 1158 0b48 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 1159 0b4c 0030A0E3 		mov	r3, #0
 1160 0b50 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 758:./src/lwip/core/pbuf.c **** 
 759:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
 760:./src/lwip/core/pbuf.c ****     (void*)p_to, (void*)p_from));
 761:./src/lwip/core/pbuf.c **** 
 762:./src/lwip/core/pbuf.c ****   /* is the target big enough to hold the source? */
 763:./src/lwip/core/pbuf.c ****   LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 1161              		.loc 1 763 0
 1162 0b54 10301BE5 		ldr	r3, [fp, #-16]
 1163 0b58 000053E3 		cmp	r3, #0
 1164 0b5c 0800000A 		beq	.L99
 1165 0b60 14301BE5 		ldr	r3, [fp, #-20]
 1166 0b64 000053E3 		cmp	r3, #0
 1167 0b68 0500000A 		beq	.L99
 1168 0b6c 10301BE5 		ldr	r3, [fp, #-16]
 1169 0b70 B820D3E1 		ldrh	r2, [r3, #8]
 1170 0b74 14301BE5 		ldr	r3, [fp, #-20]
 1171 0b78 B830D3E1 		ldrh	r3, [r3, #8]
 1172 0b7c 030052E1 		cmp	r2, r3
 1173 0b80 0100002A 		bcs	.L100
 1174              	.L99:
 1175 0b84 F630A0E3 		mov	r3, #246
 1176 0b88 610000EA 		b	.L101
 1177              	.L100:
 764:./src/lwip/core/pbuf.c ****              (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
 765:./src/lwip/core/pbuf.c **** 
 766:./src/lwip/core/pbuf.c ****   /* iterate through pbuf chain */
 767:./src/lwip/core/pbuf.c ****   do
 768:./src/lwip/core/pbuf.c ****   {
 769:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("p_to != NULL", p_to != NULL);
 770:./src/lwip/core/pbuf.c ****     /* copy one part of the original chain */
 771:./src/lwip/core/pbuf.c ****     if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 1178              		.loc 1 771 0
 1179 0b8c 10301BE5 		ldr	r3, [fp, #-16]
 1180 0b90 BA30D3E1 		ldrh	r3, [r3, #10]
 1181 0b94 0320A0E1 		mov	r2, r3
 1182 0b98 BA305BE1 		ldrh	r3, [fp, #-10]
 1183 0b9c 022063E0 		rsb	r2, r3, r2
 1184 0ba0 14301BE5 		ldr	r3, [fp, #-20]
 1185 0ba4 BA30D3E1 		ldrh	r3, [r3, #10]
 1186 0ba8 0310A0E1 		mov	r1, r3
 1187 0bac B8305BE1 		ldrh	r3, [fp, #-8]
 1188 0bb0 013063E0 		rsb	r3, r3, r1
 1189 0bb4 030052E1 		cmp	r2, r3
 1190 0bb8 050000BA 		blt	.L102
 772:./src/lwip/core/pbuf.c ****       /* complete current p_from fits into current p_to */
 773:./src/lwip/core/pbuf.c ****       len = p_from->len - offset_from;
 1191              		.loc 1 773 0
 1192 0bbc 14301BE5 		ldr	r3, [fp, #-20]
 1193 0bc0 BA20D3E1 		ldrh	r2, [r3, #10]
 1194 0bc4 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 1195 0bc8 023063E0 		rsb	r3, r3, r2
 1196 0bcc B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1197 0bd0 040000EA 		b	.L103
 1198              	.L102:
 774:./src/lwip/core/pbuf.c ****     } else {
 775:./src/lwip/core/pbuf.c ****       /* current p_from does not fit into current p_to */
 776:./src/lwip/core/pbuf.c ****       len = p_to->len - offset_to;
 1199              		.loc 1 776 0
 1200 0bd4 10301BE5 		ldr	r3, [fp, #-16]
 1201 0bd8 BA20D3E1 		ldrh	r2, [r3, #10]
 1202 0bdc BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 1203 0be0 023063E0 		rsb	r3, r3, r2
 1204 0be4 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1205              	.L103:
 777:./src/lwip/core/pbuf.c ****     }
 778:./src/lwip/core/pbuf.c ****     MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 1206              		.loc 1 778 0
 1207 0be8 10301BE5 		ldr	r3, [fp, #-16]
 1208 0bec 042093E5 		ldr	r2, [r3, #4]
 1209 0bf0 BA305BE1 		ldrh	r3, [fp, #-10]
 1210 0bf4 031082E0 		add	r1, r2, r3
 1211 0bf8 14301BE5 		ldr	r3, [fp, #-20]
 1212 0bfc 042093E5 		ldr	r2, [r3, #4]
 1213 0c00 B8305BE1 		ldrh	r3, [fp, #-8]
 1214 0c04 032082E0 		add	r2, r2, r3
 1215 0c08 B6305BE1 		ldrh	r3, [fp, #-6]
 1216 0c0c 0100A0E1 		mov	r0, r1
 1217 0c10 0210A0E1 		mov	r1, r2
 1218 0c14 0320A0E1 		mov	r2, r3
 1219 0c18 FEFFFFEB 		bl	memcpy
 779:./src/lwip/core/pbuf.c ****     offset_to += len;
 1220              		.loc 1 779 0
 1221 0c1c BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 1222 0c20 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1223 0c24 033082E0 		add	r3, r2, r3
 1224 0c28 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 780:./src/lwip/core/pbuf.c ****     offset_from += len;
 1225              		.loc 1 780 0
 1226 0c2c B8205BE1 		ldrh	r2, [fp, #-8]	@ movhi
 1227 0c30 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 1228 0c34 033082E0 		add	r3, r2, r3
 1229 0c38 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 781:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 782:./src/lwip/core/pbuf.c ****     if (offset_to == p_to->len) {
 1230              		.loc 1 782 0
 1231 0c3c 10301BE5 		ldr	r3, [fp, #-16]
 1232 0c40 BA30D3E1 		ldrh	r3, [r3, #10]
 1233 0c44 BA205BE1 		ldrh	r2, [fp, #-10]
 1234 0c48 030052E1 		cmp	r2, r3
 1235 0c4c 0400001A 		bne	.L104
 783:./src/lwip/core/pbuf.c ****       /* on to next p_to (if any) */
 784:./src/lwip/core/pbuf.c ****       offset_to = 0;
 1236              		.loc 1 784 0
 1237 0c50 0030A0E3 		mov	r3, #0
 1238 0c54 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 785:./src/lwip/core/pbuf.c ****       p_to = p_to->next;
 1239              		.loc 1 785 0
 1240 0c58 10301BE5 		ldr	r3, [fp, #-16]
 1241 0c5c 003093E5 		ldr	r3, [r3, #0]
 1242 0c60 10300BE5 		str	r3, [fp, #-16]
 1243              	.L104:
 786:./src/lwip/core/pbuf.c ****     }
 787:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 788:./src/lwip/core/pbuf.c ****     if (offset_from >= p_from->len) {
 1244              		.loc 1 788 0
 1245 0c64 14301BE5 		ldr	r3, [fp, #-20]
 1246 0c68 BA30D3E1 		ldrh	r3, [r3, #10]
 1247 0c6c B8205BE1 		ldrh	r2, [fp, #-8]
 1248 0c70 030052E1 		cmp	r2, r3
 1249 0c74 0400003A 		bcc	.L105
 789:./src/lwip/core/pbuf.c ****       /* on to next p_from (if any) */
 790:./src/lwip/core/pbuf.c ****       offset_from = 0;
 1250              		.loc 1 790 0
 1251 0c78 0030A0E3 		mov	r3, #0
 1252 0c7c B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 791:./src/lwip/core/pbuf.c ****       p_from = p_from->next;
 1253              		.loc 1 791 0
 1254 0c80 14301BE5 		ldr	r3, [fp, #-20]
 1255 0c84 003093E5 		ldr	r3, [r3, #0]
 1256 0c88 14300BE5 		str	r3, [fp, #-20]
 1257              	.L105:
 792:./src/lwip/core/pbuf.c ****     }
 793:./src/lwip/core/pbuf.c **** 
 794:./src/lwip/core/pbuf.c ****     if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 1258              		.loc 1 794 0
 1259 0c8c 14301BE5 		ldr	r3, [fp, #-20]
 1260 0c90 000053E3 		cmp	r3, #0
 1261 0c94 0B00000A 		beq	.L106
 1262 0c98 14301BE5 		ldr	r3, [fp, #-20]
 1263 0c9c BA20D3E1 		ldrh	r2, [r3, #10]
 1264 0ca0 14301BE5 		ldr	r3, [fp, #-20]
 1265 0ca4 B830D3E1 		ldrh	r3, [r3, #8]
 1266 0ca8 030052E1 		cmp	r2, r3
 1267 0cac 0500001A 		bne	.L106
 795:./src/lwip/core/pbuf.c ****       /* don't copy more than one packet! */
 796:./src/lwip/core/pbuf.c ****       LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 1268              		.loc 1 796 0
 1269 0cb0 14301BE5 		ldr	r3, [fp, #-20]
 1270 0cb4 003093E5 		ldr	r3, [r3, #0]
 1271 0cb8 000053E3 		cmp	r3, #0
 1272 0cbc 0100000A 		beq	.L106
 1273 0cc0 F730A0E3 		mov	r3, #247
 1274 0cc4 120000EA 		b	.L101
 1275              	.L106:
 797:./src/lwip/core/pbuf.c ****                  (p_from->next == NULL), return ERR_VAL;);
 798:./src/lwip/core/pbuf.c ****     }
 799:./src/lwip/core/pbuf.c ****     if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 1276              		.loc 1 799 0
 1277 0cc8 10301BE5 		ldr	r3, [fp, #-16]
 1278 0ccc 000053E3 		cmp	r3, #0
 1279 0cd0 0B00000A 		beq	.L107
 1280 0cd4 10301BE5 		ldr	r3, [fp, #-16]
 1281 0cd8 BA20D3E1 		ldrh	r2, [r3, #10]
 1282 0cdc 10301BE5 		ldr	r3, [fp, #-16]
 1283 0ce0 B830D3E1 		ldrh	r3, [r3, #8]
 1284 0ce4 030052E1 		cmp	r2, r3
 1285 0ce8 0500001A 		bne	.L107
 800:./src/lwip/core/pbuf.c ****       /* don't copy more than one packet! */
 801:./src/lwip/core/pbuf.c ****       LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 1286              		.loc 1 801 0
 1287 0cec 10301BE5 		ldr	r3, [fp, #-16]
 1288 0cf0 003093E5 		ldr	r3, [r3, #0]
 1289 0cf4 000053E3 		cmp	r3, #0
 1290 0cf8 0100000A 		beq	.L107
 1291 0cfc F730A0E3 		mov	r3, #247
 1292 0d00 030000EA 		b	.L101
 1293              	.L107:
 802:./src/lwip/core/pbuf.c ****                   (p_to->next == NULL), return ERR_VAL;);
 803:./src/lwip/core/pbuf.c ****     }
 804:./src/lwip/core/pbuf.c ****   } while (p_from);
 1294              		.loc 1 804 0
 1295 0d04 14301BE5 		ldr	r3, [fp, #-20]
 1296 0d08 000053E3 		cmp	r3, #0
 1297 0d0c 9EFFFF1A 		bne	.L100
 805:./src/lwip/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
 806:./src/lwip/core/pbuf.c ****   return ERR_OK;
 1298              		.loc 1 806 0
 1299 0d10 0030A0E3 		mov	r3, #0
 1300              	.L101:
 1301 0d14 033CA0E1 		mov	r3, r3, asl #24
 1302 0d18 433CA0E1 		mov	r3, r3, asr #24
 807:./src/lwip/core/pbuf.c **** }
 1303              		.loc 1 807 0
 1304 0d1c 0300A0E1 		mov	r0, r3
 1305 0d20 04D04BE2 		sub	sp, fp, #4
 1306 0d24 0048BDE8 		ldmfd	sp!, {fp, lr}
 1307 0d28 1EFF2FE1 		bx	lr
 1308              	.LFE11:
 1310              		.align	2
 1311              		.global	pbuf_copy_partial
 1313              	pbuf_copy_partial:
 1314              	.LFB12:
 808:./src/lwip/core/pbuf.c **** 
 809:./src/lwip/core/pbuf.c **** /**
 810:./src/lwip/core/pbuf.c ****  * Copy (part of) the contents of a packet buffer
 811:./src/lwip/core/pbuf.c ****  * to an application supplied buffer.
 812:./src/lwip/core/pbuf.c ****  *
 813:./src/lwip/core/pbuf.c ****  * @param buf the pbuf from which to copy data
 814:./src/lwip/core/pbuf.c ****  * @param dataptr the application supplied buffer
 815:./src/lwip/core/pbuf.c ****  * @param len length of data to copy (dataptr must be big enough). No more 
 816:./src/lwip/core/pbuf.c ****  * than buf->tot_len will be copied, irrespective of len
 817:./src/lwip/core/pbuf.c ****  * @param offset offset into the packet buffer from where to begin copying len bytes
 818:./src/lwip/core/pbuf.c ****  * @return the number of bytes copied, or 0 on failure
 819:./src/lwip/core/pbuf.c ****  */
 820:./src/lwip/core/pbuf.c **** u16_t
 821:./src/lwip/core/pbuf.c **** pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
 822:./src/lwip/core/pbuf.c **** {
 1315              		.loc 1 822 0
 1316              		@ Function supports interworking.
 1317              		@ args = 0, pretend = 0, frame = 32
 1318              		@ frame_needed = 1, uses_anonymous_args = 0
 1319 0d2c 00482DE9 		stmfd	sp!, {fp, lr}
 1320              	.LCFI36:
 1321 0d30 04B08DE2 		add	fp, sp, #4
 1322              	.LCFI37:
 1323 0d34 20D04DE2 		sub	sp, sp, #32
 1324              	.LCFI38:
 1325 0d38 18000BE5 		str	r0, [fp, #-24]
 1326 0d3c 1C100BE5 		str	r1, [fp, #-28]
 1327 0d40 BE214BE1 		strh	r2, [fp, #-30]	@ movhi
 1328 0d44 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
 823:./src/lwip/core/pbuf.c ****   struct pbuf *p;
 824:./src/lwip/core/pbuf.c ****   u16_t left;
 825:./src/lwip/core/pbuf.c ****   u16_t buf_copy_len;
 826:./src/lwip/core/pbuf.c ****   u16_t copied_total = 0;
 1329              		.loc 1 826 0
 1330 0d48 0030A0E3 		mov	r3, #0
 1331 0d4c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 827:./src/lwip/core/pbuf.c **** 
 828:./src/lwip/core/pbuf.c ****   LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 1332              		.loc 1 828 0
 1333 0d50 18301BE5 		ldr	r3, [fp, #-24]
 1334 0d54 000053E3 		cmp	r3, #0
 1335 0d58 0100001A 		bne	.L110
 1336 0d5c 0030A0E3 		mov	r3, #0
 1337 0d60 4E0000EA 		b	.L111
 1338              	.L110:
 829:./src/lwip/core/pbuf.c ****   LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 1339              		.loc 1 829 0
 1340 0d64 1C301BE5 		ldr	r3, [fp, #-28]
 1341 0d68 000053E3 		cmp	r3, #0
 1342 0d6c 0100001A 		bne	.L112
 1343 0d70 0030A0E3 		mov	r3, #0
 1344 0d74 490000EA 		b	.L111
 1345              	.L112:
 830:./src/lwip/core/pbuf.c **** 
 831:./src/lwip/core/pbuf.c ****   left = 0;
 1346              		.loc 1 831 0
 1347 0d78 0030A0E3 		mov	r3, #0
 1348 0d7c BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 832:./src/lwip/core/pbuf.c **** 
 833:./src/lwip/core/pbuf.c ****   if((buf == NULL) || (dataptr == NULL)) {
 1349              		.loc 1 833 0
 1350 0d80 18301BE5 		ldr	r3, [fp, #-24]
 1351 0d84 000053E3 		cmp	r3, #0
 1352 0d88 0200000A 		beq	.L113
 1353 0d8c 1C301BE5 		ldr	r3, [fp, #-28]
 1354 0d90 000053E3 		cmp	r3, #0
 1355 0d94 0100001A 		bne	.L114
 1356              	.L113:
 834:./src/lwip/core/pbuf.c ****     return 0;
 1357              		.loc 1 834 0
 1358 0d98 0030A0E3 		mov	r3, #0
 1359 0d9c 3F0000EA 		b	.L111
 1360              	.L114:
 835:./src/lwip/core/pbuf.c ****   }
 836:./src/lwip/core/pbuf.c **** 
 837:./src/lwip/core/pbuf.c ****   /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. 
 838:./src/lwip/core/pbuf.c ****   for(p = buf; len != 0 && p != NULL; p = p->next) {
 1361              		.loc 1 838 0
 1362 0da0 18301BE5 		ldr	r3, [fp, #-24]
 1363 0da4 10300BE5 		str	r3, [fp, #-16]
 1364 0da8 350000EA 		b	.L115
 1365              	.L120:
 839:./src/lwip/core/pbuf.c ****     if ((offset != 0) && (offset >= p->len)) {
 1366              		.loc 1 839 0
 1367 0dac B0325BE1 		ldrh	r3, [fp, #-32]
 1368 0db0 000053E3 		cmp	r3, #0
 1369 0db4 0A00000A 		beq	.L116
 1370 0db8 10301BE5 		ldr	r3, [fp, #-16]
 1371 0dbc BA30D3E1 		ldrh	r3, [r3, #10]
 1372 0dc0 B0225BE1 		ldrh	r2, [fp, #-32]
 1373 0dc4 030052E1 		cmp	r2, r3
 1374 0dc8 0500003A 		bcc	.L116
 840:./src/lwip/core/pbuf.c ****       /* don't copy from this buffer -> on to the next */
 841:./src/lwip/core/pbuf.c ****       offset -= p->len;
 1375              		.loc 1 841 0
 1376 0dcc 10301BE5 		ldr	r3, [fp, #-16]
 1377 0dd0 BA30D3E1 		ldrh	r3, [r3, #10]
 1378 0dd4 B0225BE1 		ldrh	r2, [fp, #-32]	@ movhi
 1379 0dd8 023063E0 		rsb	r3, r3, r2
 1380 0ddc B0324BE1 		strh	r3, [fp, #-32]	@ movhi
 1381              		.loc 1 839 0
 1382 0de0 240000EA 		b	.L117
 1383              	.L116:
 842:./src/lwip/core/pbuf.c ****     } else {
 843:./src/lwip/core/pbuf.c ****       /* copy from this buffer. maybe only partially. */
 844:./src/lwip/core/pbuf.c ****       buf_copy_len = p->len - offset;
 1384              		.loc 1 844 0
 1385 0de4 10301BE5 		ldr	r3, [fp, #-16]
 1386 0de8 BA20D3E1 		ldrh	r2, [r3, #10]
 1387 0dec B0325BE1 		ldrh	r3, [fp, #-32]	@ movhi
 1388 0df0 023063E0 		rsb	r3, r3, r2
 1389 0df4 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 845:./src/lwip/core/pbuf.c ****       if (buf_copy_len > len)
 1390              		.loc 1 845 0
 1391 0df8 B8205BE1 		ldrh	r2, [fp, #-8]
 1392 0dfc BE315BE1 		ldrh	r3, [fp, #-30]
 1393 0e00 030052E1 		cmp	r2, r3
 1394 0e04 0100009A 		bls	.L118
 846:./src/lwip/core/pbuf.c ****           buf_copy_len = len;
 1395              		.loc 1 846 0
 1396 0e08 BE315BE1 		ldrh	r3, [fp, #-30]	@ movhi
 1397 0e0c B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 1398              	.L118:
 847:./src/lwip/core/pbuf.c ****       /* copy the necessary parts of the buffer */
 848:./src/lwip/core/pbuf.c ****       MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 1399              		.loc 1 848 0
 1400 0e10 BA205BE1 		ldrh	r2, [fp, #-10]
 1401 0e14 1C301BE5 		ldr	r3, [fp, #-28]
 1402 0e18 031082E0 		add	r1, r2, r3
 1403 0e1c 10301BE5 		ldr	r3, [fp, #-16]
 1404 0e20 042093E5 		ldr	r2, [r3, #4]
 1405 0e24 B0325BE1 		ldrh	r3, [fp, #-32]
 1406 0e28 032082E0 		add	r2, r2, r3
 1407 0e2c B8305BE1 		ldrh	r3, [fp, #-8]
 1408 0e30 0100A0E1 		mov	r0, r1
 1409 0e34 0210A0E1 		mov	r1, r2
 1410 0e38 0320A0E1 		mov	r2, r3
 1411 0e3c FEFFFFEB 		bl	memcpy
 849:./src/lwip/core/pbuf.c ****       copied_total += buf_copy_len;
 1412              		.loc 1 849 0
 1413 0e40 B6205BE1 		ldrh	r2, [fp, #-6]	@ movhi
 1414 0e44 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 1415 0e48 033082E0 		add	r3, r2, r3
 1416 0e4c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 850:./src/lwip/core/pbuf.c ****       left += buf_copy_len;
 1417              		.loc 1 850 0
 1418 0e50 BA205BE1 		ldrh	r2, [fp, #-10]	@ movhi
 1419 0e54 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 1420 0e58 033082E0 		add	r3, r2, r3
 1421 0e5c BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 851:./src/lwip/core/pbuf.c ****       len -= buf_copy_len;
 1422              		.loc 1 851 0
 1423 0e60 BE215BE1 		ldrh	r2, [fp, #-30]	@ movhi
 1424 0e64 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 1425 0e68 023063E0 		rsb	r3, r3, r2
 1426 0e6c BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 852:./src/lwip/core/pbuf.c ****       offset = 0;
 1427              		.loc 1 852 0
 1428 0e70 0030A0E3 		mov	r3, #0
 1429 0e74 B0324BE1 		strh	r3, [fp, #-32]	@ movhi
 1430              	.L117:
 1431              		.loc 1 838 0
 1432 0e78 10301BE5 		ldr	r3, [fp, #-16]
 1433 0e7c 003093E5 		ldr	r3, [r3, #0]
 1434 0e80 10300BE5 		str	r3, [fp, #-16]
 1435              	.L115:
 1436 0e84 BE315BE1 		ldrh	r3, [fp, #-30]
 1437 0e88 000053E3 		cmp	r3, #0
 1438 0e8c 0200000A 		beq	.L119
 1439 0e90 10301BE5 		ldr	r3, [fp, #-16]
 1440 0e94 000053E3 		cmp	r3, #0
 1441 0e98 C3FFFF1A 		bne	.L120
 1442              	.L119:
 853:./src/lwip/core/pbuf.c ****     }
 854:./src/lwip/core/pbuf.c ****   }
 855:./src/lwip/core/pbuf.c ****   return copied_total;
 1443              		.loc 1 855 0
 1444 0e9c B6305BE1 		ldrh	r3, [fp, #-6]
 1445              	.L111:
 856:./src/lwip/core/pbuf.c **** }
 1446              		.loc 1 856 0
 1447 0ea0 0300A0E1 		mov	r0, r3
 1448 0ea4 04D04BE2 		sub	sp, fp, #4
 1449 0ea8 0048BDE8 		ldmfd	sp!, {fp, lr}
 1450 0eac 1EFF2FE1 		bx	lr
 1451              	.LFE12:
 1453              		.align	2
 1454              		.global	pbuf_take
 1456              	pbuf_take:
 1457              	.LFB13:
 857:./src/lwip/core/pbuf.c **** 
 858:./src/lwip/core/pbuf.c **** /**
 859:./src/lwip/core/pbuf.c ****  * Copy application supplied data into a pbuf.
 860:./src/lwip/core/pbuf.c ****  * This function can only be used to copy the equivalent of buf->tot_len data.
 861:./src/lwip/core/pbuf.c ****  *
 862:./src/lwip/core/pbuf.c ****  * @param buf pbuf to fill with data
 863:./src/lwip/core/pbuf.c ****  * @param dataptr application supplied data buffer
 864:./src/lwip/core/pbuf.c ****  * @param len length of the application supplied data buffer
 865:./src/lwip/core/pbuf.c ****  *
 866:./src/lwip/core/pbuf.c ****  * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 867:./src/lwip/core/pbuf.c ****  */
 868:./src/lwip/core/pbuf.c **** err_t
 869:./src/lwip/core/pbuf.c **** pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
 870:./src/lwip/core/pbuf.c **** {
 1458              		.loc 1 870 0
 1459              		@ Function supports interworking.
 1460              		@ args = 0, pretend = 0, frame = 32
 1461              		@ frame_needed = 1, uses_anonymous_args = 0
 1462 0eb0 00482DE9 		stmfd	sp!, {fp, lr}
 1463              	.LCFI39:
 1464 0eb4 04B08DE2 		add	fp, sp, #4
 1465              	.LCFI40:
 1466 0eb8 20D04DE2 		sub	sp, sp, #32
 1467              	.LCFI41:
 1468 0ebc 18000BE5 		str	r0, [fp, #-24]
 1469 0ec0 1C100BE5 		str	r1, [fp, #-28]
 1470 0ec4 0230A0E1 		mov	r3, r2
 1471 0ec8 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 871:./src/lwip/core/pbuf.c ****   struct pbuf *p;
 872:./src/lwip/core/pbuf.c ****   u16_t buf_copy_len;
 873:./src/lwip/core/pbuf.c ****   u16_t total_copy_len = len;
 1472              		.loc 1 873 0
 1473 0ecc BE315BE1 		ldrh	r3, [fp, #-30]	@ movhi
 1474 0ed0 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 874:./src/lwip/core/pbuf.c ****   u16_t copied_total = 0;
 1475              		.loc 1 874 0
 1476 0ed4 0030A0E3 		mov	r3, #0
 1477 0ed8 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 875:./src/lwip/core/pbuf.c **** 
 876:./src/lwip/core/pbuf.c ****   LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 1478              		.loc 1 876 0
 1479 0edc 18301BE5 		ldr	r3, [fp, #-24]
 1480 0ee0 000053E3 		cmp	r3, #0
 1481 0ee4 0100001A 		bne	.L123
 1482 0ee8 0030A0E3 		mov	r3, #0
 1483 0eec 390000EA 		b	.L124
 1484              	.L123:
 877:./src/lwip/core/pbuf.c ****   LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 1485              		.loc 1 877 0
 1486 0ef0 1C301BE5 		ldr	r3, [fp, #-28]
 1487 0ef4 000053E3 		cmp	r3, #0
 1488 0ef8 0100001A 		bne	.L125
 1489 0efc 0030A0E3 		mov	r3, #0
 1490 0f00 340000EA 		b	.L124
 1491              	.L125:
 878:./src/lwip/core/pbuf.c **** 
 879:./src/lwip/core/pbuf.c ****   if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 1492              		.loc 1 879 0
 1493 0f04 18301BE5 		ldr	r3, [fp, #-24]
 1494 0f08 000053E3 		cmp	r3, #0
 1495 0f0c 0700000A 		beq	.L126
 1496 0f10 1C301BE5 		ldr	r3, [fp, #-28]
 1497 0f14 000053E3 		cmp	r3, #0
 1498 0f18 0400000A 		beq	.L126
 1499 0f1c 18301BE5 		ldr	r3, [fp, #-24]
 1500 0f20 B830D3E1 		ldrh	r3, [r3, #8]
 1501 0f24 BE215BE1 		ldrh	r2, [fp, #-30]
 1502 0f28 030052E1 		cmp	r2, r3
 1503 0f2c 0100009A 		bls	.L127
 1504              	.L126:
 880:./src/lwip/core/pbuf.c ****     return ERR_ARG;
 1505              		.loc 1 880 0
 1506 0f30 F630A0E3 		mov	r3, #246
 1507 0f34 270000EA 		b	.L124
 1508              	.L127:
 881:./src/lwip/core/pbuf.c ****   }
 882:./src/lwip/core/pbuf.c **** 
 883:./src/lwip/core/pbuf.c ****   /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. 
 884:./src/lwip/core/pbuf.c ****   for(p = buf; total_copy_len != 0; p = p->next) {
 1509              		.loc 1 884 0
 1510 0f38 18301BE5 		ldr	r3, [fp, #-24]
 1511 0f3c 10300BE5 		str	r3, [fp, #-16]
 1512 0f40 1E0000EA 		b	.L128
 1513              	.L130:
 885:./src/lwip/core/pbuf.c ****     LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 886:./src/lwip/core/pbuf.c ****     buf_copy_len = total_copy_len;
 1514              		.loc 1 886 0
 1515 0f44 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 1516 0f48 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 887:./src/lwip/core/pbuf.c ****     if (buf_copy_len > p->len) {
 1517              		.loc 1 887 0
 1518 0f4c 10301BE5 		ldr	r3, [fp, #-16]
 1519 0f50 BA30D3E1 		ldrh	r3, [r3, #10]
 1520 0f54 BA205BE1 		ldrh	r2, [fp, #-10]
 1521 0f58 030052E1 		cmp	r2, r3
 1522 0f5c 0200009A 		bls	.L129
 888:./src/lwip/core/pbuf.c ****       /* this pbuf cannot hold all remaining data */
 889:./src/lwip/core/pbuf.c ****       buf_copy_len = p->len;
 1523              		.loc 1 889 0
 1524 0f60 10301BE5 		ldr	r3, [fp, #-16]
 1525 0f64 BA30D3E1 		ldrh	r3, [r3, #10]	@ movhi
 1526 0f68 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 1527              	.L129:
 890:./src/lwip/core/pbuf.c ****     }
 891:./src/lwip/core/pbuf.c ****     /* copy the necessary parts of the buffer */
 892:./src/lwip/core/pbuf.c ****     MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 1528              		.loc 1 892 0
 1529 0f6c 10301BE5 		ldr	r3, [fp, #-16]
 1530 0f70 041093E5 		ldr	r1, [r3, #4]
 1531 0f74 B6205BE1 		ldrh	r2, [fp, #-6]
 1532 0f78 1C301BE5 		ldr	r3, [fp, #-28]
 1533 0f7c 032082E0 		add	r2, r2, r3
 1534 0f80 BA305BE1 		ldrh	r3, [fp, #-10]
 1535 0f84 0100A0E1 		mov	r0, r1
 1536 0f88 0210A0E1 		mov	r1, r2
 1537 0f8c 0320A0E1 		mov	r2, r3
 1538 0f90 FEFFFFEB 		bl	memcpy
 893:./src/lwip/core/pbuf.c ****     total_copy_len -= buf_copy_len;
 1539              		.loc 1 893 0
 1540 0f94 B8205BE1 		ldrh	r2, [fp, #-8]	@ movhi
 1541 0f98 BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 1542 0f9c 023063E0 		rsb	r3, r3, r2
 1543 0fa0 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 894:./src/lwip/core/pbuf.c ****     copied_total += buf_copy_len;
 1544              		.loc 1 894 0
 1545 0fa4 B6205BE1 		ldrh	r2, [fp, #-6]	@ movhi
 1546 0fa8 BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 1547 0fac 033082E0 		add	r3, r2, r3
 1548 0fb0 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 1549              		.loc 1 884 0
 1550 0fb4 10301BE5 		ldr	r3, [fp, #-16]
 1551 0fb8 003093E5 		ldr	r3, [r3, #0]
 1552 0fbc 10300BE5 		str	r3, [fp, #-16]
 1553              	.L128:
 1554 0fc0 B8305BE1 		ldrh	r3, [fp, #-8]
 1555 0fc4 000053E3 		cmp	r3, #0
 1556 0fc8 DDFFFF1A 		bne	.L130
 895:./src/lwip/core/pbuf.c ****   }
 896:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 1557              		.loc 1 896 0
 1558 0fcc B8305BE1 		ldrh	r3, [fp, #-8]
 1559 0fd0 000053E3 		cmp	r3, #0
 897:./src/lwip/core/pbuf.c ****   return ERR_OK;
 1560              		.loc 1 897 0
 1561 0fd4 0030A0E3 		mov	r3, #0
 1562              	.L124:
 1563 0fd8 033CA0E1 		mov	r3, r3, asl #24
 1564 0fdc 433CA0E1 		mov	r3, r3, asr #24
 898:./src/lwip/core/pbuf.c **** }
 1565              		.loc 1 898 0
 1566 0fe0 0300A0E1 		mov	r0, r3
 1567 0fe4 04D04BE2 		sub	sp, fp, #4
 1568 0fe8 0048BDE8 		ldmfd	sp!, {fp, lr}
 1569 0fec 1EFF2FE1 		bx	lr
 1570              	.LFE13:
 1572              		.align	2
 1573              		.global	pbuf_coalesce
 1575              	pbuf_coalesce:
 1576              	.LFB14:
 899:./src/lwip/core/pbuf.c **** 
 900:./src/lwip/core/pbuf.c **** /**
 901:./src/lwip/core/pbuf.c ****  * Creates a single pbuf out of a queue of pbufs.
 902:./src/lwip/core/pbuf.c ****  *
 903:./src/lwip/core/pbuf.c ****  * @remark: The source pbuf 'p' is not freed by this function because that can
 904:./src/lwip/core/pbuf.c ****  *          be illegal in some places!
 905:./src/lwip/core/pbuf.c ****  *
 906:./src/lwip/core/pbuf.c ****  * @param p the source pbuf
 907:./src/lwip/core/pbuf.c ****  * @param layer pbuf_layer of the new pbuf
 908:./src/lwip/core/pbuf.c ****  *
 909:./src/lwip/core/pbuf.c ****  * @return a new, single pbuf (p->next is NULL)
 910:./src/lwip/core/pbuf.c ****  *         or the old pbuf if allocation fails
 911:./src/lwip/core/pbuf.c ****  */
 912:./src/lwip/core/pbuf.c **** struct pbuf*
 913:./src/lwip/core/pbuf.c **** pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
 914:./src/lwip/core/pbuf.c **** {
 1577              		.loc 1 914 0
 1578              		@ Function supports interworking.
 1579              		@ args = 0, pretend = 0, frame = 16
 1580              		@ frame_needed = 1, uses_anonymous_args = 0
 1581 0ff0 00482DE9 		stmfd	sp!, {fp, lr}
 1582              	.LCFI42:
 1583 0ff4 04B08DE2 		add	fp, sp, #4
 1584              	.LCFI43:
 1585 0ff8 10D04DE2 		sub	sp, sp, #16
 1586              	.LCFI44:
 1587 0ffc 10000BE5 		str	r0, [fp, #-16]
 1588 1000 0130A0E1 		mov	r3, r1
 1589 1004 11304BE5 		strb	r3, [fp, #-17]
 915:./src/lwip/core/pbuf.c ****   struct pbuf *q;
 916:./src/lwip/core/pbuf.c ****   err_t err;
 917:./src/lwip/core/pbuf.c ****   if (p->next == NULL) {
 1590              		.loc 1 917 0
 1591 1008 10301BE5 		ldr	r3, [fp, #-16]
 1592 100c 003093E5 		ldr	r3, [r3, #0]
 1593 1010 000053E3 		cmp	r3, #0
 1594 1014 0100001A 		bne	.L134
 918:./src/lwip/core/pbuf.c ****     return p;
 1595              		.loc 1 918 0
 1596 1018 10301BE5 		ldr	r3, [fp, #-16]
 1597 101c 160000EA 		b	.L135
 1598              	.L134:
 919:./src/lwip/core/pbuf.c ****   }
 920:./src/lwip/core/pbuf.c ****   q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 1599              		.loc 1 920 0
 1600 1020 10301BE5 		ldr	r3, [fp, #-16]
 1601 1024 B830D3E1 		ldrh	r3, [r3, #8]
 1602 1028 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 1603 102c 0200A0E1 		mov	r0, r2
 1604 1030 0310A0E1 		mov	r1, r3
 1605 1034 0020A0E3 		mov	r2, #0
 1606 1038 FEFFFFEB 		bl	pbuf_alloc
 1607 103c 0030A0E1 		mov	r3, r0
 1608 1040 0C300BE5 		str	r3, [fp, #-12]
 921:./src/lwip/core/pbuf.c ****   if (q == NULL) {
 1609              		.loc 1 921 0
 1610 1044 0C301BE5 		ldr	r3, [fp, #-12]
 1611 1048 000053E3 		cmp	r3, #0
 1612 104c 0100001A 		bne	.L136
 922:./src/lwip/core/pbuf.c ****     /* @todo: what do we do now? */
 923:./src/lwip/core/pbuf.c ****     return p;
 1613              		.loc 1 923 0
 1614 1050 10301BE5 		ldr	r3, [fp, #-16]
 1615 1054 080000EA 		b	.L135
 1616              	.L136:
 924:./src/lwip/core/pbuf.c ****   }
 925:./src/lwip/core/pbuf.c ****   err = pbuf_copy(q, p);
 1617              		.loc 1 925 0
 1618 1058 0C001BE5 		ldr	r0, [fp, #-12]
 1619 105c 10101BE5 		ldr	r1, [fp, #-16]
 1620 1060 FEFFFFEB 		bl	pbuf_copy
 1621 1064 0030A0E1 		mov	r3, r0
 1622 1068 FF3003E2 		and	r3, r3, #255
 1623 106c 05304BE5 		strb	r3, [fp, #-5]
 926:./src/lwip/core/pbuf.c ****   LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 927:./src/lwip/core/pbuf.c ****   pbuf_free(p);
 1624              		.loc 1 927 0
 1625 1070 10001BE5 		ldr	r0, [fp, #-16]
 1626 1074 FEFFFFEB 		bl	pbuf_free
 928:./src/lwip/core/pbuf.c ****   return q;
 1627              		.loc 1 928 0
 1628 1078 0C301BE5 		ldr	r3, [fp, #-12]
 1629              	.L135:
 929:./src/lwip/core/pbuf.c **** }
 1630              		.loc 1 929 0
 1631 107c 0300A0E1 		mov	r0, r3
 1632 1080 04D04BE2 		sub	sp, fp, #4
 1633 1084 0048BDE8 		ldmfd	sp!, {fp, lr}
 1634 1088 1EFF2FE1 		bx	lr
 1635              	.LFE14:
 1982              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 pbuf.c
     /tmp/ccjnC7GI.s:21     .bss:00000000 pbuf_free_ooseq_queued
     /tmp/ccjnC7GI.s:22     .bss:00000000 $d
     /tmp/ccjnC7GI.s:24     .text:00000000 $a
     /tmp/ccjnC7GI.s:26     .text:00000000 pbuf_free_ooseq
     /tmp/ccjnC7GI.s:83     .text:00000080 $d
     /tmp/ccjnC7GI.s:87     .text:00000088 $a
     /tmp/ccjnC7GI.s:89     .text:00000088 pbuf_pool_is_empty
     /tmp/ccjnC7GI.s:134    .text:000000f0 $d
     /tmp/ccjnC7GI.s:138    .text:000000f8 $a
     /tmp/ccjnC7GI.s:141    .text:000000f8 pbuf_alloc
     /tmp/ccjnC7GI.s:167    .text:00000130 $d
     /tmp/ccjnC7GI.s:173    .text:00000140 $a
     /tmp/ccjnC7GI.s:202    .text:00000184 $d
     /tmp/ccjnC7GI.s:208    .text:00000194 $a
     /tmp/ccjnC7GI.s:768    .text:000007d4 pbuf_free
     /tmp/ccjnC7GI.s:460    .text:00000474 pbuf_realloc
     /tmp/ccjnC7GI.s:607    .text:0000061c pbuf_header
     /tmp/ccjnC7GI.s:892    .text:00000908 pbuf_clen
     /tmp/ccjnC7GI.s:937    .text:0000095c pbuf_ref
     /tmp/ccjnC7GI.s:973    .text:000009a0 pbuf_cat
     /tmp/ccjnC7GI.s:1044   .text:00000a54 pbuf_chain
     /tmp/ccjnC7GI.s:1074   .text:00000a88 pbuf_dechain
     /tmp/ccjnC7GI.s:1142   .text:00000b30 pbuf_copy
     /tmp/ccjnC7GI.s:1313   .text:00000d2c pbuf_copy_partial
     /tmp/ccjnC7GI.s:1456   .text:00000eb0 pbuf_take
     /tmp/ccjnC7GI.s:1575   .text:00000ff0 pbuf_coalesce
     /tmp/ccjnC7GI.s:1650   .debug_frame:00000010 $d

UNDEFINED SYMBOLS
tcp_segs_free
tcp_active_pcbs
tcpip_callback_with_block
memp_malloc
mem_malloc
mem_realloc
memp_free
mem_free
memcpy
