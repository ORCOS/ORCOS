/*
 ORCOS - an Organic Reconfigurable Operating System
 Copyright (C) 2008 University of Paderborn

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "BeagleBoardxM.hh"
#include "kernel/Kernel.hh"
#include "inc/memio.h"

extern Kernel* theOS;
extern Board_ClockCfdCl* theClock;
/*
 * Concatenate preprocessor tokens A and B without expanding macro definitions
 * (however, if invoked from a macro, macro arguments are expanded).
 */
#define PPCAT_NX(A, B) A ## B

/*
 * Concatenate preprocessor tokens A and B after macro-expanding them.
 */
#define PPCAT(A, B) PPCAT_NX(A, B)

/*
 * Turn A into a string literal without expanding macro definitions
 * (however, if invoked from a macro, macro arguments are expanded).
 */
#define STRINGIZE_NX(A) #A

/*
 * Turn A into a string literal after macro-expanding it.
 */
#define STRINGIZE(A) STRINGIZE_NX(A)

#define REG_PRM_CLKSEL 0x48306D40

#define CM_CLKSEL1_PLL 0x48004D40
#define CM_CLKSEL2_PLL 0x48004D44
#define CM_CLKSEL3_PLL 0x48004D48

#define CM_CLKSEL4_PLL 0x48004D4c
#define CM_CLKSEL5_PLL 0x48004D50


#define CM_FCLKEN_PER 0x48005000

#define SETBITS(a,UP,LOW,val) a = ((a & ~(( (1 << (UP - LOW + 1)) -1) << LOW)) | ((val & ((1 << (UP - LOW + 1)) -1)) << LOW) )




/*
 * IEN  - Input Enable
 * IDIS - Input Disable
 * PTD  - Pull type Down
 * PTU  - Pull type Up
 * DIS  - Pull type selection is inactive
 * EN   - Pull type selection is active
 * M0   - Mode 0
 */

#define IEN	(1 << 8)

#define IDIS	(0 << 8)
#define PTU	(1 << 4)
#define PTD	(0 << 4)
#define EN	(1 << 3)
#define DIS	(0 << 3)

#define M0	0
#define M1	1
#define M2	2
#define M3	3
#define M4	4
#define M5	5
#define M6	6
#define M7	7

#define OMAP34XX_CTRL_BASE 0x48002000


#define writew(b, addr) (void)((*(volatile unsigned short *) (addr)) = (b))
/*
 * To get the actual address the offset has to added
 * with OMAP34XX_CTRL_BASE to get the actual address
 */

/*SDRC*/
#define CONTROL_PADCONF_SDRC_D0		0x0030
#define CONTROL_PADCONF_SDRC_D1		0x0032
#define CONTROL_PADCONF_SDRC_D2		0x0034
#define CONTROL_PADCONF_SDRC_D3		0x0036
#define CONTROL_PADCONF_SDRC_D4		0x0038
#define CONTROL_PADCONF_SDRC_D5		0x003A
#define CONTROL_PADCONF_SDRC_D6		0x003C
#define CONTROL_PADCONF_SDRC_D7		0x003E
#define CONTROL_PADCONF_SDRC_D8		0x0040
#define CONTROL_PADCONF_SDRC_D9		0x0042
#define CONTROL_PADCONF_SDRC_D10	0x0044
#define CONTROL_PADCONF_SDRC_D11	0x0046
#define CONTROL_PADCONF_SDRC_D12	0x0048
#define CONTROL_PADCONF_SDRC_D13	0x004A
#define CONTROL_PADCONF_SDRC_D14	0x004C
#define CONTROL_PADCONF_SDRC_D15	0x004E
#define CONTROL_PADCONF_SDRC_D16	0x0050
#define CONTROL_PADCONF_SDRC_D17	0x0052
#define CONTROL_PADCONF_SDRC_D18	0x0054
#define CONTROL_PADCONF_SDRC_D19	0x0056
#define CONTROL_PADCONF_SDRC_D20	0x0058
#define CONTROL_PADCONF_SDRC_D21	0x005A
#define CONTROL_PADCONF_SDRC_D22	0x005C
#define CONTROL_PADCONF_SDRC_D23	0x005E
#define CONTROL_PADCONF_SDRC_D24	0x0060
#define CONTROL_PADCONF_SDRC_D25	0x0062
#define CONTROL_PADCONF_SDRC_D26	0x0064
#define CONTROL_PADCONF_SDRC_D27	0x0066
#define CONTROL_PADCONF_SDRC_D28	0x0068
#define CONTROL_PADCONF_SDRC_D29	0x006A
#define CONTROL_PADCONF_SDRC_D30	0x006C
#define CONTROL_PADCONF_SDRC_D31	0x006E
#define CONTROL_PADCONF_SDRC_CLK	0x0070
#define CONTROL_PADCONF_SDRC_DQS0	0x0072
#define CONTROL_PADCONF_SDRC_DQS1	0x0074
#define CONTROL_PADCONF_SDRC_DQS2	0x0076
#define CONTROL_PADCONF_SDRC_DQS3	0x0078
/*GPMC*/
#define CONTROL_PADCONF_GPMC_A1		0x007A
#define CONTROL_PADCONF_GPMC_A2		0x007C
#define CONTROL_PADCONF_GPMC_A3		0x007E
#define CONTROL_PADCONF_GPMC_A4		0x0080
#define CONTROL_PADCONF_GPMC_A5		0x0082
#define CONTROL_PADCONF_GPMC_A6		0x0084
#define CONTROL_PADCONF_GPMC_A7		0x0086
#define CONTROL_PADCONF_GPMC_A8		0x0088
#define CONTROL_PADCONF_GPMC_A9		0x008A
#define CONTROL_PADCONF_GPMC_A10	0x008C
#define CONTROL_PADCONF_GPMC_D0		0x008E
#define CONTROL_PADCONF_GPMC_D1		0x0090
#define CONTROL_PADCONF_GPMC_D2		0x0092
#define CONTROL_PADCONF_GPMC_D3		0x0094
#define CONTROL_PADCONF_GPMC_D4		0x0096
#define CONTROL_PADCONF_GPMC_D5		0x0098
#define CONTROL_PADCONF_GPMC_D6		0x009A
#define CONTROL_PADCONF_GPMC_D7		0x009C
#define CONTROL_PADCONF_GPMC_D8		0x009E
#define CONTROL_PADCONF_GPMC_D9		0x00A0
#define CONTROL_PADCONF_GPMC_D10	0x00A2
#define CONTROL_PADCONF_GPMC_D11	0x00A4
#define CONTROL_PADCONF_GPMC_D12	0x00A6
#define CONTROL_PADCONF_GPMC_D13	0x00A8
#define CONTROL_PADCONF_GPMC_D14	0x00AA
#define CONTROL_PADCONF_GPMC_D15	0x00AC
#define CONTROL_PADCONF_GPMC_NCS0	0x00AE
#define CONTROL_PADCONF_GPMC_NCS1	0x00B0
#define CONTROL_PADCONF_GPMC_NCS2	0x00B2
#define CONTROL_PADCONF_GPMC_NCS3	0x00B4
#define CONTROL_PADCONF_GPMC_NCS4	0x00B6
#define CONTROL_PADCONF_GPMC_NCS5	0x00B8
#define CONTROL_PADCONF_GPMC_NCS6	0x00BA
#define CONTROL_PADCONF_GPMC_NCS7	0x00BC
#define CONTROL_PADCONF_GPMC_CLK	0x00BE
#define CONTROL_PADCONF_GPMC_NADV_ALE	0x00C0
#define CONTROL_PADCONF_GPMC_NOE	0x00C2
#define CONTROL_PADCONF_GPMC_NWE	0x00C4
#define CONTROL_PADCONF_GPMC_NBE0_CLE	0x00C6
#define CONTROL_PADCONF_GPMC_NBE1	0x00C8
#define CONTROL_PADCONF_GPMC_NWP	0x00CA
#define CONTROL_PADCONF_GPMC_WAIT0	0x00CC
#define CONTROL_PADCONF_GPMC_WAIT1	0x00CE
#define CONTROL_PADCONF_GPMC_WAIT2	0x00D0
#define CONTROL_PADCONF_GPMC_WAIT3	0x00D2
/*DSS*/
#define CONTROL_PADCONF_DSS_PCLK	0x00D4
#define CONTROL_PADCONF_DSS_HSYNC	0x00D6
#define CONTROL_PADCONF_DSS_VSYNC	0x00D8
#define CONTROL_PADCONF_DSS_ACBIAS	0x00DA
#define CONTROL_PADCONF_DSS_DATA0	0x00DC
#define CONTROL_PADCONF_DSS_DATA1	0x00DE
#define CONTROL_PADCONF_DSS_DATA2	0x00E0
#define CONTROL_PADCONF_DSS_DATA3	0x00E2
#define CONTROL_PADCONF_DSS_DATA4	0x00E4
#define CONTROL_PADCONF_DSS_DATA5	0x00E6
#define CONTROL_PADCONF_DSS_DATA6	0x00E8
#define CONTROL_PADCONF_DSS_DATA7	0x00EA
#define CONTROL_PADCONF_DSS_DATA8	0x00EC
#define CONTROL_PADCONF_DSS_DATA9	0x00EE
#define CONTROL_PADCONF_DSS_DATA10	0x00F0
#define CONTROL_PADCONF_DSS_DATA11	0x00F2
#define CONTROL_PADCONF_DSS_DATA12	0x00F4
#define CONTROL_PADCONF_DSS_DATA13	0x00F6
#define CONTROL_PADCONF_DSS_DATA14	0x00F8
#define CONTROL_PADCONF_DSS_DATA15	0x00FA
#define CONTROL_PADCONF_DSS_DATA16	0x00FC
#define CONTROL_PADCONF_DSS_DATA17	0x00FE
#define CONTROL_PADCONF_DSS_DATA18	0x0100
#define CONTROL_PADCONF_DSS_DATA19	0x0102
#define CONTROL_PADCONF_DSS_DATA20	0x0104
#define CONTROL_PADCONF_DSS_DATA21	0x0106
#define CONTROL_PADCONF_DSS_DATA22	0x0108
#define CONTROL_PADCONF_DSS_DATA23	0x010A
/*CAMERA*/
#define CONTROL_PADCONF_CAM_HS		0x010C
#define CONTROL_PADCONF_CAM_VS		0x010E
#define CONTROL_PADCONF_CAM_XCLKA	0x0110
#define CONTROL_PADCONF_CAM_PCLK	0x0112
#define CONTROL_PADCONF_CAM_FLD		0x0114
#define CONTROL_PADCONF_CAM_D0		0x0116
#define CONTROL_PADCONF_CAM_D1		0x0118
#define CONTROL_PADCONF_CAM_D2		0x011A
#define CONTROL_PADCONF_CAM_D3		0x011C
#define CONTROL_PADCONF_CAM_D4		0x011E
#define CONTROL_PADCONF_CAM_D5		0x0120
#define CONTROL_PADCONF_CAM_D6		0x0122
#define CONTROL_PADCONF_CAM_D7		0x0124
#define CONTROL_PADCONF_CAM_D8		0x0126
#define CONTROL_PADCONF_CAM_D9		0x0128
#define CONTROL_PADCONF_CAM_D10		0x012A
#define CONTROL_PADCONF_CAM_D11		0x012C
#define CONTROL_PADCONF_CAM_XCLKB	0x012E
#define CONTROL_PADCONF_CAM_WEN		0x0130
#define CONTROL_PADCONF_CAM_STROBE	0x0132
#define CONTROL_PADCONF_CSI2_DX0	0x0134
#define CONTROL_PADCONF_CSI2_DY0	0x0136
#define CONTROL_PADCONF_CSI2_DX1	0x0138
#define CONTROL_PADCONF_CSI2_DY1	0x013A
/*Audio Interface */
#define CONTROL_PADCONF_MCBSP2_FSX	0x013C
#define CONTROL_PADCONF_MCBSP2_CLKX	0x013E
#define CONTROL_PADCONF_MCBSP2_DR	0x0140
#define CONTROL_PADCONF_MCBSP2_DX	0x0142
#define CONTROL_PADCONF_MMC1_CLK	0x0144
#define CONTROL_PADCONF_MMC1_CMD	0x0146
#define CONTROL_PADCONF_MMC1_DAT0	0x0148
#define CONTROL_PADCONF_MMC1_DAT1	0x014A
#define CONTROL_PADCONF_MMC1_DAT2	0x014C
#define CONTROL_PADCONF_MMC1_DAT3	0x014E
#define CONTROL_PADCONF_MMC1_DAT4	0x0150
#define CONTROL_PADCONF_MMC1_DAT5	0x0152
#define CONTROL_PADCONF_MMC1_DAT6	0x0154
#define CONTROL_PADCONF_MMC1_DAT7	0x0156
/*Wireless LAN */
#define CONTROL_PADCONF_MMC2_CLK	0x0158
#define CONTROL_PADCONF_MMC2_CMD	0x015A
#define CONTROL_PADCONF_MMC2_DAT0	0x015C
#define CONTROL_PADCONF_MMC2_DAT1	0x015E
#define CONTROL_PADCONF_MMC2_DAT2	0x0160
#define CONTROL_PADCONF_MMC2_DAT3	0x0162
#define CONTROL_PADCONF_MMC2_DAT4	0x0164
#define CONTROL_PADCONF_MMC2_DAT5	0x0166
#define CONTROL_PADCONF_MMC2_DAT6	0x0168
#define CONTROL_PADCONF_MMC2_DAT7	0x016A
/*Bluetooth*/
#define CONTROL_PADCONF_MCBSP3_DX	0x016C
#define CONTROL_PADCONF_MCBSP3_DR	0x016E
#define CONTROL_PADCONF_MCBSP3_CLKX	0x0170
#define CONTROL_PADCONF_MCBSP3_FSX	0x0172
#define CONTROL_PADCONF_UART2_CTS	0x0174
#define CONTROL_PADCONF_UART2_RTS	0x0176
#define CONTROL_PADCONF_UART2_TX	0x0178
#define CONTROL_PADCONF_UART2_RX	0x017A
/*Modem Interface */
#define CONTROL_PADCONF_UART1_TX	0x017C
#define CONTROL_PADCONF_UART1_RTS	0x017E
#define CONTROL_PADCONF_UART1_CTS	0x0180
#define CONTROL_PADCONF_UART1_RX	0x0182
#define CONTROL_PADCONF_MCBSP4_CLKX	0x0184
#define CONTROL_PADCONF_MCBSP4_DR	0x0186
#define CONTROL_PADCONF_MCBSP4_DX	0x0188
#define CONTROL_PADCONF_MCBSP4_FSX	0x018A
#define CONTROL_PADCONF_MCBSP1_CLKR	0x018C
#define CONTROL_PADCONF_MCBSP1_FSR	0x018E
#define CONTROL_PADCONF_MCBSP1_DX	0x0190
#define CONTROL_PADCONF_MCBSP1_DR	0x0192
#define CONTROL_PADCONF_MCBSP_CLKS	0x0194
#define CONTROL_PADCONF_MCBSP1_FSX	0x0196
#define CONTROL_PADCONF_MCBSP1_CLKX	0x0198
/*Serial Interface*/
#define CONTROL_PADCONF_UART3_CTS_RCTX	0x019A
#define CONTROL_PADCONF_UART3_RTS_SD	0x019C
#define CONTROL_PADCONF_UART3_RX_IRRX	0x019E
#define CONTROL_PADCONF_UART3_TX_IRTX	0x01A0
#define CONTROL_PADCONF_HSUSB0_CLK	0x01A2
#define CONTROL_PADCONF_HSUSB0_STP	0x01A4
#define CONTROL_PADCONF_HSUSB0_DIR	0x01A6
#define CONTROL_PADCONF_HSUSB0_NXT	0x01A8
#define CONTROL_PADCONF_HSUSB0_DATA0	0x01AA
#define CONTROL_PADCONF_HSUSB0_DATA1	0x01AC
#define CONTROL_PADCONF_HSUSB0_DATA2	0x01AE
#define CONTROL_PADCONF_HSUSB0_DATA3	0x01B0
#define CONTROL_PADCONF_HSUSB0_DATA4	0x01B2
#define CONTROL_PADCONF_HSUSB0_DATA5	0x01B4
#define CONTROL_PADCONF_HSUSB0_DATA6	0x01B6
#define CONTROL_PADCONF_HSUSB0_DATA7	0x01B8
#define CONTROL_PADCONF_I2C1_SCL	0x01BA
#define CONTROL_PADCONF_I2C1_SDA	0x01BC
#define CONTROL_PADCONF_I2C2_SCL	0x01BE
#define CONTROL_PADCONF_I2C2_SDA	0x01C0
#define CONTROL_PADCONF_I2C3_SCL	0x01C2
#define CONTROL_PADCONF_I2C3_SDA	0x01C4
#define CONTROL_PADCONF_I2C4_SCL	0x0A00
#define CONTROL_PADCONF_I2C4_SDA	0x0A02
#define CONTROL_PADCONF_HDQ_SIO		0x01C6
#define CONTROL_PADCONF_MCSPI1_CLK	0x01C8
#define CONTROL_PADCONF_MCSPI1_SIMO	0x01CA
#define CONTROL_PADCONF_MCSPI1_SOMI	0x01CC
#define CONTROL_PADCONF_MCSPI1_CS0	0x01CE
#define CONTROL_PADCONF_MCSPI1_CS1	0x01D0
#define CONTROL_PADCONF_MCSPI1_CS2	0x01D2
#define CONTROL_PADCONF_MCSPI1_CS3	0x01D4
#define CONTROL_PADCONF_MCSPI2_CLK	0x01D6
#define CONTROL_PADCONF_MCSPI2_SIMO	0x01D8
#define CONTROL_PADCONF_MCSPI2_SOMI	0x01DA
#define CONTROL_PADCONF_MCSPI2_CS0	0x01DC
#define CONTROL_PADCONF_MCSPI2_CS1	0x01DE
/*Control and debug */
#define CONTROL_PADCONF_SYS_32K		0x0A04
#define CONTROL_PADCONF_SYS_CLKREQ	0x0A06
#define CONTROL_PADCONF_SYS_NIRQ	0x01E0
#define CONTROL_PADCONF_SYS_BOOT0	0x0A0A
#define CONTROL_PADCONF_SYS_BOOT1	0x0A0C
#define CONTROL_PADCONF_SYS_BOOT2	0x0A0E
#define CONTROL_PADCONF_SYS_BOOT3	0x0A10
#define CONTROL_PADCONF_SYS_BOOT4	0x0A12
#define CONTROL_PADCONF_SYS_BOOT5	0x0A14
#define CONTROL_PADCONF_SYS_BOOT6	0x0A16
#define CONTROL_PADCONF_SYS_OFF_MODE	0x0A18
#define CONTROL_PADCONF_SYS_CLKOUT1	0x0A1A
#define CONTROL_PADCONF_SYS_CLKOUT2	0x01E2
#define CONTROL_PADCONF_JTAG_nTRST	0x0A1C
#define CONTROL_PADCONF_JTAG_TCK	0x0A1E
#define CONTROL_PADCONF_JTAG_TMS	0x0A20
#define CONTROL_PADCONF_JTAG_TDI	0x0A22
#define CONTROL_PADCONF_JTAG_EMU0	0x0A24
#define CONTROL_PADCONF_JTAG_EMU1	0x0A26
#define CONTROL_PADCONF_ETK_CLK		0x0A28
#define CONTROL_PADCONF_ETK_CTL		0x0A2A
#define CONTROL_PADCONF_ETK_D0		0x0A2C
#define CONTROL_PADCONF_ETK_D1		0x0A2E
#define CONTROL_PADCONF_ETK_D2		0x0A30
#define CONTROL_PADCONF_ETK_D3		0x0A32
#define CONTROL_PADCONF_ETK_D4		0x0A34
#define CONTROL_PADCONF_ETK_D5		0x0A36
#define CONTROL_PADCONF_ETK_D6		0x0A38
#define CONTROL_PADCONF_ETK_D7		0x0A3A
#define CONTROL_PADCONF_ETK_D8		0x0A3C
#define CONTROL_PADCONF_ETK_D9		0x0A3E
#define CONTROL_PADCONF_ETK_D10		0x0A40
#define CONTROL_PADCONF_ETK_D11		0x0A42
#define CONTROL_PADCONF_ETK_D12		0x0A44
#define CONTROL_PADCONF_ETK_D13		0x0A46
#define CONTROL_PADCONF_ETK_D14		0x0A48
#define CONTROL_PADCONF_ETK_D15		0x0A4A
#define CONTROL_PADCONF_ETK_CLK_ES2	0x05D8
#define CONTROL_PADCONF_ETK_CTL_ES2	0x05DA
#define CONTROL_PADCONF_ETK_D0_ES2	0x05DC
#define CONTROL_PADCONF_ETK_D1_ES2	0x05DE
#define CONTROL_PADCONF_ETK_D2_ES2	0x05E0
#define CONTROL_PADCONF_ETK_D3_ES2	0x05E2
#define CONTROL_PADCONF_ETK_D4_ES2	0x05E4
#define CONTROL_PADCONF_ETK_D5_ES2	0x05E6
#define CONTROL_PADCONF_ETK_D6_ES2	0x05E8
#define CONTROL_PADCONF_ETK_D7_ES2	0x05EA
#define CONTROL_PADCONF_ETK_D8_ES2	0x05EC
#define CONTROL_PADCONF_ETK_D9_ES2	0x05EE
#define CONTROL_PADCONF_ETK_D10_ES2	0x05F0
#define CONTROL_PADCONF_ETK_D11_ES2	0x05F2
#define CONTROL_PADCONF_ETK_D12_ES2	0x05F4
#define CONTROL_PADCONF_ETK_D13_ES2	0x05F6
#define CONTROL_PADCONF_ETK_D14_ES2	0x05F8
#define CONTROL_PADCONF_ETK_D15_ES2	0x05FA
/*Die to Die */
#define CONTROL_PADCONF_D2D_MCAD0	0x01E4
#define CONTROL_PADCONF_D2D_MCAD1	0x01E6
#define CONTROL_PADCONF_D2D_MCAD2	0x01E8
#define CONTROL_PADCONF_D2D_MCAD3	0x01EA
#define CONTROL_PADCONF_D2D_MCAD4	0x01EC
#define CONTROL_PADCONF_D2D_MCAD5	0x01EE
#define CONTROL_PADCONF_D2D_MCAD6	0x01F0
#define CONTROL_PADCONF_D2D_MCAD7	0x01F2
#define CONTROL_PADCONF_D2D_MCAD8	0x01F4
#define CONTROL_PADCONF_D2D_MCAD9	0x01F6
#define CONTROL_PADCONF_D2D_MCAD10	0x01F8
#define CONTROL_PADCONF_D2D_MCAD11	0x01FA
#define CONTROL_PADCONF_D2D_MCAD12	0x01FC
#define CONTROL_PADCONF_D2D_MCAD13	0x01FE
#define CONTROL_PADCONF_D2D_MCAD14	0x0200
#define CONTROL_PADCONF_D2D_MCAD15	0x0202
#define CONTROL_PADCONF_D2D_MCAD16	0x0204
#define CONTROL_PADCONF_D2D_MCAD17	0x0206
#define CONTROL_PADCONF_D2D_MCAD18	0x0208
#define CONTROL_PADCONF_D2D_MCAD19	0x020A
#define CONTROL_PADCONF_D2D_MCAD20	0x020C
#define CONTROL_PADCONF_D2D_MCAD21	0x020E
#define CONTROL_PADCONF_D2D_MCAD22	0x0210
#define CONTROL_PADCONF_D2D_MCAD23	0x0212
#define CONTROL_PADCONF_D2D_MCAD24	0x0214
#define CONTROL_PADCONF_D2D_MCAD25	0x0216
#define CONTROL_PADCONF_D2D_MCAD26	0x0218
#define CONTROL_PADCONF_D2D_MCAD27	0x021A
#define CONTROL_PADCONF_D2D_MCAD28	0x021C
#define CONTROL_PADCONF_D2D_MCAD29	0x021E
#define CONTROL_PADCONF_D2D_MCAD30	0x0220
#define CONTROL_PADCONF_D2D_MCAD31	0x0222
#define CONTROL_PADCONF_D2D_MCAD32	0x0224
#define CONTROL_PADCONF_D2D_MCAD33	0x0226
#define CONTROL_PADCONF_D2D_MCAD34	0x0228
#define CONTROL_PADCONF_D2D_MCAD35	0x022A
#define CONTROL_PADCONF_D2D_MCAD36	0x022C
#define CONTROL_PADCONF_D2D_CLK26MI	0x022E
#define CONTROL_PADCONF_D2D_NRESPWRON	0x0230
#define CONTROL_PADCONF_D2D_NRESWARM	0x0232
#define CONTROL_PADCONF_D2D_ARM9NIRQ	0x0234
#define CONTROL_PADCONF_D2D_UMA2P6FIQ	0x0236
#define CONTROL_PADCONF_D2D_SPINT	0x0238
#define CONTROL_PADCONF_D2D_FRINT	0x023A
#define CONTROL_PADCONF_D2D_DMAREQ0	0x023C
#define CONTROL_PADCONF_D2D_DMAREQ1	0x023E
#define CONTROL_PADCONF_D2D_DMAREQ2	0x0240
#define CONTROL_PADCONF_D2D_DMAREQ3	0x0242
#define CONTROL_PADCONF_D2D_N3GTRST	0x0244
#define CONTROL_PADCONF_D2D_N3GTDI	0x0246
#define CONTROL_PADCONF_D2D_N3GTDO	0x0248
#define CONTROL_PADCONF_D2D_N3GTMS	0x024A
#define CONTROL_PADCONF_D2D_N3GTCK	0x024C
#define CONTROL_PADCONF_D2D_N3GRTCK	0x024E
#define CONTROL_PADCONF_D2D_MSTDBY	0x0250
#define CONTROL_PADCONF_D2D_SWAKEUP	0x0A4C
#define CONTROL_PADCONF_D2D_IDLEREQ	0x0252
#define CONTROL_PADCONF_D2D_IDLEACK	0x0254
#define CONTROL_PADCONF_D2D_MWRITE	0x0256
#define CONTROL_PADCONF_D2D_SWRITE	0x0258
#define CONTROL_PADCONF_D2D_MREAD	0x025A
#define CONTROL_PADCONF_D2D_SREAD	0x025C
#define CONTROL_PADCONF_D2D_MBUSFLAG	0x025E
#define CONTROL_PADCONF_D2D_SBUSFLAG	0x0260
#define CONTROL_PADCONF_SDRC_CKE0	0x0262
#define CONTROL_PADCONF_SDRC_CKE1	0x0264

/* AM3517 specific mux configuration */
#define CONTROL_PADCONF_SYS_NRESWARM	0x0A08
/* CCDC */
#define CONTROL_PADCONF_CCDC_PCLK	0x01E4
#define CONTROL_PADCONF_CCDC_FIELD	0x01E6
#define CONTROL_PADCONF_CCDC_HD		0x01E8
#define CONTROL_PADCONF_CCDC_VD		0x01EA
#define CONTROL_PADCONF_CCDC_WEN	0x01EC
#define CONTROL_PADCONF_CCDC_DATA0	0x01EE
#define CONTROL_PADCONF_CCDC_DATA1	0x01F0
#define CONTROL_PADCONF_CCDC_DATA2	0x01F2
#define CONTROL_PADCONF_CCDC_DATA3	0x01F4
#define CONTROL_PADCONF_CCDC_DATA4	0x01F6
#define CONTROL_PADCONF_CCDC_DATA5	0x01F8
#define CONTROL_PADCONF_CCDC_DATA6	0x01FA
#define CONTROL_PADCONF_CCDC_DATA7	0x01FC
/* RMII */
#define CONTROL_PADCONF_RMII_MDIO_DATA	0x01FE
#define CONTROL_PADCONF_RMII_MDIO_CLK	0x0200
#define CONTROL_PADCONF_RMII_RXD0	0x0202
#define CONTROL_PADCONF_RMII_RXD1	0x0204
#define CONTROL_PADCONF_RMII_CRS_DV	0x0206
#define CONTROL_PADCONF_RMII_RXER	0x0208
#define CONTROL_PADCONF_RMII_TXD0	0x020A
#define CONTROL_PADCONF_RMII_TXD1	0x020C
#define CONTROL_PADCONF_RMII_TXEN	0x020E
#define CONTROL_PADCONF_RMII_50MHZ_CLK	0x0210
#define CONTROL_PADCONF_USB0_DRVBUS	0x0212
/* CAN */
#define CONTROL_PADCONF_HECC1_TXD	0x0214
#define CONTROL_PADCONF_HECC1_RXD	0x0216

#define CONTROL_PADCONF_SYS_BOOT7	0x0218
#define CONTROL_PADCONF_SDRC_DQS0N	0x021A
#define CONTROL_PADCONF_SDRC_DQS1N	0x021C
#define CONTROL_PADCONF_SDRC_DQS2N	0x021E
#define CONTROL_PADCONF_SDRC_DQS3N	0x0220
#define CONTROL_PADCONF_STRBEN_DLY0	0x0222
#define CONTROL_PADCONF_STRBEN_DLY1	0x0224
#define CONTROL_PADCONF_SYS_BOOT8	0x0226

/* AM/DM37xx specific */
#define CONTROL_PADCONF_GPIO127		0x0A54
#define CONTROL_PADCONF_GPIO126		0x0A56
#define CONTROL_PADCONF_GPIO128		0x0A58
#define CONTROL_PADCONF_GPIO129		0x0A5A

/* AM/DM37xx specific: gpio_127, gpio_127 and gpio_129 require configuration
 * of the extended drain cells */
#define OMAP34XX_CTRL_WKUP_CTRL		(OMAP34XX_CTRL_BASE + 0x0A5C)
#define OMAP34XX_CTRL_WKUP_CTRL_GPIO_IO_PWRDNZ	(1<<6)

#define MUX_VAL(OFFSET,VALUE)\
		writew((VALUE), OMAP34XX_CTRL_BASE + (OFFSET));

#define	CP(x)	(CONTROL_PADCONF_##x)



/* BeagleBoard revisions */
#define REVISION_AXBX	0x7
#define REVISION_CX	0x6
#define REVISION_C4	0x5
#define REVISION_XM_A	0x0
#define REVISION_XM_B	0x1
#define REVISION_XM_C	0x2

/*
 * IEN  - Input Enable
 * IDIS - Input Disable
 * PTD  - Pull type Down
 * PTU  - Pull type Up
 * DIS  - Pull type selection is inactive
 * EN   - Pull type selection is active
 * M0   - Mode 0
 * The commented string gives the final mux configuration for that pin
 */
#define MUX_BEAGLE() \
 /*SDRC*/\
	MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
	MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
	MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
	MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
	MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
	MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
	MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
	MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
	MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
	MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
	MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
	MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
	MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
	MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
	MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
	MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
	MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
	MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
	MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
	MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
	MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
	MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
	MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
	MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
	MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
	MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
	MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
	MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
	MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
	MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
	MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
	MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
	MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
	MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
	MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
	MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
	MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
 /*GPMC*/\
	MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
	MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
	MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
	MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
	MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
	MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
	MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
	MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
	MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
	MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
	MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
	MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
	MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
	MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
	MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
	MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
	MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
	MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
	MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
	MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
	MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
	MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
	MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
	MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
	MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
	MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
	MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
	MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
	MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
	MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS3*/\
	MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS4*/\
	MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M0)) /*GPMC_nCS5*/\
	MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M1)) /*SYS_nDMA_REQ2*/\
	MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M1)) /*SYS_nDMA_REQ3*/\
	MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTD | DIS | M0)) /*GPMC_nBE1*/\
	MUX_VAL(CP(GPMC_WAIT2),		(IEN  | PTU | EN  | M0)) /*GPMC_WAIT2*/\
	MUX_VAL(CP(GPMC_WAIT3),		(IEN  | PTU | EN  | M0)) /*GPMC_WAIT3*/\
	MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0)) /*GPMC_CLK*/\
	MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
	MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
	MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
	MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTD | DIS | M0)) /*GPMC_nBE0_CLE*/\
	MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) /*GPMC_nWP*/\
	MUX_VAL(CP(GPMC_WAIT0),		(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
	MUX_VAL(CP(GPMC_WAIT1),		(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
 /*DSS*/\
	MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
	MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
	MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
	MUX_VAL(CP(DSS_ACBIAS),		(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
	MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
	MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
	MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
	MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
	MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
	MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
	MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
	MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
	MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
	MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
	MUX_VAL(CP(DSS_DATA10),		(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
	MUX_VAL(CP(DSS_DATA11),		(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
	MUX_VAL(CP(DSS_DATA12),		(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
	MUX_VAL(CP(DSS_DATA13),		(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
	MUX_VAL(CP(DSS_DATA14),		(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
	MUX_VAL(CP(DSS_DATA15),		(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
	MUX_VAL(CP(DSS_DATA16),		(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
	MUX_VAL(CP(DSS_DATA17),		(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
	MUX_VAL(CP(DSS_DATA18),		(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
	MUX_VAL(CP(DSS_DATA19),		(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
	MUX_VAL(CP(DSS_DATA20),		(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
	MUX_VAL(CP(DSS_DATA21),		(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
	MUX_VAL(CP(DSS_DATA22),		(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
	MUX_VAL(CP(DSS_DATA23),		(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
 /*CAMERA*/\
	MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) /*CAM_HS */\
	MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) /*CAM_VS */\
	MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
	MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
	MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*GPIO_98*/\
	MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) /*CAM_D0*/\
	MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) /*CAM_D1*/\
	MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /*CAM_D2*/\
	MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /*CAM_D3*/\
	MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /*CAM_D4*/\
	MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /*CAM_D5*/\
	MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) /*CAM_D6*/\
	MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) /*CAM_D7*/\
	MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) /*CAM_D8*/\
	MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) /*CAM_D9*/\
	MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /*CAM_D10*/\
	MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /*CAM_D11*/\
	MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
	MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /*GPIO_167*/\
	MUX_VAL(CP(CAM_STROBE),		(IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
	MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
	MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
	MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) /*CSI2_DX1*/\
	MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) /*CSI2_DY1*/\
 /*Audio Interface */\
	MUX_VAL(CP(MCBSP2_FSX),		(IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
	MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
	MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
	MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
 /*Expansion card */\
	MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
	MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
	MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
	MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
	MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
	MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
	MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
	MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
	MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
	MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
 /*Wireless LAN */\
	MUX_VAL(CP(MMC2_CLK),		(IEN  | PTU | EN  | M4)) /*GPIO_130*/\
	MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M4)) /*GPIO_131*/\
	MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M4)) /*GPIO_132*/\
	MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M4)) /*GPIO_133*/\
	MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M4)) /*GPIO_134*/\
	MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M4)) /*GPIO_135*/\
	MUX_VAL(CP(MMC2_DAT4),		(IEN  | PTU | EN  | M4)) /*GPIO_136*/\
	MUX_VAL(CP(MMC2_DAT5),		(IEN  | PTU | EN  | M4)) /*GPIO_137*/\
	MUX_VAL(CP(MMC2_DAT6),		(IEN  | PTU | EN  | M4)) /*GPIO_138*/\
	MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M4)) /*GPIO_139*/\
 /*Bluetooth*/\
	MUX_VAL(CP(MCBSP3_DX),		(IEN  | PTD | DIS | M1)) /*UART2_CTS*/\
	MUX_VAL(CP(MCBSP3_DR),		(IDIS | PTD | DIS | M1)) /*UART2_RTS*/\
	MUX_VAL(CP(MCBSP3_CLKX),	(IDIS | PTD | DIS | M1)) /*UART2_TX*/\
	MUX_VAL(CP(MCBSP3_FSX),		(IEN  | PTD | DIS | M1)) /*UART2_RX*/\
	MUX_VAL(CP(UART2_CTS),		(IEN  | PTD | DIS | M4)) /*GPIO_144*/\
	MUX_VAL(CP(UART2_RTS),		(IEN  | PTD | DIS | M4)) /*GPIO_145*/\
	MUX_VAL(CP(UART2_TX),		(IEN  | PTD | DIS | M4)) /*GPIO_146*/\
	MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147*/\
 /*Modem Interface */\
	MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
	MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M4)) /*GPIO_149*/ \
	MUX_VAL(CP(UART1_CTS),		(IDIS | PTD | DIS | M4)) /*GPIO_150*/ \
	MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
	MUX_VAL(CP(MCBSP4_CLKX),	(IEN  | PTD | DIS | M1)) /*SSI1_DAT_RX*/\
	MUX_VAL(CP(MCBSP4_DR),		(IEN  | PTD | DIS | M1)) /*SSI1_FLAG_RX*/\
	MUX_VAL(CP(MCBSP4_DX),		(IEN  | PTD | DIS | M1)) /*SSI1_RDY_RX*/\
	MUX_VAL(CP(MCBSP4_FSX),		(IEN  | PTD | DIS | M1)) /*SSI1_WAKE*/\
	MUX_VAL(CP(MCBSP1_CLKR),	(IDIS | PTD | DIS | M4)) /*GPIO_156*/\
	MUX_VAL(CP(MCBSP1_FSR),		(IDIS | PTU | EN  | M4)) /*GPIO_157*/\
	MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_158*/\
	MUX_VAL(CP(MCBSP1_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_159*/\
	MUX_VAL(CP(MCBSP_CLKS),		(IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
	MUX_VAL(CP(MCBSP1_FSX),		(IDIS | PTD | DIS | M4)) /*GPIO_161*/\
	MUX_VAL(CP(MCBSP1_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_162*/\
 /*Serial Interface*/\
	MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_RCTX*/\
	MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
	MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
	MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
	MUX_VAL(CP(HSUSB0_CLK),		(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
	MUX_VAL(CP(HSUSB0_STP),		(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
	MUX_VAL(CP(HSUSB0_DIR),		(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
	MUX_VAL(CP(HSUSB0_NXT),		(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
	MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
	MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
	MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
	MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
	MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
	MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
	MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
	MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
	MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
	MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
	MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)) /*I2C2_SCL*/\
	MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)) /*I2C2_SDA*/\
	MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
	MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
	MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
	MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
	MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*GPIO_170*/\
	MUX_VAL(CP(MCSPI1_CLK),		(IEN  | PTU | EN  | M4)) /*GPIO_171*/\
	MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTU | EN  | M4)) /*GPIO_172*/\
	MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTU | EN  | M4)) /*GPIO_173*/\
	MUX_VAL(CP(MCSPI1_CS0),		(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
	MUX_VAL(CP(MCSPI1_CS1),		(IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
	MUX_VAL(CP(MCSPI1_CS2),		(IDIS | PTD | DIS | M4)) /*GPIO_176*/\
 /* USB EHCI (port 2) */\
	MUX_VAL(CP(MCSPI1_CS3),		(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA2*/\
	MUX_VAL(CP(MCSPI2_CLK),		(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA7*/\
	MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA4*/\
	MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA5*/\
	MUX_VAL(CP(MCSPI2_CS0),		(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA6*/\
	MUX_VAL(CP(MCSPI2_CS1),		(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA3*/\
	MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTD | DIS | M3)) /*HSUSB2_CLK*/\
	MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTD | DIS | M3)) /*HSUSB2_STP*/\
	MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTD | EN  | M3)) /*HSUSB2_DIR*/\
	MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTD | EN  | M3)) /*HSUSB2_NXT*/\
	MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA0*/\
	MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTD | EN  | M3)) /*HSUSB2_DATA1*/\
 /*Control and debug */\
	MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
	MUX_VAL(CP(SYS_CLKREQ),		(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
	MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
	MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
	MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3*/\
	MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4 - MMC1_WP*/\
	MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
	MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
	MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
	MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/ \
	MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
	MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
	MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M4)) /*GPIO_186*/\
	MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M3)) /*HSUSB1_STP*/\
	MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB1_CLK*/\
	MUX_VAL(CP(ETK_D0_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA0*/\
	MUX_VAL(CP(ETK_D1_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA1*/\
	MUX_VAL(CP(ETK_D2_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA2*/\
	MUX_VAL(CP(ETK_D3_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA7*/\
	MUX_VAL(CP(ETK_D4_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA4*/\
	MUX_VAL(CP(ETK_D5_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA5*/\
	MUX_VAL(CP(ETK_D6_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA6*/\
	MUX_VAL(CP(ETK_D7_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA3*/\
	MUX_VAL(CP(ETK_D8_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_DIR*/\
	MUX_VAL(CP(ETK_D9_ES2),		(IEN  | PTU | DIS | M3)) /*HSUSB1_NXT*/\
	MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
	MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
	MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
	MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
	MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
	MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
	MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
	MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
	MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
	MUX_VAL(CP(D2D_MCAD10),		(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
	MUX_VAL(CP(D2D_MCAD11),		(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
	MUX_VAL(CP(D2D_MCAD12),		(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
	MUX_VAL(CP(D2D_MCAD13),		(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
	MUX_VAL(CP(D2D_MCAD14),		(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
	MUX_VAL(CP(D2D_MCAD15),		(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
	MUX_VAL(CP(D2D_MCAD16),		(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
	MUX_VAL(CP(D2D_MCAD17),		(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
	MUX_VAL(CP(D2D_MCAD18),		(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
	MUX_VAL(CP(D2D_MCAD19),		(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
	MUX_VAL(CP(D2D_MCAD20),		(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
	MUX_VAL(CP(D2D_MCAD21),		(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
	MUX_VAL(CP(D2D_MCAD22),		(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
	MUX_VAL(CP(D2D_MCAD23),		(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
	MUX_VAL(CP(D2D_MCAD24),		(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
	MUX_VAL(CP(D2D_MCAD25),		(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
	MUX_VAL(CP(D2D_MCAD26),		(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
	MUX_VAL(CP(D2D_MCAD27),		(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
	MUX_VAL(CP(D2D_MCAD28),		(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
	MUX_VAL(CP(D2D_MCAD29),		(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
	MUX_VAL(CP(D2D_MCAD30),		(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
	MUX_VAL(CP(D2D_MCAD31),		(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
	MUX_VAL(CP(D2D_MCAD32),		(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
	MUX_VAL(CP(D2D_MCAD33),		(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
	MUX_VAL(CP(D2D_MCAD34),		(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
	MUX_VAL(CP(D2D_MCAD35),		(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
	MUX_VAL(CP(D2D_MCAD36),		(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
	MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
	MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
	MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
	MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
	MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
	MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
	MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
	MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
	MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
	MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
	MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
	MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
	MUX_VAL(CP(D2D_N3GTDI),		(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
	MUX_VAL(CP(D2D_N3GTDO),		(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
	MUX_VAL(CP(D2D_N3GTMS),		(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
	MUX_VAL(CP(D2D_N3GTCK),		(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
	MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
	MUX_VAL(CP(D2D_MSTDBY),		(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
	MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
	MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
	MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
	MUX_VAL(CP(D2D_MWRITE),		(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
	MUX_VAL(CP(D2D_SWRITE),		(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
	MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
	MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
	MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
	MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
	MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
	MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTU | EN  | M0)) /*sdrc_cke1*/

#define MUX_BEAGLE_C() \
	MUX_VAL(CP(MCBSP3_DX),		(IEN  | PTD | DIS | M4)) /*GPIO_140*/\
	MUX_VAL(CP(MCBSP3_DR),		(IEN  | PTD | DIS | M4)) /*GPIO_142*/\
	MUX_VAL(CP(MCBSP3_CLKX),	(IEN  | PTD | DIS | M4)) /*GPIO_141*/\
	MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M0)) /*UART2_CTS*/\
	MUX_VAL(CP(UART2_RTS),		(IDIS | PTD | DIS | M0)) /*UART2_RTS*/\
	MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0)) /*UART2_TX*/\
	MUX_VAL(CP(UART2_RX),		(IDIS | PTU | EN  | M4)) /*GPIO_147*/

#define MUX_BEAGLE_XM() \
	MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | EN  | M4)) /*GPIO_56*/\
	MUX_VAL(CP(GPMC_WAIT0),		(IDIS | PTU | EN  | M4)) /*GPIO_63*/\
	MUX_VAL(CP(MMC1_DAT7),		(IDIS | PTU | EN  | M4)) /*GPIO_129*/\
	MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*GPIO_170*/\
	MUX_VAL(CP(MCBSP3_DX),		(IEN  | PTD | DIS | M4)) /*GPIO_140*/\
	MUX_VAL(CP(MCBSP3_DR),		(IEN  | PTD | DIS | M4)) /*GPIO_142*/\
	MUX_VAL(CP(MCBSP3_CLKX),	(IEN  | PTD | DIS | M4)) /*GPIO_141*/\
	MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M0)) /*UART2_CTS*/\
	MUX_VAL(CP(UART2_RTS),		(IDIS | PTD | DIS | M0)) /*UART2_RTS*/\
	MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0)) /*UART2_TX*/\
	MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M7)) /*safe_mode*/\
	MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M7)) /*safe_mode*/\
	MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M7)) /*safe_mode*/\
	MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M7)) /*safe_mode*/\
	MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M7)) /*safe_mode*/\
	MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M7)) /*safe_mode*/\
	MUX_VAL(CP(DSS_DATA18),		(IDIS | PTD | DIS | M3)) /*DSS_DATA0*/\
	MUX_VAL(CP(DSS_DATA19),		(IDIS | PTD | DIS | M3)) /*DSS_DATA1*/\
	MUX_VAL(CP(DSS_DATA20),		(IDIS | PTD | DIS | M3)) /*DSS_DATA2*/\
	MUX_VAL(CP(DSS_DATA21),		(IDIS | PTD | DIS | M3)) /*DSS_DATA3*/\
	MUX_VAL(CP(DSS_DATA22),		(IDIS | PTD | DIS | M3)) /*DSS_DATA4*/\
	MUX_VAL(CP(DSS_DATA23),		(IDIS | PTD | DIS | M3)) /*DSS_DATA5*/\
	MUX_VAL(CP(SYS_BOOT0),		(IDIS | PTD | DIS | M3)) /*DSS_DATA18*/\
	MUX_VAL(CP(SYS_BOOT1),		(IDIS | PTD | DIS | M3)) /*DSS_DATA19*/\
	MUX_VAL(CP(SYS_BOOT3),		(IDIS | PTD | DIS | M3)) /*DSS_DATA20*/\
	MUX_VAL(CP(SYS_BOOT4),		(IDIS | PTD | DIS | M3)) /*DSS_DATA21*/\
	MUX_VAL(CP(SYS_BOOT5),		(IDIS | PTD | DIS | M3)) /*DSS_DATA22*/\
	MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M3)) /*DSS_DATA23*/

#define MUX_TINCANTOOLS_ZIPPY() \
	MUX_VAL(CP(MMC2_CLK),       (IEN  | PTU | EN  | M0)) /*MMC2_CLK*/\
	MUX_VAL(CP(MMC2_CMD),       (IEN  | PTU | EN  | M0)) /*MMC2_CMD*/\
	MUX_VAL(CP(MMC2_DAT0),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT0*/\
	MUX_VAL(CP(MMC2_DAT1),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT1*/\
	MUX_VAL(CP(MMC2_DAT2),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT2*/\
	MUX_VAL(CP(MMC2_DAT3),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT3*/\
	MUX_VAL(CP(MMC2_DAT4),      (IEN  | PTU | EN  | M1)) /*MMC2_DIR_DAT0*/\
	MUX_VAL(CP(MMC2_DAT5),      (IEN  | PTU | EN  | M1)) /*MMC2_DIR_DAT1*/\
	MUX_VAL(CP(MMC2_DAT6),      (IEN  | PTU | EN  | M1)) /*MMC2_DIR_CMD*/\
	MUX_VAL(CP(MMC2_DAT7),      (IEN  | PTU | EN  | M1)) /*MMC2_CLKIN*/\
	MUX_VAL(CP(MCBSP1_CLKR),    (IEN  | PTU | EN  | M1)) /*MCSPI4_CLK*/\
	MUX_VAL(CP(MCBSP1_FSR),     (IEN  | PTU | EN  | M4)) /*GPIO_157*/\
	MUX_VAL(CP(MCBSP1_DX),      (IEN  | PTD | EN  | M1)) /*MCSPI4_SIMO*/\
	MUX_VAL(CP(MCBSP1_DR),      (IEN  | PTD | DIS | M1)) /*MCSPI4_SOMI*/\
	MUX_VAL(CP(MCBSP1_FSX),     (IEN  | PTD | EN  | M1)) /*MCSPI4_CS0*/\
	MUX_VAL(CP(MCBSP1_CLKX),    (IEN  | PTD | DIS | M4)) /*GPIO_162*/\
	MUX_VAL(CP(MCBSP3_DX),      (IEN  | PTD | DIS | M4)) /*GPIO_140*/\
	MUX_VAL(CP(MCBSP3_DR),      (IEN  | PTD | DIS | M4)) /*GPIO_142*/\
	MUX_VAL(CP(MCBSP3_CLKX),    (IEN  | PTD | DIS | M4)) /*GPIO_141*/

#define MUX_TINCANTOOLS_TRAINER() \
	MUX_VAL(CP(MMC2_CLK),       (IEN  | PTU | EN  | M4)) /*GPIO_130*/\
	MUX_VAL(CP(MMC2_CMD),       (IEN  | PTU | EN  | M4)) /*GPIO_131*/\
	MUX_VAL(CP(MMC2_DAT0),      (IEN  | PTU | EN  | M4)) /*GPIO_132*/\
	MUX_VAL(CP(MMC2_DAT1),      (IEN  | PTU | EN  | M4)) /*GPIO_133*/\
	MUX_VAL(CP(MMC2_DAT2),      (IEN  | PTU | EN  | M4)) /*GPIO_134*/\
	MUX_VAL(CP(MMC2_DAT3),      (IEN  | PTU | EN  | M4)) /*GPIO_135*/\
	MUX_VAL(CP(MMC2_DAT4),      (IEN  | PTU | EN  | M4)) /*GPIO_136*/\
	MUX_VAL(CP(MMC2_DAT5),      (IEN  | PTU | EN  | M4)) /*GPIO_137*/\
	MUX_VAL(CP(MMC2_DAT6),      (IEN  | PTU | EN  | M4)) /*GPIO_138*/\
	MUX_VAL(CP(MMC2_DAT7),      (IEN  | PTU | EN  | M4)) /*GPIO_139*/\
	MUX_VAL(CP(MCBSP3_DX),      (IEN  | PTU | EN  | M4)) /*GPIO_140*/\
	MUX_VAL(CP(MCBSP3_CLKX),    (IEN  | PTU | EN  | M4)) /*GPIO_141*/\
	MUX_VAL(CP(MCBSP1_CLKX),    (IEN  | PTU | EN  | M4)) /*GPIO_162*/

#define MUX_KBADC_BEAGLEFPGA() \
	MUX_VAL(CP(MCBSP1_CLKR),    (IEN  | PTU | DIS | M1)) /*MCSPI4_CLK*/\
	MUX_VAL(CP(MCBSP1_DX),      (IDIS | PTU | DIS | M1)) /*MCSPI4_SIMO*/\
	MUX_VAL(CP(MCBSP1_DR),      (IEN  | PTU | EN  | M1)) /*MCSPI4_SOMI*/\
	MUX_VAL(CP(MCBSP1_FSX),     (IDIS | PTU | DIS | M1)) /*MCSPI4_CS0*/

#define MUX_BBTOYS_WIFI() \
	MUX_VAL(CP(MMC2_CLK),       (IEN  | PTU | EN  | M0)) /*MMC2_CLK*/\
	MUX_VAL(CP(MMC2_CMD),       (IEN  | PTU | EN  | M0)) /*MMC2_CMD*/\
	MUX_VAL(CP(MMC2_DAT0),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT0*/\
	MUX_VAL(CP(MMC2_DAT1),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT1*/\
	MUX_VAL(CP(MMC2_DAT2),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT2*/\
	MUX_VAL(CP(MMC2_DAT3),      (IEN  | PTU | EN  | M0)) /*MMC2_DAT3*/\
	MUX_VAL(CP(MMC2_DAT4),      (IDIS | PTU | EN  | M4)) /*GPIO_136 FM_EN/BT_WU*/\
	MUX_VAL(CP(MMC2_DAT5),      (IEN  | PTU | EN  | M4)) /*GPIO_137 WLAN_IRQ*/\
	MUX_VAL(CP(MMC2_DAT6),      (IDIS | PTU | EN  | M4)) /*GPIO_138 BT_EN*/\
	MUX_VAL(CP(MMC2_DAT7),      (IDIS | PTU | EN  | M4)) /*GPIO_139 WLAN_EN*/

#define GPIO0                           (0x1 << 0)
#define GPIO1                           (0x1 << 1)
#define GPIO2                           (0x1 << 2)
#define GPIO3                           (0x1 << 3)
#define GPIO4                           (0x1 << 4)
#define GPIO5                           (0x1 << 5)
#define GPIO6                           (0x1 << 6)
#define GPIO7                           (0x1 << 7)
#define GPIO8                           (0x1 << 8)
#define GPIO9                           (0x1 << 9)
#define GPIO10                          (0x1 << 10)
#define GPIO11                          (0x1 << 11)
#define GPIO12                          (0x1 << 12)
#define GPIO13                          (0x1 << 13)
#define GPIO14                          (0x1 << 14)
#define GPIO15                          (0x1 << 15)
#define GPIO16                          (0x1 << 16)
#define GPIO17                          (0x1 << 17)
#define GPIO18                          (0x1 << 18)
#define GPIO19                          (0x1 << 19)
#define GPIO20                          (0x1 << 20)
#define GPIO21                          (0x1 << 21)
#define GPIO22                          (0x1 << 22)
#define GPIO23                          (0x1 << 23)
#define GPIO24                          (0x1 << 24)
#define GPIO25                          (0x1 << 25)
#define GPIO26                          (0x1 << 26)
#define GPIO27                          (0x1 << 27)
#define GPIO28                          (0x1 << 28)
#define GPIO29                          (0x1 << 29)
#define GPIO30                          (0x1 << 30)
#define GPIO31                          (0x1 << 31)





BeagleBoardxM::BeagleBoardxM() {



	/*
	 * Tables for 36XX/37XX devices
	 *
	 */
	//	mpu_36x_dpll_param:
	//	.word 300, 12, 0, 1

	//iva_36x_dpll_param:
	/* 26MHz */
	//	.word 10, 0, 0, 1

	//core_36x_dpll_param:
	/* 26MHz */
	// .word 200, 12, 0, 1

	//	per_36x_dpll_param:
	/*    SYSCLK    M       N      M2      M3      M4     M5      M6      m2DIV */
    //	.word 26000,    432,   12,     9,      16,     9,     4,      3,      1

	/*unint4 m = 432*2 ;
	//unint4 m = 432 ;
	unint4 n = 12;
	unint4 m2 = 9 ;
	unint4 m3 = 16 ;
	unint4 m4 = 9 ;
	unint4 m5 = 4 ;
	unint4 m6 = 3 ;

	unint4 core_m = 332;
	//unint4 core_m = 200;
	unint4 core_n = 12;*/

	// set to 26mhz sys_clk
	OUTW(REG_PRM_CLKSEL,3);
	//uboot: 0x48306d40: 00000003

	// core clock is set by dpll3
	// also sets 54mhz to DPLL4_M3
	// 96 Mhz to CM_96M
	//unint4 cm_clksel1_val = core_n << 8 | core_m << 16 | 1 << 27;
	//OUTW(CM_CLKSEL1_PLL,cm_clksel1_val);
	OUTW(CM_CLKSEL1_PLL,0x09900c00);
	// uboot: 0x48004d40: 09900c00
	// core_n = 12 = 0xc
	// core_m = 400 = 0x190

	// set core L3 and L4 divider
	// CM_CLKSEL_CORE
	//OUTW(0x48004a40,2 | 2 << 2 | 1 << 12);
	//OUTW(0x48004a40,0x1f0a);

	//OUTW(0x48004a40,0x1f0a);
	OUTW(0x48004a40,0x0000130a);
	// uboot: 0x48004a40: 0000130a

	// L4 @ 166 mhz , L3 @ 332 mhz

	OUTW(0x48307270,0x80);
	// uboot: 0x48307270: 00000080


	// controls dpll4
	//unint4 sd_val = 8; // ((26 * m / (n+1)) / 250) +1;
	//unint4 cm_clksel2_val = n | m << 8 | 0x4 << 21 | sd_val << 24;
	//OUTW(CM_CLKSEL2_PLL,cm_clksel2_val);

	OUTW(CM_CLKSEL2_PLL,0x0483600c);
	// uboot: 0x48004d44: 0483600c
	// n = 12 = 0xc
	// m = 864 = 0x360

	// sets the divider for 96 Mhz clock: 96 Mhz = DPLL4 clock / this value
	//unint4 cm_slksel3_val = m2;
 	//OUTW(CM_CLKSEL3_PLL,cm_slksel3_val);

	OUTW(CM_CLKSEL3_PLL,0x9);
 	// uboot m2 = 9

 	OUTW(0x48004d00,0x370037);   // lock DPLL3


	// sets DPLL5
	//OUTW(CM_CLKSEL4_PLL,0x01bb0b);
 	//OUTW(CM_CLKSEL4_PLL,(120 << 8) | 25);
	OUTW(CM_CLKSEL4_PLL,0x0000780c);
 	// uboot 0x48004d4c: 0000780c


 	// 120 MHZ = DPPL5 / regival
 	//OUTW(CM_CLKSEL5_PLL,0x8);
	OUTW(CM_CLKSEL5_PLL,0x1);
	// uboot : 1

 	OUTW(0x48004d34,0x0); 		 // disable auto stop mode of dpll5
 	//OUTW(0x48004d04,0x7); 	     // lock DPLL5

 	OUTW(0x48004d04,0x17);
 	// uboot : 0x17
 	//OUTW(0x48004d04,0xf); 	     // lock DPLL5 and enable automatic recalibration


 	//unint4 cm_clksel_dss_val = m4 | m3 << 8;
	//OUTW(0x48004e40,cm_clksel_dss_val);
	OUTW(0x48004e40,0x00001009);
	// uboot 0x48004e40: 00001009

	//OUTW(0x48005140,m6<<24);
	OUTW(0x48005140,0x03020a50);
	// uboot : 0x48005140: 03020a50

 	// set clsel PLL IVA2
 	OUTW(0x48004040,0x81400);
 	// uboot : 0x48004040: 00081400

 	// lock iva2
 	//OUTW(0x48004004,0x00000037);
 	OUTW(0x48004004,0x00000017);
 	// uboot: 0x48004004: 00000017

 	//unint4 mpu_m = 200;
 	//unint4 mpu_m = 300;
 	//unint4 mpu_n = 12;
 	//unint4 cm_clksel1_pll_mpu_val = mpu_n | mpu_m << 8 | 1 << 19;

 	// set mpu (dpll1) divider
 	//OUTW(0x48004940,cm_clksel1_pll_mpu_val);
 	OUTW(0x48004940,0x0012580c);
 	// uboot: 0x48004940: 0012580c

	OUTW(0x48004944,1);
	// uboot: 1

	// lock mpu
 	OUTW(0x48004904,0x00000037);
 	// uboot: 37

 	//OUTW(0x48004940,0x12580c);
 	// lock mpu

 	// set GPT clock sources to sys_clk = 26 mhz
 	//OUTW(0x48005040,0xff);


 	// set GPT clock sources to 32K_FCLK
 	//OUTW(0x48005040,0x0);
 	OUTW(0x48005040,0xff);
 	// uboot: 0x48005040: 000000ff




 	 // enable all functional and interface clocks
	// OUTW(0x48005000,0xFFFFFFFF);
 	// enable gpio 5+6 functional clock and uart3
 	 OUTW(0x48005000,0x30800);
	 //OUTW(0x48005010,0xFFFFFFFF);
 	OUTW(0x48005010,0x30800);

// created first so we can very early write to the serial console
// to e.g. write error messages!
#ifdef HAS_Board_UARTCfd

     UARTCfd = new NEW_Board_UARTCfd;
#if __EARLY_SERIAL_SUPPORT__
     theOS->setStdOutputDevice( UARTCfd );
#endif
 	LOG(ARCH,INFO,(ARCH,INFO,""));
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardXM Initializing..."));

     #define BoardUART_str "[K][INFO ] Board UART: '" Board_UART_NAME "' [" STRINGIZE(Board_UARTCfdCl) "]\r"
     printf(BoardUART_str);
#endif


    unint4 cm_idlest_wkup = INW(0x48004c20);
	if ((cm_idlest_wkup & 0)) {
		printf("ERROR: GPTIMER1 cannot be accessed..");
	}
	if ((cm_idlest_wkup & (1<<2))) {
		printf("ERROR: 32k Sync Timer cannot be accessed..");
	}
	if ((cm_idlest_wkup & (1<<3))) {
		printf("ERROR: GPIO1 cannot be accessed..");
	}
	if ((cm_idlest_wkup & (1<<5))) {
		printf("ERROR: WDTIMER2 cannot be accessed..");
	}


     // enable clocks of most components uart1-3 i2c1-3 a.s.o
 	OUTW(0x48004A00,0x03fffe29);

 	OUTW(0x48004A10,0x3ffffffb);
 	OUTW(0x48004A14,0x0000001f);
 	OUTW(0x48004c00,0x000000e9);
 	OUTW(0x48004c10,0x0000003f);

 	//OUTW(0x48004c00,0x1 | 1 << 3 | 1 << 5);
 	//OUTW(0x48004c10,0x1 | 1 << 2 | 1 << 3 | 1 << 5);
	//OUTW(0x48004c40,0x1 | 1 << 1 | 0x2 << 3);

	OUTW(0x48004c40,0x15);
	// uboot 0x48004c40: 00000015

	OUTW(0x48004c30,0x0);

// 	unint4 cm_core = INW(0x48004A40);
 //	SETBITS(cm_core,13,12,2);
 	//OUTW(0x48004A40,cm_core);

	// enable i2c pullup
	OUTW(0x48000000 + 0x2000 + 0x448,~(0x00000001));

	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM: CM_FCLKEN1_CORE  =%x",INW(0x48004A00)));
	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM: CM_CLKSEL_CORE   =%x",INW(0x48004A40)));
	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM: CM_CLKSEL1_PLL   =%x",INW(0x48004D40)));
	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM: CM_IDLEST2_CKGEN =%x",INW(0x48004d24)));


 	unint sys_clk = INW(REG_PRM_CLKSEL);
 	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM: PRM_CLKSEL       =%d",sys_clk));


 	unint sys_clock = 26000;

 	if (sys_clk == 4)
 		sys_clock = 38400;
 	else
 	if (sys_clk == 3)
 		sys_clock = 26000;
 	else
 	if (sys_clk == 2)
 		sys_clock = 19200;
 	else
 	if (sys_clk == 1)
 		sys_clock = 13000;
 	else
 	if (sys_clk == 0)
 		sys_clock = 12000;

 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: System Clock      = %d kHz",sys_clock));

 	unint m_dpll3 = (INW(CM_CLKSEL1_PLL) >> 16) & 0x7ff;  // dpll3 multiplier
 	unint n_dpll3 = (INW(CM_CLKSEL1_PLL) >> 8) & 0x7f;  // dpll3 divisor
 	unint f_clkout = (sys_clock * m_dpll3) / (n_dpll3+1);
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: f_CLKOUT          = %d kHz ", f_clkout));
 	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM:                     [m = %d, n = %d]",m_dpll3,n_dpll3));

 	unint m2_dpll3 = INW(CM_CLKSEL1_PLL) >> 27;
 	unint core_clock = f_clkout / m2_dpll3;   // dpll3 output clock
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: CORE_CLOCK        = %d kHz ", core_clock));
 	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM:                     [m2 = %d]",m2_dpll3));


 	unint4 m_dpll4 = (INW(CM_CLKSEL2_PLL) >> 8) & 0x7ff;
 	unint4 n_dpll4 = INW(CM_CLKSEL2_PLL) & 0x7f;
 	unint dpll4_clock = (sys_clock * m_dpll4) / (n_dpll4+1);
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: DPLL4_CLOCK       = %d kHz ", dpll4_clock));
 	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM:                     [m = %d, n = %d]",m_dpll4,n_dpll4));
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: DPLL4_AWON_FCLKOUT= %d kHz", dpll4_clock * 2));

 	unint4 mhz54clock = dpll4_clock / (INW(0x48004e40) >> 8);
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: 54Mhz Clock       = %d kHz", mhz54clock));

 	unint mhz96clock = dpll4_clock / (INW(CM_CLKSEL3_PLL) & 0x1f);
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: 96Mhz Clock       = %d kHz ", mhz96clock));
 	LOG(ARCH,DEBUG,(ARCH,DEBUG,"BeagleBoardxM: DIV_96M           = %d",(INW(CM_CLKSEL3_PLL) & 0x1f)));

 	unint4 m_dpll5 = (INW(CM_CLKSEL4_PLL) >> 8) & 0x7ff;
 	unint4 n_dpll5 = INW(CM_CLKSEL4_PLL) & 0x7f;
 	unint4 dpll5_clock = (sys_clock * m_dpll5) / (n_dpll5+1);
 	unint mhz120clock = dpll5_clock / (INW(CM_CLKSEL5_PLL) & 0x1f);
 	LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: 120Mhz Clock      = %d kHz ", mhz120clock));


 	unint4 cm_idlest1 = INW(0x48004d20);
 	if (!(cm_idlest1 & 1)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: DPLL3 not locked.."));
 	}
 	if (!(cm_idlest1 & 2)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: DPLL4 not locked.."));
 	}
 	if (!(cm_idlest1 & 1 << 2)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: 96Mhz FCLK clock not active.."));
 	}
 	if (!(cm_idlest1 & 1 << 3)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: 48Mhz clock not active.."));
 	}
 	if (!(cm_idlest1 & 1 << 4)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: 12Mhz clock not active.."));
 	}
 	if (!(cm_idlest1 & 1 << 5)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: 54Mhz clock not active.."));
 	}
 	if (!(cm_idlest1 & 1 << 9)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: DPLL4_M2_CLK clock not active.."));
 	}
 	if (!(cm_idlest1 & 1 << 10)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: DPLL4_M3_CLK clock not active.."));
 	}

 	unint4 cm_idlest2 = INW(0x48004d24);
 	if (!(cm_idlest2 & 1)) {
 		LOG(ARCH,ERROR,(ARCH,ERROR,"BeagleBoardxM: ERROR: DPLL5 not locked.."));
 	}

 	// set all mux values
 	MUX_BEAGLE();

 	MUX_BEAGLE_XM();



 	/* Set GPIO states before they are made outputs */
 	// GPIO6

 	OUTW(0x49058000 + 0x94, GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1);
 	// GPIO5
    OUTW(0x49056000 + 0x94, GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 | GPIO15 | GPIO14 | GPIO13 | GPIO12);

 	/* Configure GPIOs to output */
    //GPIO6
 	OUTW(0x49058000 + 0x34, ~(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1));
 	// GPIO5
 	OUTW(0x49056000 + 0x34,~(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 | GPIO15 | GPIO14 | GPIO13 | GPIO12));


#ifdef HAS_Board_UART2Cfd
     UART2Cfd = new NEW_Board_UART2Cfd;
	 #define BoardUART2_str "[K][INFO ] Board UART2: '" Board_UART2_NAME "' [" STRINGIZE(Board_UART2CfdCl) "]\r"
     printf(BoardUART2_str );
#endif

    // Processor
#ifdef HAS_Board_ProcessorCfd
     LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: Board Processor [" STRINGIZE(Board_ProcessorCfdCl) "]" ));
     ProcessorCfd = new NEW_Board_ProcessorCfd;
#endif

    // Watchdog
#ifdef HAS_Board_WatchdogCfd
    WatchdogCfd = new NEW_Board_WatchdogCfd;
    //getWatchdog()->enable();
#endif

    // Timer
#ifdef HAS_Board_TimerCfd
    LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: Board Timer [" STRINGIZE(Board_TimerCfdCl) "]") );
    TimerCfd = new NEW_Board_TimerCfd;
#endif

    // Clock
#ifdef HAS_Board_ClockCfd
    LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: Board Clock [" STRINGIZE(Board_ClockCfdCl) "]") );
    ClockCfd = new NEW_Board_ClockCfd;
    theClock = ClockCfd; // clock is now available for other devices
#endif

    // LED Interface
#ifdef HAS_Board_LEDCfd
    LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: Board LED: '" Board_LED_NAME  "' [" STRINGIZE(Board_LEDCfdCl) "]" ));
    LEDCfd = new NEW_Board_LEDCfd;
#endif

#ifdef HAS_Board_USB_HCCfd
    LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: USB Host-Controller: [" STRINGIZE(USB_HCCfdCl) "]" ));

    USB_HCCfd = new NEW_Board_USB_HCCfd;

 	// enable the EHCI interrupt source inside the MPU interrupt controller
 	OUTW(MPU_INTCPS_MIR_CLEAR(2), 0x2000 ); // enable interrupt: (ehci int no. 77: (77 mod 32) + 2): position of bit

#endif

#ifdef HAS_Board_UARTCfd
#ifdef HAS_BoardLEDCfd
    UARTCfd->setLED( LEDCfd );
#endif
#endif

#ifdef HAS_Board_ETHCfd
    ETHCfd = new NEW_Board_ETHCfd;
#endif

#ifdef HAS_Board_UART3Cfd
     UART3Cfd = new NEW_Board_UART3Cfd;
#endif

    // InterruptHandler
#ifdef HAS_Board_InterruptHandlerCfd
    InterruptHandlerCfd = new NEW_Board_InterruptHandlerCfd;
    LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: Board Interrupt Handler: [" STRINGIZE(Board_InterruptHandlerCfdCl) "]" ));
#endif

    // OPB_Interrupt_Controller
#ifdef HAS_Board_InterruptControllerCfd
    InterruptControllerCfd = new NEW_Board_InterruptControllerCfd;
    LOG(ARCH,INFO,(ARCH,INFO,"BeagleBoardxM: Board Interrupt Controller: [" STRINGIZE(Board_InterruptControllerCfdCl) "]" ) );
    InterruptControllerCfd->clearIRQ(1);
#endif

	unint prod_id = *((unint *) 0x4830A20C);
	LOG(ARCH,INFO,(ARCH,INFO,"OMAP PROD_ID : %x",prod_id));

 /*   LOG(ARCH,INFO,(ARCH,INFO,"Starting Display Subsystem (DSS) LCD Output."));
    dss = new BeagleBoardDSS("dss");
    dss->init();
    */
    // theOS->setStdOutputDevice( dss );

}

BeagleBoardxM::~BeagleBoardxM() {
}
