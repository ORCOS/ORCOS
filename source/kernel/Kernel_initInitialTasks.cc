#include "Kernel.hh"
#include "SCLConfig.hh"

//! table containing references to the tasktables of every task (generated by linker)
extern unint4 tasktable;
extern Kernel* theOS;
extern void* __KERNELEND;
extern void* __RAM_END;

/*!
 * \brief Initialize method for the initial task set with virtual memory
 */
void Kernel::initInitialTaskSet()
{
    unint4 num_tasks = tasktable;

    register MemoryManagerCfdCl* OSMemManager = theOS->getMemManager();

    for ( unint4 i = 1; i <= num_tasks * 3; i+=3 ) {

    	LOG(KERNEL,INFO,(KERNEL,INFO,"Creating Initial Task"));

        // get the taskTable of task number i
        taskTable* task_info = (taskTable*) *( &tasktable + i );

        LOG(KERNEL,INFO,(KERNEL,INFO,"TaskCB @0x%x", task_info));

        // now do some sanity checks to ensure the correct boot process even if tasktable is corrupt
        int sane = 1;
        if ((void*) task_info->task_heap_end <= (void*) task_info->task_heap_start) sane = 0;
        if ((void*) task_info->task_heap_start < &__KERNELEND) sane = 0;
        if ((void*) task_info->task_heap_end < &__KERNELEND) sane = 0;
        if ((void*) task_info->task_heap_start > &__RAM_END) sane = 0;
        if ((void*) task_info->task_heap_end > &__RAM_END) sane = 0;

	#ifndef HAS_MemoryManager_HatLayerCfd
        if ((void*) task_info->task_start_addr < &__KERNELEND) sane = 0;
        if ((void*) task_info->task_start_addr > &__RAM_END) sane = 0;
        if ((void*) task_info->task_data_end < &__KERNELEND) sane = 0;
	#endif

        if (sane == 1) {
        // create the memory manager for the task
        void* memaddr = OSMemManager->alloc(sizeof(MemoryManagerCfdCl),true);

        #ifndef HAS_MemoryManager_HatLayerCfd
            MemoryManagerCfdCl* task_memManager =
                       new ( memaddr ) MemoryManagerCfdCl( (void*) task_info->task_heap_start, (void*) task_info->task_heap_end);

           /*
            * create a new Task CB in Kernel Space!! only holds information about the task.
            * The task code itself remains at task_info->task_start_addr
            */
           Task* task = new Task( task_memManager, task_info );

           LOG(KERNEL,INFO,(KERNEL,INFO,"TaskID %d:" ,task->getId()));
           LOG(KERNEL,INFO,(KERNEL,INFO,"start at 0x%x, end  at 0x%x" , task->getTaskTable()->task_start_addr, task->getTaskTable()->task_heap_end));
           LOG(KERNEL,INFO,(KERNEL,INFO,"entry at 0x%x, exit at 0x%x" , task->getTaskTable()->task_entry_addr, task->getTaskTable()->task_thread_exit_addr));
           LOG(KERNEL,INFO,(KERNEL,INFO,"heap  at 0x%x, size %d" , task->getTaskTable()->task_heap_start, (int) task->getTaskTable()->task_heap_end - (int)  task->getTaskTable()->task_heap_start));

        #else
           // we get the ID of the task we will create next
           TaskIdT tid = Task::getIdOfNextCreatedTask();

           // get the heap start address
           unint4 task_heap_start = (unint4) *( &tasktable + i + 1 );
           // get the task end address
           unint4 task_end = (unint4) *( &tasktable + i + 2 );
           // get the size of the task area
           unint4 size = task_end - (unint4) task_info;

           LOG(KERNEL,INFO,(KERNEL,INFO,"Task %d:" ,tid));
           LOG(KERNEL,INFO,(KERNEL,INFO,"start at 0x%x, end at 0x%x" , task_info, task_end));
           LOG(KERNEL,INFO,(KERNEL,INFO,"heap at 0x%x, size %d" , task_heap_start, size));

           // create the vm map for the task! protection = 7 = RWX, ZoneSelect = 3
           getHatLayer()->map((void*) LOG_TASK_SPACE_START,(void*) task_info, size ,7,3,tid, !ICACHE_ENABLE);
           // now since the task is mapped activate its virtual memory map by setting the pid
           SETPID(tid);


            MemoryManagerCfdCl* task_memManager =
                    new(memaddr)  MemoryManagerCfdCl((void*) (LOG_TASK_SPACE_START + ( task_heap_start -  (unint4) task_info)),
                            (void*) (LOG_TASK_SPACE_START + size ) );

            //LOG(KERNEL,INFO,(KERNEL,INFO,"Kernel: creating TaskCB"));

            /*
             * create a new Task CB in Kernel Space!! only holds information about the task.
             * The task code itself remains at task_info->task_start_addr
             */
            Task* task = new Task( task_memManager, (taskTable*) LOG_TASK_SPACE_START );
        #endif

        this->taskDatabase->addTail( task );
        task->myTaskDbItem = this->taskDatabase->getTail();
        task->run();

/*        LOG(KERNEL,INFO,(KERNEL,INFO,"Kernel: Task %d:" ,task->getId()));
        LOG(KERNEL,INFO,(KERNEL,INFO,"Kernel: start at 0x%x, end at 0x%x" , task->getTaskTable()->task_start_addr, task->getTaskTable()->task_heap_end));
        LOG(KERNEL,INFO,(KERNEL,INFO,"Kernel: entry at 0x%x, exit at 0x%x" , task->getTaskTable()->task_entry_addr, task->getTaskTable()->task_thread_exit_addr));
        LOG(KERNEL,INFO,(KERNEL,INFO,"Kernel: heap at 0x%x, size %d" , task->getTaskTable()->task_heap_start, (int) task->getTaskTable()->task_heap_end - (int)  task->getTaskTable()->task_heap_start));
*/

    #ifdef HAS_MemoryManager_HatLayerCfd
        SETPID(0);
    #endif

        } else {
        	 LOG(KERNEL,ERROR,(KERNEL,ERROR,"TaskCB corrupted.. task informations invalid.. dropping task"));
        }
    }
}

